(in-package racer)

;;;
;;;----------------------------------------------
;;;       Automatically Generated Racer Stubs    
;;;          Version: 2.0, Build: 2013-03-07 
;;;          Date: March 07 2013, 13:05  
;;;----------------------------------------------
;;;

(defun abort-all-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abort-all-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun abort-all-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abort-all-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun abort-query ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abort-query"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun abort-rule ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abort-rule"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun abox-consistent-if-assertions-added-p ( abox assertions)
 (declare (ignorable  abox assertions))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abox-consistent-if-assertions-added-p"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr assertions))
      ")" )))

   (service-request req-string))))

(defun abox-consistent-p ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abox-consistent-p"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun abox-entails-abox-p ( a b &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox a b))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abox-entails-abox-p"
      (myformat nil " ~S" (transform-s-expr a))
      (myformat nil " ~S" (transform-s-expr b))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun abox-prepared-p ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abox-prepared-p"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun abox-realized-p ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abox-realized-p"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun abox-una-consistent-p ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abox-una-consistent-p"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun accurate-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "accurate-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun accurate-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "accurate-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun activate-defined-query ( name arity &key  (pos nil pos-supplied-p) (tbox nil tbox-supplied-p))
 (declare (ignorable  pos tbox name arity))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "activate-defined-query"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr arity))
      (when pos-supplied-p (myformat nil " :pos ~S" (transform-s-expr pos)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun active-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "active-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun active-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "active-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun add-all-different-assertion ( abox individual-name-set)
 (declare (ignorable  abox individual-name-set))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-all-different-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual-name-set))
      ")" )))

   (service-request req-string))))

(defun add-annotation-concept-assertion ( abox individual-name concept)
 (declare (ignorable  abox individual-name concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-annotation-concept-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual-name))
      (myformat nil " ~S" (transform-s-expr concept))
      ")" )))

   (service-request req-string))))

(defun add-annotation-role-assertion ( abox predecessor-name filler-name role-term)
 (declare (ignorable  abox predecessor-name filler-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-annotation-role-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr predecessor-name))
      (myformat nil " ~S" (transform-s-expr filler-name))
      (myformat nil " ~S" (transform-s-expr role-term))
      ")" )))

   (service-request req-string))))

(defun add-attribute-assertion ( abox individual object attribute)
 (declare (ignorable  abox individual object attribute))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-attribute-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr object))
      (myformat nil " ~S" (transform-s-expr attribute))
      ")" )))

   (service-request req-string))))

(defun add-chosen-sets-of-rule-consequences ( query &key  (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p))
 (declare (ignorable  dont-add-abox-duplicates-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-chosen-sets-of-rule-consequences"
      (myformat nil " ~S" (transform-s-expr query))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      ")" )))

   (service-request req-string))))

(defun add-concept-assertion ( abox individual-name concept)
 (declare (ignorable  abox individual-name concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-concept-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual-name))
      (myformat nil " ~S" (transform-s-expr concept))
      ")" )))

   (service-request req-string))))

(defun add-concept-axiom ( tbox left right &key  (inclusion-p nil inclusion-p-supplied-p))
 (declare (ignorable  inclusion-p tbox left right))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-concept-axiom"
      (myformat nil " ~S" (transform-s-expr tbox))
      (myformat nil " ~S" (transform-s-expr left))
      (myformat nil " ~S" (transform-s-expr right))
      (when inclusion-p-supplied-p (myformat nil " :inclusion-p ~S" (transform-s-expr inclusion-p)))
      ")" )))

   (service-request req-string))))

(defun add-constraint-assertion ( abox constraint)
 (declare (ignorable  abox constraint))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-constraint-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr constraint))
      ")" )))

   (service-request req-string))))

(defun add-datatype-property ( tbox name &rest  args)
 (declare (ignorable  args tbox name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-datatype-property"
      (myformat nil " ~S" (transform-s-expr tbox))
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   (service-request req-string))))

(defun add-datatype-role-filler ( abox individual value role &optional  (type nil type-supplied-p))
 (declare (ignorable  type abox individual value role))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-datatype-role-filler"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr value))
      (myformat nil " ~S" (transform-s-expr role))
      (when type-supplied-p (myformat nil " ~S" (transform-s-expr type)))
      ")" )))

   (service-request req-string))))

(defun add-different-from-assertion ( abox individual-name-1 individual-name-2)
 (declare (ignorable  abox individual-name-1 individual-name-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-different-from-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual-name-1))
      (myformat nil " ~S" (transform-s-expr individual-name-2))
      ")" )))

   (service-request req-string))))

(defun add-disjointness-axiom ( tbox concept-name group-name &optional  (form nil form-supplied-p))
 (declare (ignorable  form tbox concept-name group-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-disjointness-axiom"
      (myformat nil " ~S" (transform-s-expr tbox))
      (myformat nil " ~S" (transform-s-expr concept-name))
      (myformat nil " ~S" (transform-s-expr group-name))
      (when form-supplied-p (myformat nil " ~S" (transform-s-expr form)))
      ")" )))

   (service-request req-string))))

(defun add-doc-entry1 ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-doc-entry1"
      ")" )))

   (service-request req-string))))

(defun add-doc-image-data-from-file1 ( url type pathname)
 (declare (ignorable  url type pathname))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-doc-image-data-from-file1"
      (myformat nil " ~S" (transform-s-expr url))
      (myformat nil " ~S" (transform-s-expr type))
      (myformat nil " ~S" (transform-s-expr pathname))
      ")" )))

   (service-request req-string))))

(defun add-doc-image-data1 ( url type bytes)
 (declare (ignorable  url type bytes))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-doc-image-data1"
      (myformat nil " ~S" (transform-s-expr url))
      (myformat nil " ~S" (transform-s-expr type))
      (myformat nil " ~S" (transform-s-expr bytes))
      ")" )))

   (service-request req-string))))

(defun add-doc-image-file1 ( url type pathname)
 (declare (ignorable  url type pathname))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-doc-image-file1"
      (myformat nil " ~S" (transform-s-expr url))
      (myformat nil " ~S" (transform-s-expr type))
      (myformat nil " ~S" (transform-s-expr pathname))
      ")" )))

   (service-request req-string))))

(defun add-doc-phrase1 ( label string)
 (declare (ignorable  label string))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-doc-phrase1"
      (myformat nil " ~S" (transform-s-expr label))
      (myformat nil " ~S" (transform-s-expr string))
      ")" )))

   (service-request req-string))))

(defun add-event-assertion ( assertion &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox assertion))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-event-assertion"
      (myformat nil " ~S" (transform-s-expr assertion))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun add-event-rule ( head body &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox head body))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-event-rule"
      (myformat nil " ~S" (transform-s-expr head))
      (myformat nil " ~S" (transform-s-expr body))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun add-explanation-assertions ( query expl-no &key  (from nil from-supplied-p) (to nil to-supplied-p) (only-best-p nil only-best-p-supplied-p) (order-by nil order-by-supplied-p) (reverse-order-p nil reverse-order-p-supplied-p) (equi-order-by nil equi-order-by-supplied-p) (remove-marker-symbols-p nil remove-marker-symbols-p-supplied-p) (remove-entailed-explanations-p nil remove-entailed-explanations-p-supplied-p) (new-inds-p nil new-inds-p-supplied-p) (tuples-p nil tuples-p-supplied-p) (full-tuples-p nil full-tuples-p-supplied-p) (all-assertions-p nil all-assertions-p-supplied-p) (hypothesized-assertions-p nil hypothesized-assertions-p-supplied-p) (show-score-p nil show-score-p-supplied-p) (abox-entailment nil abox-entailment-supplied-p) (ensure-permutations-p nil ensure-permutations-p-supplied-p))
 (declare (ignorable  from to only-best-p order-by reverse-order-p equi-order-by remove-marker-symbols-p remove-entailed-explanations-p new-inds-p tuples-p full-tuples-p all-assertions-p hypothesized-assertions-p show-score-p abox-entailment ensure-permutations-p query expl-no))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-explanation-assertions"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr expl-no))
      (when from-supplied-p (myformat nil " :from ~S" (transform-s-expr from)))
      (when to-supplied-p (myformat nil " :to ~S" (transform-s-expr to)))
      (when only-best-p-supplied-p (myformat nil " :only-best-p ~S" (transform-s-expr only-best-p)))
      (when order-by-supplied-p (myformat nil " :order-by ~S" (transform-s-expr order-by)))
      (when reverse-order-p-supplied-p (myformat nil " :reverse-order-p ~S" (transform-s-expr reverse-order-p)))
      (when equi-order-by-supplied-p (myformat nil " :equi-order-by ~S" (transform-s-expr equi-order-by)))
      (when remove-marker-symbols-p-supplied-p (myformat nil " :remove-marker-symbols-p ~S" (transform-s-expr remove-marker-symbols-p)))
      (when remove-entailed-explanations-p-supplied-p (myformat nil " :remove-entailed-explanations-p ~S" (transform-s-expr remove-entailed-explanations-p)))
      (when new-inds-p-supplied-p (myformat nil " :new-inds-p ~S" (transform-s-expr new-inds-p)))
      (when tuples-p-supplied-p (myformat nil " :tuples-p ~S" (transform-s-expr tuples-p)))
      (when full-tuples-p-supplied-p (myformat nil " :full-tuples-p ~S" (transform-s-expr full-tuples-p)))
      (when all-assertions-p-supplied-p (myformat nil " :all-assertions-p ~S" (transform-s-expr all-assertions-p)))
      (when hypothesized-assertions-p-supplied-p (myformat nil " :hypothesized-assertions-p ~S" (transform-s-expr hypothesized-assertions-p)))
      (when show-score-p-supplied-p (myformat nil " :show-score-p ~S" (transform-s-expr show-score-p)))
      (when abox-entailment-supplied-p (myformat nil " :abox-entailment ~S" (transform-s-expr abox-entailment)))
      (when ensure-permutations-p-supplied-p (myformat nil " :ensure-permutations-p ~S" (transform-s-expr ensure-permutations-p)))
      ")" )))

   (service-request req-string))))

(defun add-missing-top-conjuncts ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-missing-top-conjuncts"
      ")" )))

   (service-request req-string))))

(defun add-negated-role-assertion ( abox predecessor-name filler-name role-term)
 (declare (ignorable  abox predecessor-name filler-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-negated-role-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr predecessor-name))
      (myformat nil " ~S" (transform-s-expr filler-name))
      (myformat nil " ~S" (transform-s-expr role-term))
      ")" )))

   (service-request req-string))))

(defun add-negative-datatype-role-filler ( abox individual value role &optional  (type nil type-supplied-p))
 (declare (ignorable  type abox individual value role))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-negative-datatype-role-filler"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr value))
      (myformat nil " ~S" (transform-s-expr role))
      (when type-supplied-p (myformat nil " ~S" (transform-s-expr type)))
      ")" )))

   (service-request req-string))))

(defun add-prefix ( prefix mapping)
 (declare (ignorable  prefix mapping))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-prefix"
      (myformat nil " ~S" (transform-s-expr prefix))
      (myformat nil " ~S" (transform-s-expr mapping))
      ")" )))

   (service-request req-string))))

(defun add-role-assertion ( abox predecessor-name filler-name role-term)
 (declare (ignorable  abox predecessor-name filler-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-role-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr predecessor-name))
      (myformat nil " ~S" (transform-s-expr filler-name))
      (myformat nil " ~S" (transform-s-expr role-term))
      ")" )))

   (service-request req-string))))

(defun add-role-assertions-for-datatype-properties ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-role-assertions-for-datatype-properties"
      ")" )))

   (service-request req-string))))

(defun add-role-axiom ( tbox role-name &key  (cd-attribute nil cd-attribute-supplied-p) (feature-p nil feature-p-supplied-p) (feature nil feature-supplied-p) (transitive-p nil transitive-p-supplied-p) (transitive nil transitive-supplied-p) (parents nil parents-supplied-p) (parent nil parent-supplied-p) (inverse nil inverse-supplied-p) (inverse-feature-p nil inverse-feature-p-supplied-p) (domain nil domain-supplied-p) (range nil range-supplied-p) (symmetric nil symmetric-supplied-p) (symmetric-p nil symmetric-p-supplied-p) (reflexive nil reflexive-supplied-p) (reflexive-p nil reflexive-p-supplied-p) (datatype nil datatype-supplied-p) (annotation-p nil annotation-p-supplied-p) (irreflexive nil irreflexive-supplied-p) (irreflexive-p nil irreflexive-p-supplied-p) (asymmetric nil asymmetric-supplied-p) (asymmetric-p nil asymmetric-p-supplied-p) (compositions nil compositions-supplied-p))
 (declare (ignorable  cd-attribute feature-p feature transitive-p transitive parents parent inverse inverse-feature-p domain range symmetric symmetric-p reflexive reflexive-p datatype annotation-p irreflexive irreflexive-p asymmetric asymmetric-p compositions tbox role-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-role-axiom"
      (myformat nil " ~S" (transform-s-expr tbox))
      (myformat nil " ~S" (transform-s-expr role-name))
      (when cd-attribute-supplied-p (myformat nil " :cd-attribute ~S" (transform-s-expr cd-attribute)))
      (when feature-p-supplied-p (myformat nil " :feature-p ~S" (transform-s-expr feature-p)))
      (when feature-supplied-p (myformat nil " :feature ~S" (transform-s-expr feature)))
      (when transitive-p-supplied-p (myformat nil " :transitive-p ~S" (transform-s-expr transitive-p)))
      (when transitive-supplied-p (myformat nil " :transitive ~S" (transform-s-expr transitive)))
      (when parents-supplied-p (myformat nil " :parents ~S" (transform-s-expr parents)))
      (when parent-supplied-p (myformat nil " :parent ~S" (transform-s-expr parent)))
      (when inverse-supplied-p (myformat nil " :inverse ~S" (transform-s-expr inverse)))
      (when inverse-feature-p-supplied-p (myformat nil " :inverse-feature-p ~S" (transform-s-expr inverse-feature-p)))
      (when domain-supplied-p (myformat nil " :domain ~S" (transform-s-expr domain)))
      (when range-supplied-p (myformat nil " :range ~S" (transform-s-expr range)))
      (when symmetric-supplied-p (myformat nil " :symmetric ~S" (transform-s-expr symmetric)))
      (when symmetric-p-supplied-p (myformat nil " :symmetric-p ~S" (transform-s-expr symmetric-p)))
      (when reflexive-supplied-p (myformat nil " :reflexive ~S" (transform-s-expr reflexive)))
      (when reflexive-p-supplied-p (myformat nil " :reflexive-p ~S" (transform-s-expr reflexive-p)))
      (when datatype-supplied-p (myformat nil " :datatype ~S" (transform-s-expr datatype)))
      (when annotation-p-supplied-p (myformat nil " :annotation-p ~S" (transform-s-expr annotation-p)))
      (when irreflexive-supplied-p (myformat nil " :irreflexive ~S" (transform-s-expr irreflexive)))
      (when irreflexive-p-supplied-p (myformat nil " :irreflexive-p ~S" (transform-s-expr irreflexive-p)))
      (when asymmetric-supplied-p (myformat nil " :asymmetric ~S" (transform-s-expr asymmetric)))
      (when asymmetric-p-supplied-p (myformat nil " :asymmetric-p ~S" (transform-s-expr asymmetric-p)))
      (when compositions-supplied-p (myformat nil " :compositions ~S" (transform-s-expr compositions)))
      ")" )))

   (service-request req-string))))

(defun add-role-axioms ( tbox role-name &key  (cd-attribute nil cd-attribute-supplied-p) (feature-p nil feature-p-supplied-p) (feature nil feature-supplied-p) (transitive-p nil transitive-p-supplied-p) (transitive nil transitive-supplied-p) (parents nil parents-supplied-p) (parent nil parent-supplied-p) (inverse nil inverse-supplied-p) (inverse-feature-p nil inverse-feature-p-supplied-p) (domain nil domain-supplied-p) (range nil range-supplied-p) (symmetric nil symmetric-supplied-p) (symmetric-p nil symmetric-p-supplied-p) (reflexive nil reflexive-supplied-p) (reflexive-p nil reflexive-p-supplied-p) (datatype nil datatype-supplied-p) (annotation-p nil annotation-p-supplied-p) (irreflexive nil irreflexive-supplied-p) (irreflexive-p nil irreflexive-p-supplied-p) (asymmetric nil asymmetric-supplied-p) (asymmetric-p nil asymmetric-p-supplied-p) (compositions nil compositions-supplied-p))
 (declare (ignorable  cd-attribute feature-p feature transitive-p transitive parents parent inverse inverse-feature-p domain range symmetric symmetric-p reflexive reflexive-p datatype annotation-p irreflexive irreflexive-p asymmetric asymmetric-p compositions tbox role-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-role-axioms"
      (myformat nil " ~S" (transform-s-expr tbox))
      (myformat nil " ~S" (transform-s-expr role-name))
      (when cd-attribute-supplied-p (myformat nil " :cd-attribute ~S" (transform-s-expr cd-attribute)))
      (when feature-p-supplied-p (myformat nil " :feature-p ~S" (transform-s-expr feature-p)))
      (when feature-supplied-p (myformat nil " :feature ~S" (transform-s-expr feature)))
      (when transitive-p-supplied-p (myformat nil " :transitive-p ~S" (transform-s-expr transitive-p)))
      (when transitive-supplied-p (myformat nil " :transitive ~S" (transform-s-expr transitive)))
      (when parents-supplied-p (myformat nil " :parents ~S" (transform-s-expr parents)))
      (when parent-supplied-p (myformat nil " :parent ~S" (transform-s-expr parent)))
      (when inverse-supplied-p (myformat nil " :inverse ~S" (transform-s-expr inverse)))
      (when inverse-feature-p-supplied-p (myformat nil " :inverse-feature-p ~S" (transform-s-expr inverse-feature-p)))
      (when domain-supplied-p (myformat nil " :domain ~S" (transform-s-expr domain)))
      (when range-supplied-p (myformat nil " :range ~S" (transform-s-expr range)))
      (when symmetric-supplied-p (myformat nil " :symmetric ~S" (transform-s-expr symmetric)))
      (when symmetric-p-supplied-p (myformat nil " :symmetric-p ~S" (transform-s-expr symmetric-p)))
      (when reflexive-supplied-p (myformat nil " :reflexive ~S" (transform-s-expr reflexive)))
      (when reflexive-p-supplied-p (myformat nil " :reflexive-p ~S" (transform-s-expr reflexive-p)))
      (when datatype-supplied-p (myformat nil " :datatype ~S" (transform-s-expr datatype)))
      (when annotation-p-supplied-p (myformat nil " :annotation-p ~S" (transform-s-expr annotation-p)))
      (when irreflexive-supplied-p (myformat nil " :irreflexive ~S" (transform-s-expr irreflexive)))
      (when irreflexive-p-supplied-p (myformat nil " :irreflexive-p ~S" (transform-s-expr irreflexive-p)))
      (when asymmetric-supplied-p (myformat nil " :asymmetric ~S" (transform-s-expr asymmetric)))
      (when asymmetric-p-supplied-p (myformat nil " :asymmetric-p ~S" (transform-s-expr asymmetric-p)))
      (when compositions-supplied-p (myformat nil " :compositions ~S" (transform-s-expr compositions)))
      ")" )))

   (service-request req-string))))

(defun add-rule-axiom ( abox lefthand-side righthand-side &key  (id nil id-supplied-p) (forward-rule-p nil forward-rule-p-supplied-p) (backward-rule-p nil backward-rule-p-supplied-p) (fire-once-p nil fire-once-p-supplied-p))
 (declare (ignorable  id forward-rule-p backward-rule-p fire-once-p abox lefthand-side righthand-side))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-rule-axiom"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr lefthand-side))
      (myformat nil " ~S" (transform-s-expr righthand-side))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when forward-rule-p-supplied-p (myformat nil " :forward-rule-p ~S" (transform-s-expr forward-rule-p)))
      (when backward-rule-p-supplied-p (myformat nil " :backward-rule-p ~S" (transform-s-expr backward-rule-p)))
      (when fire-once-p-supplied-p (myformat nil " :fire-once-p ~S" (transform-s-expr fire-once-p)))
      ")" )))

   (service-request req-string))))

(defun add-rule-consequences-automatically ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-rule-consequences-automatically"
      ")" )))

   (service-request req-string))))

(defun add-same-individual-as-assertion ( abox individual-name-1 individual-name-2)
 (declare (ignorable  abox individual-name-1 individual-name-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-same-individual-as-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual-name-1))
      (myformat nil " ~S" (transform-s-expr individual-name-2))
      ")" )))

   (service-request req-string))))

(defun alc-concept-coherent ( concept-term &key  (logic nil logic-supplied-p))
 (declare (ignorable  logic concept-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "alc-concept-coherent"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (when logic-supplied-p (myformat nil " :logic ~S" (transform-s-expr logic)))
      ")" )))

   (service-request req-string))))

(defun all-aboxes ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-aboxes"
      ")" )))

   (service-request req-string))))

(defun all-annotation-concept-assertions ( &optional  (abox nil abox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-annotation-concept-assertions"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-annotation-role-assertions ( &optional  (abox nil abox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-annotation-role-assertions"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-atomic-concepts ( &optional  (tbox nil tbox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  tbox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-atomic-concepts"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-attribute-assertions ( &optional  (abox nil abox-supplied-p) (individual nil individual-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox individual count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-attribute-assertions"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when individual-supplied-p (myformat nil " ~S" (transform-s-expr individual)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-attributes ( &optional  (tbox nil tbox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  tbox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-attributes"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-concept-assertions ( &optional  (abox nil abox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-concept-assertions"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-concept-assertions-for-individual ( individual &optional  (abox nil abox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox count individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-concept-assertions-for-individual"
      (myformat nil " ~S" (transform-s-expr individual))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-constraints ( &optional  (abox nil abox-supplied-p) (object-names nil object-names-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox object-names count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-constraints"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when object-names-supplied-p (myformat nil " ~S" (transform-s-expr object-names)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-different-from-assertions ( &optional  (abox nil abox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-different-from-assertions"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-equivalent-concepts ( &optional  (tbox nil tbox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  tbox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-equivalent-concepts"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-features ( &optional  (tbox nil tbox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  tbox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-features"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-individuals ( &optional  (abox nil abox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-individuals"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun all-role-assertions ( &optional  (abox nil abox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-role-assertions"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-role-assertions-for-individual-in-domain ( individual &optional  (abox nil abox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox count individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-role-assertions-for-individual-in-domain"
      (myformat nil " ~S" (transform-s-expr individual))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-role-assertions-for-individual-in-range ( individual &optional  (abox nil abox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox count individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-role-assertions-for-individual-in-range"
      (myformat nil " ~S" (transform-s-expr individual))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-roles ( &optional  (tbox nil tbox-supplied-p) &key  (count nil count-supplied-p) (test nil test-supplied-p) (inverse-test nil inverse-test-supplied-p) (default nil default-supplied-p))
 (declare (ignorable  tbox count test inverse-test default))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-roles"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      (when test-supplied-p (myformat nil " :test ~S" (transform-s-expr test)))
      (when inverse-test-supplied-p (myformat nil " :inverse-test ~S" (transform-s-expr inverse-test)))
      (when default-supplied-p (myformat nil " :default ~S" (transform-s-expr default)))
      ")" )))

   (service-request req-string))))

(defun all-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun all-same-as-assertions ( &optional  (abox nil abox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  abox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-same-as-assertions"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun all-substrates ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-substrates"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun all-tboxes ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-tboxes"
      ")" )))

   (service-request req-string))))

(defun all-transitive-roles ( &optional  (tbox nil tbox-supplied-p) &key  (count nil count-supplied-p))
 (declare (ignorable  tbox count))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-transitive-roles"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when count-supplied-p (myformat nil " :count ~S" (transform-s-expr count)))
      ")" )))

   (service-request req-string))))

(defun allow-overloaded-definitions ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "allow-overloaded-definitions"
      ")" )))

   (service-request req-string))))

(defun answer-query ( &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "answer-query"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun answer-query-under-premise ( &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "answer-query-under-premise"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun answer-query-under-premise1 ( &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "answer-query-under-premise1"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun answer-query1 ( &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "answer-query1"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun answer-tbox-query ( &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (tbox nil tbox-supplied-p) (package nil package-supplied-p) (create-tbox-if-not-found-p nil create-tbox-if-not-found-p-supplied-p) (substrate nil substrate-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois tbox package create-tbox-if-not-found-p substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "answer-tbox-query"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when create-tbox-if-not-found-p-supplied-p (myformat nil " :create-tbox-if-not-found-p ~S" (transform-s-expr create-tbox-if-not-found-p)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      ")" )))

   (service-request req-string))))

(defun answer-tbox-query1 ( &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (tbox nil tbox-supplied-p) (package nil package-supplied-p) (create-tbox-if-not-found-p nil create-tbox-if-not-found-p-supplied-p) (substrate nil substrate-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois tbox package create-tbox-if-not-found-p substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "answer-tbox-query1"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when create-tbox-if-not-found-p-supplied-p (myformat nil " :create-tbox-if-not-found-p ~S" (transform-s-expr create-tbox-if-not-found-p)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      ")" )))

   (service-request req-string))))

(defun applicable-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "applicable-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun apply-rule ( &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "apply-rule"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun apply-rule-under-premise ( &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "apply-rule-under-premise"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun apply-rule-under-premise1 ( &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "apply-rule-under-premise1"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun associated-aboxes ( tbox)
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "associated-aboxes"
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun associated-tbox ( abox)
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "associated-tbox"
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun asymmetric-p ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "asymmetric-p"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun atomic-concept-ancestors ( concept-term tbox)
 (declare (ignorable  concept-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-concept-ancestors"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun atomic-concept-children ( concept-term tbox)
 (declare (ignorable  concept-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-concept-children"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun atomic-concept-descendants ( concept-term tbox)
 (declare (ignorable  concept-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-concept-descendants"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun atomic-concept-parents ( concept-term tbox)
 (declare (ignorable  concept-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-concept-parents"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun atomic-concept-synonyms ( concept-term tbox)
 (declare (ignorable  concept-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-concept-synonyms"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun atomic-role-ancestors ( role-term tbox)
 (declare (ignorable  role-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-role-ancestors"
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun atomic-role-children ( role-term tbox &key  (synsets-p nil synsets-p-supplied-p))
 (declare (ignorable  synsets-p role-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-role-children"
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      (when synsets-p-supplied-p (myformat nil " :synsets-p ~S" (transform-s-expr synsets-p)))
      ")" )))

   (service-request req-string))))

(defun atomic-role-descendants ( role-term tbox)
 (declare (ignorable  role-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-role-descendants"
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun atomic-role-domain ( role-term tbox)
 (declare (ignorable  role-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-role-domain"
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun atomic-role-inverse ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-role-inverse"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun atomic-role-parents ( role-term tbox &key  (synsets-p nil synsets-p-supplied-p))
 (declare (ignorable  synsets-p role-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-role-parents"
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      (when synsets-p-supplied-p (myformat nil " :synsets-p ~S" (transform-s-expr synsets-p)))
      ")" )))

   (service-request req-string))))

(defun atomic-role-range ( role-term tbox)
 (declare (ignorable  role-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-role-range"
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun atomic-role-synonyms ( role-term tbox)
 (declare (ignorable  role-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "atomic-role-synonyms"
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun attribute-domain-1 ( attribute-name &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox attribute-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "attribute-domain-1"
      (myformat nil " ~S" (transform-s-expr attribute-name))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun attribute-type ( attribute-name &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox attribute-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "attribute-type"
      (myformat nil " ~S" (transform-s-expr attribute-name))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun cd-attribute-p ( attribute &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox attribute))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "cd-attribute-p"
      (myformat nil " ~S" (transform-s-expr attribute))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun cd-object-p ( object-name &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox object-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "cd-object-p"
      (myformat nil " ~S" (transform-s-expr object-name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun cheap-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "cheap-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun cheap-query-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "cheap-query-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun cheap-rule-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "cheap-rule-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun cheap-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "cheap-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun check-abox-coherence ( &optional  (abox nil abox-supplied-p) (filename-or-stream nil filename-or-stream-supplied-p))
 (declare (ignorable  abox filename-or-stream))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "check-abox-coherence"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when filename-or-stream-supplied-p (myformat nil " ~S" (transform-s-expr filename-or-stream)))
      ")" )))

   (service-request req-string))))

(defun check-abox-consistency-before-querying ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "check-abox-consistency-before-querying"
      ")" )))

   (service-request req-string))))

(defun check-concept-coherence ( concept &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "check-concept-coherence"
      (myformat nil " ~S" (transform-s-expr concept))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun check-for-updates ( &key  (url nil url-supplied-p))
 (declare (ignorable  url))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "check-for-updates"
      (when url-supplied-p (myformat nil " :url ~S" (transform-s-expr url)))
      ")" )))

   (service-request req-string))))

(defun check-nrql-subscriptions ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "check-nrql-subscriptions"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun check-ontology ( filename &key  (verbose nil verbose-supplied-p) (explain-all nil explain-all-supplied-p) (n nil n-supplied-p))
 (declare (ignorable  verbose explain-all n filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "check-ontology"
      (myformat nil " ~S" (transform-s-expr filename))
      (when verbose-supplied-p (myformat nil " :verbose ~S" (transform-s-expr verbose)))
      (when explain-all-supplied-p (myformat nil " :explain-all ~S" (transform-s-expr explain-all)))
      (when n-supplied-p (myformat nil " :n ~S" (transform-s-expr n)))
      ")" )))

   (service-request req-string))))

(defun check-subscriptions ( abox)
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "check-subscriptions"
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun check-tbox-coherence ( &optional  (tbox nil tbox-supplied-p) &key  (stream nil stream-supplied-p))
 (declare (ignorable  tbox stream))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "check-tbox-coherence"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when stream-supplied-p (myformat nil " :stream ~S" (transform-s-expr stream)))
      ")" )))

   (service-request req-string))))

(defun choose-current-set-of-rule-consequences ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "choose-current-set-of-rule-consequences"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun classify-query ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "classify-query"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun classify-tbox ( &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "classify-tbox"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun clear-all-documentation ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "clear-all-documentation"
      ")" )))

   (service-request req-string))))

(defun clear-default-tbox ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "clear-default-tbox"
      ")" )))

   (service-request req-string))))

(defun close-triple-store ( &key  (db nil db-supplied-p) (if-closed nil if-closed-supplied-p))
 (declare (ignorable  db if-closed))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "close-triple-store"
      (when db-supplied-p (myformat nil " :db ~S" (transform-s-expr db)))
      (when if-closed-supplied-p (myformat nil " :if-closed ~S" (transform-s-expr if-closed)))
      ")" )))

   (service-request req-string))))

(defun compute-abox-difference1 ( a b &key  (also-unmapped-differences-p nil also-unmapped-differences-p-supplied-p) (remove-redundant-diffs-p nil remove-redundant-diffs-p-supplied-p) (optimizer-max-plans nil optimizer-max-plans-supplied-p) (known-correspondances nil known-correspondances-supplied-p) (auto-correspondances-p nil auto-correspondances-p-supplied-p) (only-difference-p nil only-difference-p-supplied-p) (full-tuples-p nil full-tuples-p-supplied-p) (show-score-p nil show-score-p-supplied-p) (equi-order-by nil equi-order-by-supplied-p) (remove-implied-concept-assertions-p nil remove-implied-concept-assertions-p-supplied-p) (remove-common-assertions-p nil remove-common-assertions-p-supplied-p) (common-assertions-as-strict-atoms-p nil common-assertions-as-strict-atoms-p-supplied-p) (map-new-inds-to-new-inds-p nil map-new-inds-to-new-inds-p-supplied-p) (cutoff-fn nil cutoff-fn-supplied-p) (hypo-mode-stack nil hypo-mode-stack-supplied-p) (c-mode nil c-mode-supplied-p) (r-mode nil r-mode-supplied-p) (only-best-p nil only-best-p-supplied-p) (order-by nil order-by-supplied-p) (reverse-order-p nil reverse-order-p-supplied-p) (ensure-permutations-p nil ensure-permutations-p-supplied-p) (how-many nil how-many-supplied-p) (strategy nil strategy-supplied-p) (simple-result-p nil simple-result-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (same-as-only-p nil same-as-only-p-supplied-p) (candidate-individuals nil candidate-individuals-supplied-p) (binding-validator nil binding-validator-supplied-p))
 (declare (ignorable  also-unmapped-differences-p remove-redundant-diffs-p optimizer-max-plans known-correspondances auto-correspondances-p only-difference-p full-tuples-p show-score-p equi-order-by remove-implied-concept-assertions-p remove-common-assertions-p common-assertions-as-strict-atoms-p map-new-inds-to-new-inds-p cutoff-fn hypo-mode-stack c-mode r-mode only-best-p order-by reverse-order-p ensure-permutations-p how-many strategy simple-result-p runtime-consistency-checking-p final-consistency-checking-p same-as-only-p candidate-individuals binding-validator a b))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "compute-abox-difference1"
      (myformat nil " ~S" (transform-s-expr a))
      (myformat nil " ~S" (transform-s-expr b))
      (when also-unmapped-differences-p-supplied-p (myformat nil " :also-unmapped-differences-p ~S" (transform-s-expr also-unmapped-differences-p)))
      (when remove-redundant-diffs-p-supplied-p (myformat nil " :remove-redundant-diffs-p ~S" (transform-s-expr remove-redundant-diffs-p)))
      (when optimizer-max-plans-supplied-p (myformat nil " :optimizer-max-plans ~S" (transform-s-expr optimizer-max-plans)))
      (when known-correspondances-supplied-p (myformat nil " :known-correspondances ~S" (transform-s-expr known-correspondances)))
      (when auto-correspondances-p-supplied-p (myformat nil " :auto-correspondances-p ~S" (transform-s-expr auto-correspondances-p)))
      (when only-difference-p-supplied-p (myformat nil " :only-difference-p ~S" (transform-s-expr only-difference-p)))
      (when full-tuples-p-supplied-p (myformat nil " :full-tuples-p ~S" (transform-s-expr full-tuples-p)))
      (when show-score-p-supplied-p (myformat nil " :show-score-p ~S" (transform-s-expr show-score-p)))
      (when equi-order-by-supplied-p (myformat nil " :equi-order-by ~S" (transform-s-expr equi-order-by)))
      (when remove-implied-concept-assertions-p-supplied-p (myformat nil " :remove-implied-concept-assertions-p ~S" (transform-s-expr remove-implied-concept-assertions-p)))
      (when remove-common-assertions-p-supplied-p (myformat nil " :remove-common-assertions-p ~S" (transform-s-expr remove-common-assertions-p)))
      (when common-assertions-as-strict-atoms-p-supplied-p (myformat nil " :common-assertions-as-strict-atoms-p ~S" (transform-s-expr common-assertions-as-strict-atoms-p)))
      (when map-new-inds-to-new-inds-p-supplied-p (myformat nil " :map-new-inds-to-new-inds-p ~S" (transform-s-expr map-new-inds-to-new-inds-p)))
      (when cutoff-fn-supplied-p (myformat nil " :cutoff-fn ~S" (transform-s-expr cutoff-fn)))
      (when hypo-mode-stack-supplied-p (myformat nil " :hypo-mode-stack ~S" (transform-s-expr hypo-mode-stack)))
      (when c-mode-supplied-p (myformat nil " :c-mode ~S" (transform-s-expr c-mode)))
      (when r-mode-supplied-p (myformat nil " :r-mode ~S" (transform-s-expr r-mode)))
      (when only-best-p-supplied-p (myformat nil " :only-best-p ~S" (transform-s-expr only-best-p)))
      (when order-by-supplied-p (myformat nil " :order-by ~S" (transform-s-expr order-by)))
      (when reverse-order-p-supplied-p (myformat nil " :reverse-order-p ~S" (transform-s-expr reverse-order-p)))
      (when ensure-permutations-p-supplied-p (myformat nil " :ensure-permutations-p ~S" (transform-s-expr ensure-permutations-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when strategy-supplied-p (myformat nil " :strategy ~S" (transform-s-expr strategy)))
      (when simple-result-p-supplied-p (myformat nil " :simple-result-p ~S" (transform-s-expr simple-result-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when same-as-only-p-supplied-p (myformat nil " :same-as-only-p ~S" (transform-s-expr same-as-only-p)))
      (when candidate-individuals-supplied-p (myformat nil " :candidate-individuals ~S" (transform-s-expr candidate-individuals)))
      (when binding-validator-supplied-p (myformat nil " :binding-validator ~S" (transform-s-expr binding-validator)))
      ")" )))

   (service-request req-string))))

(defun compute-abox-difference2 ( a b &key  (also-unmapped-differences-p nil also-unmapped-differences-p-supplied-p) (remove-redundant-diffs-p nil remove-redundant-diffs-p-supplied-p) (optimizer-max-plans nil optimizer-max-plans-supplied-p) (known-correspondances nil known-correspondances-supplied-p) (auto-correspondances-p nil auto-correspondances-p-supplied-p) (only-difference-p nil only-difference-p-supplied-p) (full-tuples-p nil full-tuples-p-supplied-p) (show-score-p nil show-score-p-supplied-p) (equi-order-by nil equi-order-by-supplied-p) (remove-implied-concept-assertions-p nil remove-implied-concept-assertions-p-supplied-p) (remove-common-assertions-p nil remove-common-assertions-p-supplied-p) (common-assertions-as-strict-atoms-p nil common-assertions-as-strict-atoms-p-supplied-p) (map-new-inds-to-new-inds-p nil map-new-inds-to-new-inds-p-supplied-p) (cutoff-fn nil cutoff-fn-supplied-p) (hypo-mode-stack nil hypo-mode-stack-supplied-p) (c-mode nil c-mode-supplied-p) (r-mode nil r-mode-supplied-p) (only-best-p nil only-best-p-supplied-p) (order-by nil order-by-supplied-p) (reverse-order-p nil reverse-order-p-supplied-p) (ensure-permutations-p nil ensure-permutations-p-supplied-p) (how-many nil how-many-supplied-p) (strategy nil strategy-supplied-p) (simple-result-p nil simple-result-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (same-as-only-p nil same-as-only-p-supplied-p) (candidate-individuals nil candidate-individuals-supplied-p) (binding-validator nil binding-validator-supplied-p))
 (declare (ignorable  also-unmapped-differences-p remove-redundant-diffs-p optimizer-max-plans known-correspondances auto-correspondances-p only-difference-p full-tuples-p show-score-p equi-order-by remove-implied-concept-assertions-p remove-common-assertions-p common-assertions-as-strict-atoms-p map-new-inds-to-new-inds-p cutoff-fn hypo-mode-stack c-mode r-mode only-best-p order-by reverse-order-p ensure-permutations-p how-many strategy simple-result-p runtime-consistency-checking-p final-consistency-checking-p same-as-only-p candidate-individuals binding-validator a b))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "compute-abox-difference2"
      (myformat nil " ~S" (transform-s-expr a))
      (myformat nil " ~S" (transform-s-expr b))
      (when also-unmapped-differences-p-supplied-p (myformat nil " :also-unmapped-differences-p ~S" (transform-s-expr also-unmapped-differences-p)))
      (when remove-redundant-diffs-p-supplied-p (myformat nil " :remove-redundant-diffs-p ~S" (transform-s-expr remove-redundant-diffs-p)))
      (when optimizer-max-plans-supplied-p (myformat nil " :optimizer-max-plans ~S" (transform-s-expr optimizer-max-plans)))
      (when known-correspondances-supplied-p (myformat nil " :known-correspondances ~S" (transform-s-expr known-correspondances)))
      (when auto-correspondances-p-supplied-p (myformat nil " :auto-correspondances-p ~S" (transform-s-expr auto-correspondances-p)))
      (when only-difference-p-supplied-p (myformat nil " :only-difference-p ~S" (transform-s-expr only-difference-p)))
      (when full-tuples-p-supplied-p (myformat nil " :full-tuples-p ~S" (transform-s-expr full-tuples-p)))
      (when show-score-p-supplied-p (myformat nil " :show-score-p ~S" (transform-s-expr show-score-p)))
      (when equi-order-by-supplied-p (myformat nil " :equi-order-by ~S" (transform-s-expr equi-order-by)))
      (when remove-implied-concept-assertions-p-supplied-p (myformat nil " :remove-implied-concept-assertions-p ~S" (transform-s-expr remove-implied-concept-assertions-p)))
      (when remove-common-assertions-p-supplied-p (myformat nil " :remove-common-assertions-p ~S" (transform-s-expr remove-common-assertions-p)))
      (when common-assertions-as-strict-atoms-p-supplied-p (myformat nil " :common-assertions-as-strict-atoms-p ~S" (transform-s-expr common-assertions-as-strict-atoms-p)))
      (when map-new-inds-to-new-inds-p-supplied-p (myformat nil " :map-new-inds-to-new-inds-p ~S" (transform-s-expr map-new-inds-to-new-inds-p)))
      (when cutoff-fn-supplied-p (myformat nil " :cutoff-fn ~S" (transform-s-expr cutoff-fn)))
      (when hypo-mode-stack-supplied-p (myformat nil " :hypo-mode-stack ~S" (transform-s-expr hypo-mode-stack)))
      (when c-mode-supplied-p (myformat nil " :c-mode ~S" (transform-s-expr c-mode)))
      (when r-mode-supplied-p (myformat nil " :r-mode ~S" (transform-s-expr r-mode)))
      (when only-best-p-supplied-p (myformat nil " :only-best-p ~S" (transform-s-expr only-best-p)))
      (when order-by-supplied-p (myformat nil " :order-by ~S" (transform-s-expr order-by)))
      (when reverse-order-p-supplied-p (myformat nil " :reverse-order-p ~S" (transform-s-expr reverse-order-p)))
      (when ensure-permutations-p-supplied-p (myformat nil " :ensure-permutations-p ~S" (transform-s-expr ensure-permutations-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when strategy-supplied-p (myformat nil " :strategy ~S" (transform-s-expr strategy)))
      (when simple-result-p-supplied-p (myformat nil " :simple-result-p ~S" (transform-s-expr simple-result-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when same-as-only-p-supplied-p (myformat nil " :same-as-only-p ~S" (transform-s-expr same-as-only-p)))
      (when candidate-individuals-supplied-p (myformat nil " :candidate-individuals ~S" (transform-s-expr candidate-individuals)))
      (when binding-validator-supplied-p (myformat nil " :binding-validator ~S" (transform-s-expr binding-validator)))
      ")" )))

   (service-request req-string))))

(defun compute-all-implicit-role-fillers ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "compute-all-implicit-role-fillers"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun compute-implicit-role-fillers ( individual-name &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "compute-implicit-role-fillers"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun compute-index-for-instance-retrieval ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "compute-index-for-instance-retrieval"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun compute-subgraph-aboxes ( abox-or-name)
 (declare (ignorable  abox-or-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "compute-subgraph-aboxes"
      (myformat nil " ~S" (transform-s-expr abox-or-name))
      ")" )))

   (service-request req-string))))

(defun concept-disjoint-p ( concept-1 concept-2 tbox)
 (declare (ignorable  concept-1 concept-2 tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-disjoint-p"
      (myformat nil " ~S" (transform-s-expr concept-1))
      (myformat nil " ~S" (transform-s-expr concept-2))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun concept-equivalent-p ( concept-1 concept-2 tbox)
 (declare (ignorable  concept-1 concept-2 tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-equivalent-p"
      (myformat nil " ~S" (transform-s-expr concept-1))
      (myformat nil " ~S" (transform-s-expr concept-2))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun concept-is-primitive-p ( concept-name &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-is-primitive-p"
      (myformat nil " ~S" (transform-s-expr concept-name))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun concept-p ( concept-name &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-p"
      (myformat nil " ~S" (transform-s-expr concept-name))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun concept-satisfiable-p ( concept-term tbox)
 (declare (ignorable  concept-term tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-satisfiable-p"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun concept-subsumes-p ( subsumer subsumee tbox)
 (declare (ignorable  subsumer subsumee tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-subsumes-p"
      (myformat nil " ~S" (transform-s-expr subsumer))
      (myformat nil " ~S" (transform-s-expr subsumee))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun constraint-entailed-p ( constraint &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox constraint))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "constraint-entailed-p"
      (myformat nil " ~S" (transform-s-expr constraint))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun convert-event-specs ( in-file out-file)
 (declare (ignorable  in-file out-file))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "convert-event-specs"
      (myformat nil " ~S" (transform-s-expr in-file))
      (myformat nil " ~S" (transform-s-expr out-file))
      ")" )))

   (service-request req-string))))

(defun copy-rules ( from-abox to-abox &key  (type-of-substrate nil type-of-substrate-supplied-p) (keep-old-names-p nil keep-old-names-p-supplied-p))
 (declare (ignorable  type-of-substrate keep-old-names-p from-abox to-abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "copy-rules"
      (myformat nil " ~S" (transform-s-expr from-abox))
      (myformat nil " ~S" (transform-s-expr to-abox))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when keep-old-names-p-supplied-p (myformat nil " :keep-old-names-p ~S" (transform-s-expr keep-old-names-p)))
      ")" )))

   (service-request req-string))))

(defun create-abox-clone ( abox &key  (new-name nil new-name-supplied-p) (overwrite nil overwrite-supplied-p) (copy-rules nil copy-rules-supplied-p))
 (declare (ignorable  new-name overwrite copy-rules abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "create-abox-clone"
      (myformat nil " ~S" (transform-s-expr abox))
      (when new-name-supplied-p (myformat nil " :new-name ~S" (transform-s-expr new-name)))
      (when overwrite-supplied-p (myformat nil " :overwrite ~S" (transform-s-expr overwrite)))
      (when copy-rules-supplied-p (myformat nil " :copy-rules ~S" (transform-s-expr copy-rules)))
      ")" )))

   (service-request req-string))))

(defun create-data-edge ( from to descr &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (racer-descr nil racer-descr-supplied-p) (told-info-p nil told-info-p-supplied-p))
 (declare (ignorable  abox type-of-substrate racer-descr told-info-p from to descr))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "create-data-edge"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (myformat nil " ~S" (transform-s-expr descr))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when racer-descr-supplied-p (myformat nil " :racer-descr ~S" (transform-s-expr racer-descr)))
      (when told-info-p-supplied-p (myformat nil " :told-info-p ~S" (transform-s-expr told-info-p)))
      ")" )))

   (service-request req-string))))

(defun create-data-node ( name &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (racer-descr nil racer-descr-supplied-p) (descr nil descr-supplied-p) (told-info-p nil told-info-p-supplied-p))
 (declare (ignorable  abox type-of-substrate racer-descr descr told-info-p name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "create-data-node"
      (myformat nil " ~S" (transform-s-expr name))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when racer-descr-supplied-p (myformat nil " :racer-descr ~S" (transform-s-expr racer-descr)))
      (when descr-supplied-p (myformat nil " :descr ~S" (transform-s-expr descr)))
      (when told-info-p-supplied-p (myformat nil " :told-info-p ~S" (transform-s-expr told-info-p)))
      ")" )))

   (service-request req-string))))

(defun create-rcc-edge ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (racer-descr nil racer-descr-supplied-p) (told-info-p nil told-info-p-supplied-p))
 (declare (ignorable  abox type-of-substrate racer-descr told-info-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "create-rcc-edge"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when racer-descr-supplied-p (myformat nil " :racer-descr ~S" (transform-s-expr racer-descr)))
      (when told-info-p-supplied-p (myformat nil " :told-info-p ~S" (transform-s-expr told-info-p)))
      ")" )))

   (service-request req-string))))

(defun create-rcc-node ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (racer-descr nil racer-descr-supplied-p) (descr nil descr-supplied-p) (told-info-p nil told-info-p-supplied-p))
 (declare (ignorable  abox type-of-substrate racer-descr descr told-info-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "create-rcc-node"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when racer-descr-supplied-p (myformat nil " :racer-descr ~S" (transform-s-expr racer-descr)))
      (when descr-supplied-p (myformat nil " :descr ~S" (transform-s-expr descr)))
      (when told-info-p-supplied-p (myformat nil " :told-info-p ~S" (transform-s-expr told-info-p)))
      ")" )))

   (service-request req-string))))

(defun create-subgraph-aboxes ( abox-or-name &optional  (new-name nil new-name-supplied-p) (tbox nil tbox-supplied-p))
 (declare (ignorable  new-name tbox abox-or-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "create-subgraph-aboxes"
      (myformat nil " ~S" (transform-s-expr abox-or-name))
      (when new-name-supplied-p (myformat nil " ~S" (transform-s-expr new-name)))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun create-tbox-clone ( tbox &key  (new-name nil new-name-supplied-p) (overwrite nil overwrite-supplied-p))
 (declare (ignorable  new-name overwrite tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "create-tbox-clone"
      (myformat nil " ~S" (transform-s-expr tbox))
      (when new-name-supplied-p (myformat nil " :new-name ~S" (transform-s-expr new-name)))
      (when overwrite-supplied-p (myformat nil " :overwrite ~S" (transform-s-expr overwrite)))
      ")" )))

   (service-request req-string))))

(defun create-tbox-internal-marker-concept ( tbox &optional  (marker-name nil marker-name-supplied-p))
 (declare (ignorable  marker-name tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "create-tbox-internal-marker-concept"
      (myformat nil " ~S" (transform-s-expr tbox))
      (when marker-name-supplied-p (myformat nil " ~S" (transform-s-expr marker-name)))
      ")" )))

   (service-request req-string))))

(defun create-triple-store ( name &key  (if-exists nil if-exists-supplied-p) (directory nil directory-supplied-p) (data-version-level nil data-version-level-supplied-p))
 (declare (ignorable  if-exists directory data-version-level name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "create-triple-store"
      (myformat nil " ~S" (transform-s-expr name))
      (when if-exists-supplied-p (myformat nil " :if-exists ~S" (transform-s-expr if-exists)))
      (when directory-supplied-p (myformat nil " :directory ~S" (transform-s-expr directory)))
      (when data-version-level-supplied-p (myformat nil " :data-version-level ~S" (transform-s-expr data-version-level)))
      ")" )))

   (service-request req-string))))

(defun current-abox ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "current-abox"
      ")" )))

   (service-request req-string))))

(defun current-tbox ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "current-tbox"
      ")" )))

   (service-request req-string))))

(defun data-edge1 ( from to data-relation &optional  (racer-descr nil racer-descr-supplied-p) (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  racer-descr abox type-of-substrate from to data-relation))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "data-edge1"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (myformat nil " ~S" (transform-s-expr data-relation))
      (when racer-descr-supplied-p (myformat nil " ~S" (transform-s-expr racer-descr)))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun data-node1 ( name &optional  (descr nil descr-supplied-p) (racer-descr nil racer-descr-supplied-p) (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  descr racer-descr abox type-of-substrate name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "data-node1"
      (myformat nil " ~S" (transform-s-expr name))
      (when descr-supplied-p (myformat nil " ~S" (transform-s-expr descr)))
      (when racer-descr-supplied-p (myformat nil " ~S" (transform-s-expr racer-descr)))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun datatype-role-has-range ( rolename range tbox)
 (declare (ignorable  rolename range tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "datatype-role-has-range"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr range))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun datatype-role-range ( role-name tbox)
 (declare (ignorable  role-name tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "datatype-role-range"
      (myformat nil " ~S" (transform-s-expr role-name))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun deactivate-defined-query ( name arity &key  (pos nil pos-supplied-p) (tbox nil tbox-supplied-p))
 (declare (ignorable  pos tbox name arity))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "deactivate-defined-query"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr arity))
      (when pos-supplied-p (myformat nil " :pos ~S" (transform-s-expr pos)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun declare-current-knowledge-bases-as-persistent ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "declare-current-knowledge-bases-as-persistent"
      ")" )))

   (service-request req-string))))

(defun declare-disjoint ( concepts tbox)
 (declare (ignorable  concepts tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "declare-disjoint"
      (myformat nil " ~S" (transform-s-expr concepts))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun defcon1 ( name value)
 (declare (ignorable  name value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "defcon1"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr value))
      ")" )))

   (service-request req-string))))

(defun define-and-execute-query ( name head body &key  (keep-p nil keep-p-supplied-p) (tbox nil tbox-supplied-p) (consider-head-atom-for-consistency-check-p nil consider-head-atom-for-consistency-check-p-supplied-p) (allow-multiple-definitions-p nil allow-multiple-definitions-p-supplied-p))
 (declare (ignorable  keep-p tbox consider-head-atom-for-consistency-check-p allow-multiple-definitions-p name head body))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-and-execute-query"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr head))
      (myformat nil " ~S" (transform-s-expr body))
      (when keep-p-supplied-p (myformat nil " :keep-p ~S" (transform-s-expr keep-p)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when consider-head-atom-for-consistency-check-p-supplied-p (myformat nil " :consider-head-atom-for-consistency-check-p ~S" (transform-s-expr consider-head-atom-for-consistency-check-p)))
      (when allow-multiple-definitions-p-supplied-p (myformat nil " :allow-multiple-definitions-p ~S" (transform-s-expr allow-multiple-definitions-p)))
      ")" )))

   (service-request req-string))))

(defun define-and-prepare-query ( name head body &key  (keep-p nil keep-p-supplied-p) (tbox nil tbox-supplied-p) (consider-head-atom-for-consistency-check-p nil consider-head-atom-for-consistency-check-p-supplied-p) (allow-multiple-definitions-p nil allow-multiple-definitions-p-supplied-p))
 (declare (ignorable  keep-p tbox consider-head-atom-for-consistency-check-p allow-multiple-definitions-p name head body))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-and-prepare-query"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr head))
      (myformat nil " ~S" (transform-s-expr body))
      (when keep-p-supplied-p (myformat nil " :keep-p ~S" (transform-s-expr keep-p)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when consider-head-atom-for-consistency-check-p-supplied-p (myformat nil " :consider-head-atom-for-consistency-check-p ~S" (transform-s-expr consider-head-atom-for-consistency-check-p)))
      (when allow-multiple-definitions-p-supplied-p (myformat nil " :allow-multiple-definitions-p ~S" (transform-s-expr allow-multiple-definitions-p)))
      ")" )))

   (service-request req-string))))

(defun define-query ( name head body &key  (keep-p nil keep-p-supplied-p) (tbox nil tbox-supplied-p) (consider-head-atom-for-consistency-check-p nil consider-head-atom-for-consistency-check-p-supplied-p) (allow-multiple-definitions-p nil allow-multiple-definitions-p-supplied-p))
 (declare (ignorable  keep-p tbox consider-head-atom-for-consistency-check-p allow-multiple-definitions-p name head body))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-query"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr head))
      (myformat nil " ~S" (transform-s-expr body))
      (when keep-p-supplied-p (myformat nil " :keep-p ~S" (transform-s-expr keep-p)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when consider-head-atom-for-consistency-check-p-supplied-p (myformat nil " :consider-head-atom-for-consistency-check-p ~S" (transform-s-expr consider-head-atom-for-consistency-check-p)))
      (when allow-multiple-definitions-p-supplied-p (myformat nil " :allow-multiple-definitions-p ~S" (transform-s-expr allow-multiple-definitions-p)))
      ")" )))

   (service-request req-string))))

(defun define1 ( name arglist)
 (declare (ignorable  name arglist))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define1"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr arglist))
      ")" )))

   (service-request req-string))))

(defun defpar1 ( name value)
 (declare (ignorable  name value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "defpar1"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr value))
      ")" )))

   (service-request req-string))))

(defun del-data-edge1 ( from to &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate from to))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "del-data-edge1"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun del-data-node1 ( name &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "del-data-node1"
      (myformat nil " ~S" (transform-s-expr name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun del-doc-entry1 ( label)
 (declare (ignorable  label))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "del-doc-entry1"
      (myformat nil " ~S" (transform-s-expr label))
      ")" )))

   (service-request req-string))))

(defun del-rcc-edge1 ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "del-rcc-edge1"
      ")" )))

   (service-request req-string))))

(defun del-rcc-node1 ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "del-rcc-node1"
      ")" )))

   (service-request req-string))))

(defun delete-all-aboxes ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-all-aboxes"
      ")" )))

   (service-request req-string))))

(defun delete-all-definitions ( &key  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-all-definitions"
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun delete-all-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-all-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun delete-all-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-all-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun delete-all-substrates ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-all-substrates"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun delete-all-tboxes ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-all-tboxes"
      ")" )))

   (service-request req-string))))

(defun delete-data-edge ( from to &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (told-info-p nil told-info-p-supplied-p))
 (declare (ignorable  abox type-of-substrate told-info-p from to))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-data-edge"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when told-info-p-supplied-p (myformat nil " :told-info-p ~S" (transform-s-expr told-info-p)))
      ")" )))

   (service-request req-string))))

(defun delete-data-node ( name &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (told-info-p nil told-info-p-supplied-p))
 (declare (ignorable  abox type-of-substrate told-info-p name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-data-node"
      (myformat nil " ~S" (transform-s-expr name))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when told-info-p-supplied-p (myformat nil " :told-info-p ~S" (transform-s-expr told-info-p)))
      ")" )))

   (service-request req-string))))

(defun delete-prefix-mappings ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-prefix-mappings"
      ")" )))

   (service-request req-string))))

(defun delete-query ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-query"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun delete-rcc-synonyms ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-rcc-synonyms"
      ")" )))

   (service-request req-string))))

(defun delete-rule ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-rule"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun describe-abox ( &optional  (abox nil abox-supplied-p) (stream nil stream-supplied-p))
 (declare (ignorable  abox stream))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-abox"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when stream-supplied-p (myformat nil " ~S" (transform-s-expr stream)))
      ")" )))

   (service-request req-string))))

(defun describe-all-definitions ( &key  (tbox nil tbox-supplied-p) (error-p nil error-p-supplied-p))
 (declare (ignorable  tbox error-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-all-definitions"
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when error-p-supplied-p (myformat nil " :error-p ~S" (transform-s-expr error-p)))
      ")" )))

   (service-request req-string))))

(defun describe-all-edges ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-all-edges"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun describe-all-nodes ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-all-nodes"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun describe-all-queries ( &optional  (rewritten-p nil rewritten-p-supplied-p) &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  rewritten-p abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-all-queries"
      (when rewritten-p-supplied-p (myformat nil " ~S" (transform-s-expr rewritten-p)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun describe-all-rules ( &optional  (rewritten-p nil rewritten-p-supplied-p) &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  rewritten-p abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-all-rules"
      (when rewritten-p-supplied-p (myformat nil " ~S" (transform-s-expr rewritten-p)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun describe-all-substrates ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-all-substrates"
      ")" )))

   (service-request req-string))))

(defun describe-concept ( concept-name &optional  (tbox nil tbox-supplied-p) (stream nil stream-supplied-p))
 (declare (ignorable  tbox stream concept-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-concept"
      (myformat nil " ~S" (transform-s-expr concept-name))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when stream-supplied-p (myformat nil " ~S" (transform-s-expr stream)))
      ")" )))

   (service-request req-string))))

(defun describe-current-substrate ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-current-substrate"
      ")" )))

   (service-request req-string))))

(defun describe-definition ( name &key  (tbox nil tbox-supplied-p) (arity nil arity-supplied-p) (error-p nil error-p-supplied-p))
 (declare (ignorable  tbox arity error-p name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-definition"
      (myformat nil " ~S" (transform-s-expr name))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when arity-supplied-p (myformat nil " :arity ~S" (transform-s-expr arity)))
      (when error-p-supplied-p (myformat nil " :error-p ~S" (transform-s-expr error-p)))
      ")" )))

   (service-request req-string))))

(defun describe-individual ( individual-name &optional  (abox nil abox-supplied-p) (stream nil stream-supplied-p))
 (declare (ignorable  abox stream individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-individual"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when stream-supplied-p (myformat nil " ~S" (transform-s-expr stream)))
      ")" )))

   (service-request req-string))))

(defun describe-individual1 ( individual-name &optional  (abox nil abox-supplied-p) (stream nil stream-supplied-p))
 (declare (ignorable  abox stream individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-individual1"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when stream-supplied-p (myformat nil " ~S" (transform-s-expr stream)))
      ")" )))

   (service-request req-string))))

(defun describe-query ( query &optional  (rewritten-p nil rewritten-p-supplied-p))
 (declare (ignorable  rewritten-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-query"
      (myformat nil " ~S" (transform-s-expr query))
      (when rewritten-p-supplied-p (myformat nil " ~S" (transform-s-expr rewritten-p)))
      ")" )))

   (service-request req-string))))

(defun describe-query-processing-mode ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-query-processing-mode"
      ")" )))

   (service-request req-string))))

(defun describe-query-status ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-query-status"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun describe-role ( role-term &optional  (tbox nil tbox-supplied-p) (stream nil stream-supplied-p))
 (declare (ignorable  tbox stream role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-role"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when stream-supplied-p (myformat nil " ~S" (transform-s-expr stream)))
      ")" )))

   (service-request req-string))))

(defun describe-rule ( query &optional  (rewritten-p nil rewritten-p-supplied-p))
 (declare (ignorable  rewritten-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-rule"
      (myformat nil " ~S" (transform-s-expr query))
      (when rewritten-p-supplied-p (myformat nil " ~S" (transform-s-expr rewritten-p)))
      ")" )))

   (service-request req-string))))

(defun describe-rule-status ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-rule-status"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun describe-substrate ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-substrate"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun describe-tbox ( &optional  (tbox nil tbox-supplied-p) (stream nil stream-supplied-p))
 (declare (ignorable  tbox stream))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "describe-tbox"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when stream-supplied-p (myformat nil " ~S" (transform-s-expr stream)))
      ")" )))

   (service-request req-string))))

(defun description-implies-p ( a b)
 (declare (ignorable  a b))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "description-implies-p"
      (myformat nil " ~S" (transform-s-expr a))
      (myformat nil " ~S" (transform-s-expr b))
      ")" )))

   (service-request req-string))))

(defun dig-read-document ( url-spec &optional  (kb-name nil kb-name-supplied-p) (init nil init-supplied-p))
 (declare (ignorable  kb-name init url-spec))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dig-read-document"
      (myformat nil " ~S" (transform-s-expr url-spec))
      (when kb-name-supplied-p (myformat nil " ~S" (transform-s-expr kb-name)))
      (when init-supplied-p (myformat nil " ~S" (transform-s-expr init)))
      ")" )))

   (service-request req-string))))

(defun dig-read-file ( filename &key  (kb-name nil kb-name-supplied-p) (init nil init-supplied-p))
 (declare (ignorable  kb-name init filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dig-read-file"
      (myformat nil " ~S" (transform-s-expr filename))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      ")" )))

   (service-request req-string))))

(defun disable-abduction ( &key  (reset-p nil reset-p-supplied-p))
 (declare (ignorable  reset-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-abduction"
      (when reset-p-supplied-p (myformat nil " :reset-p ~S" (transform-s-expr reset-p)))
      ")" )))

   (service-request req-string))))

(defun disable-abox-mirroring ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-abox-mirroring"
      ")" )))

   (service-request req-string))))

(defun disable-data-substrate-mirroring ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-data-substrate-mirroring"
      ")" )))

   (service-request req-string))))

(defun disable-defined-queries ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-defined-queries"
      ")" )))

   (service-request req-string))))

(defun disable-kb-has-changed-warning-tokens ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-kb-has-changed-warning-tokens"
      ")" )))

   (service-request req-string))))

(defun disable-lazy-unfolding-of-defined-queries ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-lazy-unfolding-of-defined-queries"
      ")" )))

   (service-request req-string))))

(defun disable-nrql-warnings ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-nrql-warnings"
      ")" )))

   (service-request req-string))))

(defun disable-phase-two-starts-warning-tokens ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-phase-two-starts-warning-tokens"
      ")" )))

   (service-request req-string))))

(defun disable-query-optimization ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-query-optimization"
      ")" )))

   (service-request req-string))))

(defun disable-query-realization ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-query-realization"
      ")" )))

   (service-request req-string))))

(defun disable-query-repository ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-query-repository"
      ")" )))

   (service-request req-string))))

(defun disable-rcc-substrate-mirroring ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-rcc-substrate-mirroring"
      ")" )))

   (service-request req-string))))

(defun disable-told-information-querying ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-told-information-querying"
      ")" )))

   (service-request req-string))))

(defun disable-two-phase-query-processing-mode ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disable-two-phase-query-processing-mode"
      ")" )))

   (service-request req-string))))

(defun dont-add-missing-top-conjuncts ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dont-add-missing-top-conjuncts"
      ")" )))

   (service-request req-string))))

(defun dont-add-role-assertions-for-datatype-properties ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dont-add-role-assertions-for-datatype-properties"
      ")" )))

   (service-request req-string))))

(defun dont-add-rule-consequences-automatically ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dont-add-rule-consequences-automatically"
      ")" )))

   (service-request req-string))))

(defun dont-allow-overloaded-definitions ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dont-allow-overloaded-definitions"
      ")" )))

   (service-request req-string))))

(defun dont-check-abox-consistency-before-querying ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dont-check-abox-consistency-before-querying"
      ")" )))

   (service-request req-string))))

(defun dont-keep-defined-query-atoms ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dont-keep-defined-query-atoms"
      ")" )))

   (service-request req-string))))

(defun dont-prefer-defined-queries ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dont-prefer-defined-queries"
      ")" )))

   (service-request req-string))))

(defun dont-report-inconsistent-queries-and-rules ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dont-report-inconsistent-queries-and-rules"
      ")" )))

   (service-request req-string))))

(defun dont-use-individual-synonym-equivalence-classes ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dont-use-individual-synonym-equivalence-classes"
      ")" )))

   (service-request req-string))))

(defun dont-use-injective-variables-by-default ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "dont-use-injective-variables-by-default"
      ")" )))

   (service-request req-string))))

(defun edge-description1 ( from to &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate from to))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "edge-description1"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun edge-label1 ( from to &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate from to))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "edge-label1"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun enable-abduction ( c-mode r-mode &key  (reset-p nil reset-p-supplied-p) (hypo-mode-stack nil hypo-mode-stack-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (ensure-permutations-p nil ensure-permutations-p-supplied-p) (same-as-only-p nil same-as-only-p-supplied-p) (how-many nil how-many-supplied-p) (candidate-individuals nil candidate-individuals-supplied-p) (binding-validator nil binding-validator-supplied-p) (cutoff-fn nil cutoff-fn-supplied-p) (order-by nil order-by-supplied-p) (only-best-p nil only-best-p-supplied-p) (reverse-order-p nil reverse-order-p-supplied-p))
 (declare (ignorable  reset-p hypo-mode-stack runtime-consistency-checking-p final-consistency-checking-p ensure-permutations-p same-as-only-p how-many candidate-individuals binding-validator cutoff-fn order-by only-best-p reverse-order-p c-mode r-mode))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-abduction"
      (myformat nil " ~S" (transform-s-expr c-mode))
      (myformat nil " ~S" (transform-s-expr r-mode))
      (when reset-p-supplied-p (myformat nil " :reset-p ~S" (transform-s-expr reset-p)))
      (when hypo-mode-stack-supplied-p (myformat nil " :hypo-mode-stack ~S" (transform-s-expr hypo-mode-stack)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when ensure-permutations-p-supplied-p (myformat nil " :ensure-permutations-p ~S" (transform-s-expr ensure-permutations-p)))
      (when same-as-only-p-supplied-p (myformat nil " :same-as-only-p ~S" (transform-s-expr same-as-only-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when candidate-individuals-supplied-p (myformat nil " :candidate-individuals ~S" (transform-s-expr candidate-individuals)))
      (when binding-validator-supplied-p (myformat nil " :binding-validator ~S" (transform-s-expr binding-validator)))
      (when cutoff-fn-supplied-p (myformat nil " :cutoff-fn ~S" (transform-s-expr cutoff-fn)))
      (when order-by-supplied-p (myformat nil " :order-by ~S" (transform-s-expr order-by)))
      (when only-best-p-supplied-p (myformat nil " :only-best-p ~S" (transform-s-expr only-best-p)))
      (when reverse-order-p-supplied-p (myformat nil " :reverse-order-p ~S" (transform-s-expr reverse-order-p)))
      ")" )))

   (service-request req-string))))

(defun enable-abox-mirroring ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-abox-mirroring"
      ")" )))

   (service-request req-string))))

(defun enable-data-substrate-mirroring ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-data-substrate-mirroring"
      ")" )))

   (service-request req-string))))

(defun enable-defined-queries ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-defined-queries"
      ")" )))

   (service-request req-string))))

(defun enable-eager-tuple-computation ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-eager-tuple-computation"
      ")" )))

   (service-request req-string))))

(defun enable-kb-has-changed-warning-tokens ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-kb-has-changed-warning-tokens"
      ")" )))

   (service-request req-string))))

(defun enable-lazy-tuple-computation ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-lazy-tuple-computation"
      ")" )))

   (service-request req-string))))

(defun enable-lazy-unfolding-of-defined-queries ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-lazy-unfolding-of-defined-queries"
      ")" )))

   (service-request req-string))))

(defun enable-nrql-warnings ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-nrql-warnings"
      ")" )))

   (service-request req-string))))

(defun enable-optimized-query-processing ( &optional  (rewrite-concept-definitions nil rewrite-concept-definitions-supplied-p))
 (declare (ignorable  rewrite-concept-definitions))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-optimized-query-processing"
      (when rewrite-concept-definitions-supplied-p (myformat nil " ~S" (transform-s-expr rewrite-concept-definitions)))
      ")" )))

   (service-request req-string))))

(defun enable-phase-two-starts-warning-tokens ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-phase-two-starts-warning-tokens"
      ")" )))

   (service-request req-string))))

(defun enable-query-optimization ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-query-optimization"
      ")" )))

   (service-request req-string))))

(defun enable-query-realization ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-query-realization"
      ")" )))

   (service-request req-string))))

(defun enable-query-repository ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-query-repository"
      ")" )))

   (service-request req-string))))

(defun enable-rcc-substrate-mirroring ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-rcc-substrate-mirroring"
      ")" )))

   (service-request req-string))))

(defun enable-smart-abox-mirroring ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-smart-abox-mirroring"
      ")" )))

   (service-request req-string))))

(defun enable-told-information-querying ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-told-information-querying"
      ")" )))

   (service-request req-string))))

(defun enable-two-phase-query-processing-mode ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-two-phase-query-processing-mode"
      ")" )))

   (service-request req-string))))

(defun enable-very-smart-abox-mirroring ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "enable-very-smart-abox-mirroring"
      ")" )))

   (service-request req-string))))

(defun ensure-abox-signature ( abox-name-or-abox &key  (individuals nil individuals-supplied-p) (objects nil objects-supplied-p))
 (declare (ignorable  individuals objects abox-name-or-abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "ensure-abox-signature"
      (myformat nil " ~S" (transform-s-expr abox-name-or-abox))
      (when individuals-supplied-p (myformat nil " :individuals ~S" (transform-s-expr individuals)))
      (when objects-supplied-p (myformat nil " :objects ~S" (transform-s-expr objects)))
      ")" )))

   (service-request req-string))))

(defun ensure-subsumption-based-query-answering ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "ensure-subsumption-based-query-answering"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun ensure-tbox-signature ( tbox &key  (atomic-concepts nil atomic-concepts-supplied-p) (roles nil roles-supplied-p) (transitive-roles nil transitive-roles-supplied-p) (features nil features-supplied-p) (attributes nil attributes-supplied-p))
 (declare (ignorable  atomic-concepts roles transitive-roles features attributes tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "ensure-tbox-signature"
      (myformat nil " ~S" (transform-s-expr tbox))
      (when atomic-concepts-supplied-p (myformat nil " :atomic-concepts ~S" (transform-s-expr atomic-concepts)))
      (when roles-supplied-p (myformat nil " :roles ~S" (transform-s-expr roles)))
      (when transitive-roles-supplied-p (myformat nil " :transitive-roles ~S" (transform-s-expr transitive-roles)))
      (when features-supplied-p (myformat nil " :features ~S" (transform-s-expr features)))
      (when attributes-supplied-p (myformat nil " :attributes ~S" (transform-s-expr attributes)))
      ")" )))

   (service-request req-string))))

(defun exclude-permutations ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "exclude-permutations"
      ")" )))

   (service-request req-string))))

(defun execute-all-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p))
 (declare (ignorable  abox type-of-substrate dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "execute-all-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      ")" )))

   (service-request req-string))))

(defun execute-all-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "execute-all-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun execute-applicable-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "execute-applicable-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun execute-or-reexecute-all-queries ( &key  (debug-p nil debug-p-supplied-p) (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p))
 (declare (ignorable  debug-p abox type-of-substrate dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "execute-or-reexecute-all-queries"
      (when debug-p-supplied-p (myformat nil " :debug-p ~S" (transform-s-expr debug-p)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      ")" )))

   (service-request req-string))))

(defun execute-or-reexecute-all-rules ( &key  (debug-p nil debug-p-supplied-p) (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  debug-p abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "execute-or-reexecute-all-rules"
      (when debug-p-supplied-p (myformat nil " :debug-p ~S" (transform-s-expr debug-p)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun execute-or-reexecute-query ( query &key  (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p))
 (declare (ignorable  dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "execute-or-reexecute-query"
      (myformat nil " ~S" (transform-s-expr query))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      ")" )))

   (service-request req-string))))

(defun execute-or-reexecute-rule ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "execute-or-reexecute-rule"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun execute-query ( query &key  (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p))
 (declare (ignorable  dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "execute-query"
      (myformat nil " ~S" (transform-s-expr query))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      ")" )))

   (service-request req-string))))

(defun execute-rule ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "execute-rule"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun expensive-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "expensive-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun expensive-query-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "expensive-query-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun expensive-rule-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "expensive-rule-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun expensive-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "expensive-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun fcall ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "fcall"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   (service-request req-string))))

(defun feature-p ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "feature-p"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun find-abox ( abox-name-or-abox &optional  (errorp nil errorp-supplied-p))
 (declare (ignorable  errorp abox-name-or-abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "find-abox"
      (myformat nil " ~S" (transform-s-expr abox-name-or-abox))
      (when errorp-supplied-p (myformat nil " ~S" (transform-s-expr errorp)))
      ")" )))

   (service-request req-string))))

(defun find-tbox ( tbox &optional  (errorp nil errorp-supplied-p))
 (declare (ignorable  errorp tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "find-tbox"
      (myformat nil " ~S" (transform-s-expr tbox))
      (when errorp-supplied-p (myformat nil " ~S" (transform-s-expr errorp)))
      ")" )))

   (service-request req-string))))

(defun forget-abox ( abox)
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-abox"
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun forget-all-different-assertion ( abox individual-name-set)
 (declare (ignorable  abox individual-name-set))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-all-different-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual-name-set))
      ")" )))

   (service-request req-string))))

(defun forget-annotation-concept-assertion ( abox individual-name concept)
 (declare (ignorable  abox individual-name concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-annotation-concept-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual-name))
      (myformat nil " ~S" (transform-s-expr concept))
      ")" )))

   (service-request req-string))))

(defun forget-concept-assertion ( abox individual-name concept)
 (declare (ignorable  abox individual-name concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-concept-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual-name))
      (myformat nil " ~S" (transform-s-expr concept))
      ")" )))

   (service-request req-string))))

(defun forget-concept-axiom ( tbox left right &key  (inclusion-p nil inclusion-p-supplied-p))
 (declare (ignorable  inclusion-p tbox left right))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-concept-axiom"
      (myformat nil " ~S" (transform-s-expr tbox))
      (myformat nil " ~S" (transform-s-expr left))
      (myformat nil " ~S" (transform-s-expr right))
      (when inclusion-p-supplied-p (myformat nil " :inclusion-p ~S" (transform-s-expr inclusion-p)))
      ")" )))

   (service-request req-string))))

(defun forget-constrained-assertion ( abox individual-name object-name attribute-term)
 (declare (ignorable  abox individual-name object-name attribute-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-constrained-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual-name))
      (myformat nil " ~S" (transform-s-expr object-name))
      (myformat nil " ~S" (transform-s-expr attribute-term))
      ")" )))

   (service-request req-string))))

(defun forget-constraint ( abox constraint)
 (declare (ignorable  abox constraint))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-constraint"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr constraint))
      ")" )))

   (service-request req-string))))

(defun forget-datatype-role-filler ( abox individual value role)
 (declare (ignorable  abox individual value role))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-datatype-role-filler"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr value))
      (myformat nil " ~S" (transform-s-expr role))
      ")" )))

   (service-request req-string))))

(defun forget-different-from-assertion ( abox individual-1 individual-2)
 (declare (ignorable  abox individual-1 individual-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-different-from-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual-1))
      (myformat nil " ~S" (transform-s-expr individual-2))
      ")" )))

   (service-request req-string))))

(defun forget-disjointness-axiom ( tbox concept-name group-name &optional  (form nil form-supplied-p))
 (declare (ignorable  form tbox concept-name group-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-disjointness-axiom"
      (myformat nil " ~S" (transform-s-expr tbox))
      (myformat nil " ~S" (transform-s-expr concept-name))
      (myformat nil " ~S" (transform-s-expr group-name))
      (when form-supplied-p (myformat nil " ~S" (transform-s-expr form)))
      ")" )))

   (service-request req-string))))

(defun forget-disjointness-axiom-statement ( tbox concepts)
 (declare (ignorable  tbox concepts))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-disjointness-axiom-statement"
      (myformat nil " ~S" (transform-s-expr tbox))
      (myformat nil " ~S" (transform-s-expr concepts))
      ")" )))

   (service-request req-string))))

(defun forget-individual ( individual &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-individual"
      (myformat nil " ~S" (transform-s-expr individual))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun forget-negated-role-assertion ( abox predecessor-name filler-name role-term)
 (declare (ignorable  abox predecessor-name filler-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-negated-role-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr predecessor-name))
      (myformat nil " ~S" (transform-s-expr filler-name))
      (myformat nil " ~S" (transform-s-expr role-term))
      ")" )))

   (service-request req-string))))

(defun forget-negative-datatype-role-filler ( abox individual value role)
 (declare (ignorable  abox individual value role))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-negative-datatype-role-filler"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr value))
      (myformat nil " ~S" (transform-s-expr role))
      ")" )))

   (service-request req-string))))

(defun forget-role-assertion ( abox predecessor-name filler-name role-term)
 (declare (ignorable  abox predecessor-name filler-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-role-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr predecessor-name))
      (myformat nil " ~S" (transform-s-expr filler-name))
      (myformat nil " ~S" (transform-s-expr role-term))
      ")" )))

   (service-request req-string))))

(defun forget-role-axioms ( tbox role &key  (cd-attribute nil cd-attribute-supplied-p) (parents nil parents-supplied-p) (parent nil parent-supplied-p) (transitive nil transitive-supplied-p) (transitive-p nil transitive-p-supplied-p) (feature nil feature-supplied-p) (feature-p nil feature-p-supplied-p) (domain nil domain-supplied-p) (range nil range-supplied-p) (inverse nil inverse-supplied-p) (symmetric nil symmetric-supplied-p) (reflexive nil reflexive-supplied-p) (reflexive-p nil reflexive-p-supplied-p) (datatype nil datatype-supplied-p) (annotation-p nil annotation-p-supplied-p))
 (declare (ignorable  cd-attribute parents parent transitive transitive-p feature feature-p domain range inverse symmetric reflexive reflexive-p datatype annotation-p tbox role))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-role-axioms"
      (myformat nil " ~S" (transform-s-expr tbox))
      (myformat nil " ~S" (transform-s-expr role))
      (when cd-attribute-supplied-p (myformat nil " :cd-attribute ~S" (transform-s-expr cd-attribute)))
      (when parents-supplied-p (myformat nil " :parents ~S" (transform-s-expr parents)))
      (when parent-supplied-p (myformat nil " :parent ~S" (transform-s-expr parent)))
      (when transitive-supplied-p (myformat nil " :transitive ~S" (transform-s-expr transitive)))
      (when transitive-p-supplied-p (myformat nil " :transitive-p ~S" (transform-s-expr transitive-p)))
      (when feature-supplied-p (myformat nil " :feature ~S" (transform-s-expr feature)))
      (when feature-p-supplied-p (myformat nil " :feature-p ~S" (transform-s-expr feature-p)))
      (when domain-supplied-p (myformat nil " :domain ~S" (transform-s-expr domain)))
      (when range-supplied-p (myformat nil " :range ~S" (transform-s-expr range)))
      (when inverse-supplied-p (myformat nil " :inverse ~S" (transform-s-expr inverse)))
      (when symmetric-supplied-p (myformat nil " :symmetric ~S" (transform-s-expr symmetric)))
      (when reflexive-supplied-p (myformat nil " :reflexive ~S" (transform-s-expr reflexive)))
      (when reflexive-p-supplied-p (myformat nil " :reflexive-p ~S" (transform-s-expr reflexive-p)))
      (when datatype-supplied-p (myformat nil " :datatype ~S" (transform-s-expr datatype)))
      (when annotation-p-supplied-p (myformat nil " :annotation-p ~S" (transform-s-expr annotation-p)))
      ")" )))

   (service-request req-string))))

(defun forget-same-individual-as-assertion ( abox individual-1 individual-2)
 (declare (ignorable  abox individual-1 individual-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-same-individual-as-assertion"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual-1))
      (myformat nil " ~S" (transform-s-expr individual-2))
      ")" )))

   (service-request req-string))))

(defun forget-statement ( tbox abox assertions)
 (declare (ignorable  tbox abox assertions))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-statement"
      (myformat nil " ~S" (transform-s-expr tbox))
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr assertions))
      ")" )))

   (service-request req-string))))

(defun forget-tbox ( tbox)
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget-tbox"
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun full-reset ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "full-reset"
      ")" )))

   (service-request req-string))))

(defun get-abox-graph ( &optional  (abox nil abox-supplied-p) &key  (depth nil depth-supplied-p) (no-transitives-p nil no-transitives-p-supplied-p) (no-top-role-p nil no-top-role-p-supplied-p) (browsing-mode-p nil browsing-mode-p-supplied-p) (told-only-p nil told-only-p-supplied-p) (root-individuals nil root-individuals-supplied-p) (selected-individuals nil selected-individuals-supplied-p) (only-successors-in-selected-individuals-p nil only-successors-in-selected-individuals-p-supplied-p) (for-roles nil for-roles-supplied-p) (for-datatype-properties nil for-datatype-properties-supplied-p) (for-annotation-properties nil for-annotation-properties-supplied-p))
 (declare (ignorable  abox depth no-transitives-p no-top-role-p browsing-mode-p told-only-p root-individuals selected-individuals only-successors-in-selected-individuals-p for-roles for-datatype-properties for-annotation-properties))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-abox-graph"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when depth-supplied-p (myformat nil " :depth ~S" (transform-s-expr depth)))
      (when no-transitives-p-supplied-p (myformat nil " :no-transitives-p ~S" (transform-s-expr no-transitives-p)))
      (when no-top-role-p-supplied-p (myformat nil " :no-top-role-p ~S" (transform-s-expr no-top-role-p)))
      (when browsing-mode-p-supplied-p (myformat nil " :browsing-mode-p ~S" (transform-s-expr browsing-mode-p)))
      (when told-only-p-supplied-p (myformat nil " :told-only-p ~S" (transform-s-expr told-only-p)))
      (when root-individuals-supplied-p (myformat nil " :root-individuals ~S" (transform-s-expr root-individuals)))
      (when selected-individuals-supplied-p (myformat nil " :selected-individuals ~S" (transform-s-expr selected-individuals)))
      (when only-successors-in-selected-individuals-p-supplied-p (myformat nil " :only-successors-in-selected-individuals-p ~S" (transform-s-expr only-successors-in-selected-individuals-p)))
      (when for-roles-supplied-p (myformat nil " :for-roles ~S" (transform-s-expr for-roles)))
      (when for-datatype-properties-supplied-p (myformat nil " :for-datatype-properties ~S" (transform-s-expr for-datatype-properties)))
      (when for-annotation-properties-supplied-p (myformat nil " :for-annotation-properties ~S" (transform-s-expr for-annotation-properties)))
      ")" )))

   (service-request req-string))))

(defun get-abox-language ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-abox-language"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun get-abox-signature ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-abox-signature"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun get-abox-version ( abox)
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-abox-version"
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun get-agraph-version ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-agraph-version"
      ")" )))

   (service-request req-string))))

(defun get-all-answers ( &key  (ready-p nil ready-p-supplied-p) (active-p nil active-p-supplied-p) (processed-p nil processed-p-supplied-p) (queries-p nil queries-p-supplied-p) (rules-p nil rules-p-supplied-p) (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (execute-p nil execute-p-supplied-p))
 (declare (ignorable  ready-p active-p processed-p queries-p rules-p abox type-of-substrate dont-show-variables execute-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-all-answers"
      (when ready-p-supplied-p (myformat nil " :ready-p ~S" (transform-s-expr ready-p)))
      (when active-p-supplied-p (myformat nil " :active-p ~S" (transform-s-expr active-p)))
      (when processed-p-supplied-p (myformat nil " :processed-p ~S" (transform-s-expr processed-p)))
      (when queries-p-supplied-p (myformat nil " :queries-p ~S" (transform-s-expr queries-p)))
      (when rules-p-supplied-p (myformat nil " :rules-p ~S" (transform-s-expr rules-p)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      ")" )))

   (service-request req-string))))

(defun get-all-functions ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-all-functions"
      ")" )))

   (service-request req-string))))

(defun get-all-remaining-sets-of-rule-consequences ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-all-remaining-sets-of-rule-consequences"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun get-all-remaining-tuples ( query &key  (execute-p nil execute-p-supplied-p))
 (declare (ignorable  execute-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-all-remaining-tuples"
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      ")" )))

   (service-request req-string))))

(defun get-all-server-functions ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-all-server-functions"
      ")" )))

   (service-request req-string))))

(defun get-all-server-values ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-all-server-values"
      ")" )))

   (service-request req-string))))

(defun get-all-values ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-all-values"
      ")" )))

   (service-request req-string))))

(defun get-answer ( query &key  (dont-show-variables nil dont-show-variables-supplied-p) (execute-p nil execute-p-supplied-p))
 (declare (ignorable  dont-show-variables execute-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-answer"
      (myformat nil " ~S" (transform-s-expr query))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      ")" )))

   (service-request req-string))))

(defun get-answer-size ( query &key  (dont-show-variables nil dont-show-variables-supplied-p) (execute-p nil execute-p-supplied-p))
 (declare (ignorable  dont-show-variables execute-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-answer-size"
      (myformat nil " ~S" (transform-s-expr query))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      ")" )))

   (service-request req-string))))

(defun get-build-version ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-build-version"
      ")" )))

   (service-request req-string))))

(defun get-chosen-sets-of-rule-consequences ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-chosen-sets-of-rule-consequences"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun get-concept-definition-1 ( concept-name tbox)
 (declare (ignorable  concept-name tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-concept-definition-1"
      (myformat nil " ~S" (transform-s-expr concept-name))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun get-concept-negated-definition-1 ( concept-name tbox)
 (declare (ignorable  concept-name tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-concept-negated-definition-1"
      (myformat nil " ~S" (transform-s-expr concept-name))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun get-concept-pmodel ( concept-expr tbox)
 (declare (ignorable  concept-expr tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-concept-pmodel"
      (myformat nil " ~S" (transform-s-expr concept-expr))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun get-concept-properties ( concept &optional  (tbox nil tbox-supplied-p) &key  (for-roles nil for-roles-supplied-p) (qualifications nil qualifications-supplied-p))
 (declare (ignorable  tbox for-roles qualifications concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-concept-properties"
      (myformat nil " ~S" (transform-s-expr concept))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when for-roles-supplied-p (myformat nil " :for-roles ~S" (transform-s-expr for-roles)))
      (when qualifications-supplied-p (myformat nil " :qualifications ~S" (transform-s-expr qualifications)))
      ")" )))

   (service-request req-string))))

(defun get-current-set-of-rule-consequences ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-current-set-of-rule-consequences"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun get-current-tuple ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-current-tuple"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun get-dag-of-qbox-for-abox ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-dag-of-qbox-for-abox"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun get-data-bottom-role ( tbox)
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-data-bottom-role"
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun get-data-edge-description ( from to &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate from to))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-data-edge-description"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun get-data-edge-label ( from to &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate from to))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-data-edge-label"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun get-data-node-description ( name &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-data-node-description"
      (myformat nil " ~S" (transform-s-expr name))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun get-data-node-label ( name &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-data-node-label"
      (myformat nil " ~S" (transform-s-expr name))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun get-edge-label-for-non-existent-edges ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-edge-label-for-non-existent-edges"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun get-explanations ( query &key  (from nil from-supplied-p) (to nil to-supplied-p) (only-best-p nil only-best-p-supplied-p) (order-by nil order-by-supplied-p) (reverse-order-p nil reverse-order-p-supplied-p) (equi-order-by nil equi-order-by-supplied-p) (remove-marker-symbols-p nil remove-marker-symbols-p-supplied-p) (remove-entailed-explanations-p nil remove-entailed-explanations-p-supplied-p) (new-inds-p nil new-inds-p-supplied-p) (tuples-p nil tuples-p-supplied-p) (full-tuples-p nil full-tuples-p-supplied-p) (all-assertions-p nil all-assertions-p-supplied-p) (hypothesized-assertions-p nil hypothesized-assertions-p-supplied-p) (show-score-p nil show-score-p-supplied-p) (abox-entailment nil abox-entailment-supplied-p) (ensure-permutations-p nil ensure-permutations-p-supplied-p))
 (declare (ignorable  from to only-best-p order-by reverse-order-p equi-order-by remove-marker-symbols-p remove-entailed-explanations-p new-inds-p tuples-p full-tuples-p all-assertions-p hypothesized-assertions-p show-score-p abox-entailment ensure-permutations-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-explanations"
      (myformat nil " ~S" (transform-s-expr query))
      (when from-supplied-p (myformat nil " :from ~S" (transform-s-expr from)))
      (when to-supplied-p (myformat nil " :to ~S" (transform-s-expr to)))
      (when only-best-p-supplied-p (myformat nil " :only-best-p ~S" (transform-s-expr only-best-p)))
      (when order-by-supplied-p (myformat nil " :order-by ~S" (transform-s-expr order-by)))
      (when reverse-order-p-supplied-p (myformat nil " :reverse-order-p ~S" (transform-s-expr reverse-order-p)))
      (when equi-order-by-supplied-p (myformat nil " :equi-order-by ~S" (transform-s-expr equi-order-by)))
      (when remove-marker-symbols-p-supplied-p (myformat nil " :remove-marker-symbols-p ~S" (transform-s-expr remove-marker-symbols-p)))
      (when remove-entailed-explanations-p-supplied-p (myformat nil " :remove-entailed-explanations-p ~S" (transform-s-expr remove-entailed-explanations-p)))
      (when new-inds-p-supplied-p (myformat nil " :new-inds-p ~S" (transform-s-expr new-inds-p)))
      (when tuples-p-supplied-p (myformat nil " :tuples-p ~S" (transform-s-expr tuples-p)))
      (when full-tuples-p-supplied-p (myformat nil " :full-tuples-p ~S" (transform-s-expr full-tuples-p)))
      (when all-assertions-p-supplied-p (myformat nil " :all-assertions-p ~S" (transform-s-expr all-assertions-p)))
      (when hypothesized-assertions-p-supplied-p (myformat nil " :hypothesized-assertions-p ~S" (transform-s-expr hypothesized-assertions-p)))
      (when show-score-p-supplied-p (myformat nil " :show-score-p ~S" (transform-s-expr show-score-p)))
      (when abox-entailment-supplied-p (myformat nil " :abox-entailment ~S" (transform-s-expr abox-entailment)))
      (when ensure-permutations-p-supplied-p (myformat nil " :ensure-permutations-p ~S" (transform-s-expr ensure-permutations-p)))
      ")" )))

   (service-request req-string))))

(defun get-individual-annotation-datatype-fillers ( individual-name &optional  (abox nil abox-supplied-p) (with-types-p nil with-types-p-supplied-p))
 (declare (ignorable  abox with-types-p individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-individual-annotation-datatype-fillers"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when with-types-p-supplied-p (myformat nil " ~S" (transform-s-expr with-types-p)))
      ")" )))

   (service-request req-string))))

(defun get-individual-annotation-fillers ( individual-name &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-individual-annotation-fillers"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun get-individual-datatype-fillers ( individual-name &optional  (abox nil abox-supplied-p) (with-types-p nil with-types-p-supplied-p))
 (declare (ignorable  abox with-types-p individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-individual-datatype-fillers"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when with-types-p-supplied-p (myformat nil " ~S" (transform-s-expr with-types-p)))
      ")" )))

   (service-request req-string))))

(defun get-individual-pmodel ( individual-name abox)
 (declare (ignorable  individual-name abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-individual-pmodel"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun get-individual-successors ( ind &key  (no-inverses-p nil no-inverses-p-supplied-p) (only-inverses-p nil only-inverses-p-supplied-p) (no-transitives-p nil no-transitives-p-supplied-p) (no-top-role-p nil no-top-role-p-supplied-p) (negated-p nil negated-p-supplied-p) (roles nil roles-supplied-p) (only-one-p nil only-one-p-supplied-p) (only-if-p nil only-if-p-supplied-p) (abox nil abox-supplied-p) (remove-synonyms-p nil remove-synonyms-p-supplied-p) (show-synonyms-p nil show-synonyms-p-supplied-p))
 (declare (ignorable  no-inverses-p only-inverses-p no-transitives-p no-top-role-p negated-p roles only-one-p only-if-p abox remove-synonyms-p show-synonyms-p ind))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-individual-successors"
      (myformat nil " ~S" (transform-s-expr ind))
      (when no-inverses-p-supplied-p (myformat nil " :no-inverses-p ~S" (transform-s-expr no-inverses-p)))
      (when only-inverses-p-supplied-p (myformat nil " :only-inverses-p ~S" (transform-s-expr only-inverses-p)))
      (when no-transitives-p-supplied-p (myformat nil " :no-transitives-p ~S" (transform-s-expr no-transitives-p)))
      (when no-top-role-p-supplied-p (myformat nil " :no-top-role-p ~S" (transform-s-expr no-top-role-p)))
      (when negated-p-supplied-p (myformat nil " :negated-p ~S" (transform-s-expr negated-p)))
      (when roles-supplied-p (myformat nil " :roles ~S" (transform-s-expr roles)))
      (when only-one-p-supplied-p (myformat nil " :only-one-p ~S" (transform-s-expr only-one-p)))
      (when only-if-p-supplied-p (myformat nil " :only-if-p ~S" (transform-s-expr only-if-p)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when remove-synonyms-p-supplied-p (myformat nil " :remove-synonyms-p ~S" (transform-s-expr remove-synonyms-p)))
      (when show-synonyms-p-supplied-p (myformat nil " :show-synonyms-p ~S" (transform-s-expr show-synonyms-p)))
      ")" )))

   (service-request req-string))))

(defun get-initial-size-of-process-pool ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-initial-size-of-process-pool"
      ")" )))

   (service-request req-string))))

(defun get-kb-signature ( kb-name)
 (declare (ignorable  kb-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-kb-signature"
      (myformat nil " ~S" (transform-s-expr kb-name))
      ")" )))

   (service-request req-string))))

(defun get-max-no-of-tuples-bound ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-max-no-of-tuples-bound"
      ")" )))

   (service-request req-string))))

(defun get-maximum ( aboxes &key  (key nil key-supplied-p))
 (declare (ignorable  key aboxes))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-maximum"
      (myformat nil " ~S" (transform-s-expr aboxes))
      (when key-supplied-p (myformat nil " :key ~S" (transform-s-expr key)))
      ")" )))

   (service-request req-string))))

(defun get-maximum-size-of-process-pool ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-maximum-size-of-process-pool"
      ")" )))

   (service-request req-string))))

(defun get-meta-constraint ( &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-meta-constraint"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun get-minimum ( aboxes &key  (key nil key-supplied-p))
 (declare (ignorable  key aboxes))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-minimum"
      (myformat nil " ~S" (transform-s-expr aboxes))
      (when key-supplied-p (myformat nil " :key ~S" (transform-s-expr key)))
      ")" )))

   (service-request req-string))))

(defun get-namespace-prefix ( tbox)
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-namespace-prefix"
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun get-new-ind-counter ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-new-ind-counter"
      ")" )))

   (service-request req-string))))

(defun get-new-ind-prefix ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-new-ind-prefix"
      ")" )))

   (service-request req-string))))

(defun get-next-n-remaining-sets-of-rule-consequences ( query &optional  (n nil n-supplied-p))
 (declare (ignorable  n query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-next-n-remaining-sets-of-rule-consequences"
      (myformat nil " ~S" (transform-s-expr query))
      (when n-supplied-p (myformat nil " ~S" (transform-s-expr n)))
      ")" )))

   (service-request req-string))))

(defun get-next-n-remaining-tuples ( query &optional  (n nil n-supplied-p) &key  (execute-p nil execute-p-supplied-p))
 (declare (ignorable  n execute-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-next-n-remaining-tuples"
      (myformat nil " ~S" (transform-s-expr query))
      (when n-supplied-p (myformat nil " ~S" (transform-s-expr n)))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      ")" )))

   (service-request req-string))))

(defun get-next-set-of-rule-consequences ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-next-set-of-rule-consequences"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun get-next-tuple ( query &key  (execute-p nil execute-p-supplied-p))
 (declare (ignorable  execute-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-next-tuple"
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      ")" )))

   (service-request req-string))))

(defun get-nodes-in-qbox-for-abox ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-nodes-in-qbox-for-abox"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun get-nrql-version ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-nrql-version"
      ")" )))

   (service-request req-string))))

(defun get-number-of-explanations ( query &key  (dont-show-variables nil dont-show-variables-supplied-p) (execute-p nil execute-p-supplied-p))
 (declare (ignorable  dont-show-variables execute-p query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-number-of-explanations"
      (myformat nil " ~S" (transform-s-expr query))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      ")" )))

   (service-request req-string))))

(defun get-object-bottom-role ( tbox)
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-object-bottom-role"
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun get-prefixes ( &optional  (tbox nil tbox-supplied-p) (ask-owlapi-p nil ask-owlapi-p-supplied-p))
 (declare (ignorable  tbox ask-owlapi-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-prefixes"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when ask-owlapi-p-supplied-p (myformat nil " ~S" (transform-s-expr ask-owlapi-p)))
      ")" )))

   (service-request req-string))))

(defun get-process-pool-size ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-process-pool-size"
      ")" )))

   (service-request req-string))))

(defun get-proxy-server ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-proxy-server"
      ")" )))

   (service-request req-string))))

(defun get-role-datatype ( role-name &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-role-datatype"
      (myformat nil " ~S" (transform-s-expr role-name))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun get-role-hierarchy ( &optional  (tbox nil tbox-supplied-p) &key  (for-roles nil for-roles-supplied-p))
 (declare (ignorable  tbox for-roles))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-role-hierarchy"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when for-roles-supplied-p (myformat nil " :for-roles ~S" (transform-s-expr for-roles)))
      ")" )))

   (service-request req-string))))

(defun get-server-timeout ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-server-timeout"
      ")" )))

   (service-request req-string))))

(defun get-substrate-edges ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-substrate-edges"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun get-substrate-nodes ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-substrate-nodes"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun get-substrate-type ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-substrate-type"
      ")" )))

   (service-request req-string))))

(defun get-tbox-language ( &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-tbox-language"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun get-tbox-signature ( &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-tbox-signature"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun get-tbox-version ( tbox)
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-tbox-version"
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun in-unsafe-mode? ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "in-unsafe-mode?"
      ")" )))

   (service-request req-string))))

(defun inaccurate-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "inaccurate-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun inaccurate-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "inaccurate-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun include-kb ( pathname)
 (declare (ignorable  pathname))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "include-kb"
      (myformat nil " ~S" (transform-s-expr pathname))
      ")" )))

   (service-request req-string))))

(defun include-permutations ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "include-permutations"
      ")" )))

   (service-request req-string))))

(defun index-all-triples ( &key  (db nil db-supplied-p))
 (declare (ignorable  db))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "index-all-triples"
      (when db-supplied-p (myformat nil " :db ~S" (transform-s-expr db)))
      ")" )))

   (service-request req-string))))

(defun individual-instance-p ( individual-name concept abox)
 (declare (ignorable  individual-name concept abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-instance-p"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (myformat nil " ~S" (transform-s-expr concept))
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun individual-p ( individual-name &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-p"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun individuals-equal-p ( individual-1 individual-2 &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual-1 individual-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individuals-equal-p"
      (myformat nil " ~S" (transform-s-expr individual-1))
      (myformat nil " ~S" (transform-s-expr individual-2))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun individuals-not-equal-p ( individual-1 individual-2 &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual-1 individual-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individuals-not-equal-p"
      (myformat nil " ~S" (transform-s-expr individual-1))
      (myformat nil " ~S" (transform-s-expr individual-2))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun individuals-related-p ( ind-predecessor-name-set ind-filler-name-set role-term abox)
 (declare (ignorable  ind-predecessor-name-set ind-filler-name-set role-term abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individuals-related-p"
      (myformat nil " ~S" (transform-s-expr ind-predecessor-name-set))
      (myformat nil " ~S" (transform-s-expr ind-filler-name-set))
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun init-abox ( abox &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "init-abox"
      (myformat nil " ~S" (transform-s-expr abox))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun init-publications-1 ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "init-publications-1"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun init-subscriptions-1 ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "init-subscriptions-1"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun init-tbox ( tbox &key  (original nil original-supplied-p) (reset nil reset-supplied-p))
 (declare (ignorable  original reset tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "init-tbox"
      (myformat nil " ~S" (transform-s-expr tbox))
      (when original-supplied-p (myformat nil " :original ~S" (transform-s-expr original)))
      (when reset-supplied-p (myformat nil " :reset ~S" (transform-s-expr reset)))
      ")" )))

   (service-request req-string))))

(defun installed-patches ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "installed-patches"
      ")" )))

   (service-request req-string))))

(defun installed-plugins ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "installed-plugins"
      ")" )))

   (service-request req-string))))

(defun instantiators ( individual-name abox)
 (declare (ignorable  individual-name abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "instantiators"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun internal-individuals-related-p ( ind-predecessor-name-set ind-filler-name-set role-term abox &optional  (check-p nil check-p-supplied-p))
 (declare (ignorable  check-p ind-predecessor-name-set ind-filler-name-set role-term abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "internal-individuals-related-p"
      (myformat nil " ~S" (transform-s-expr ind-predecessor-name-set))
      (myformat nil " ~S" (transform-s-expr ind-filler-name-set))
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr abox))
      (when check-p-supplied-p (myformat nil " ~S" (transform-s-expr check-p)))
      ")" )))

   (service-request req-string))))

(defun inverse-feature-p ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "inverse-feature-p"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun inverse-of-role ( rolename inverse-role tbox)
 (declare (ignorable  rolename inverse-role tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "inverse-of-role"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr inverse-role))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun irreflexive-p ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "irreflexive-p"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun kb-ontologies ( kb-name)
 (declare (ignorable  kb-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "kb-ontologies"
      (myformat nil " ~S" (transform-s-expr kb-name))
      ")" )))

   (service-request req-string))))

(defun keep-defined-query-atoms ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "keep-defined-query-atoms"
      ")" )))

   (service-request req-string))))

(defun lcs ( concept1 concept2)
 (declare (ignorable  concept1 concept2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "lcs"
      (myformat nil " ~S" (transform-s-expr concept1))
      (myformat nil " ~S" (transform-s-expr concept2))
      ")" )))

   (service-request req-string))))

(defun lcs-unfold ( concept-1 concept-2 &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept-1 concept-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "lcs-unfold"
      (myformat nil " ~S" (transform-s-expr concept-1))
      (myformat nil " ~S" (transform-s-expr concept-2))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun load-racer-patch ( fn)
 (declare (ignorable  fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "load-racer-patch"
      (myformat nil " ~S" (transform-s-expr fn))
      ")" )))

   (service-request req-string))))

(defun load-racer-patches ( directory)
 (declare (ignorable  directory))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "load-racer-patches"
      (myformat nil " ~S" (transform-s-expr directory))
      ")" )))

   (service-request req-string))))

(defun load-racer-plugin ( fn)
 (declare (ignorable  fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "load-racer-plugin"
      (myformat nil " ~S" (transform-s-expr fn))
      ")" )))

   (service-request req-string))))

(defun load-racer-plugins ( directory)
 (declare (ignorable  directory))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "load-racer-plugins"
      (myformat nil " ~S" (transform-s-expr directory))
      ")" )))

   (service-request req-string))))

(defun logging-off ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "logging-off"
      ")" )))

   (service-request req-string))))

(defun logging-on ( &optional  (filename nil filename-supplied-p) (debug nil debug-supplied-p))
 (declare (ignorable  filename debug))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "logging-on"
      (when filename-supplied-p (myformat nil " ~S" (transform-s-expr filename)))
      (when debug-supplied-p (myformat nil " ~S" (transform-s-expr debug)))
      ")" )))

   (service-request req-string))))

(defun make-abduction-rule-from-aboxes ( precond-abox postcond-abox for-abox &key  (forward-rule-p nil forward-rule-p-supplied-p) (backward-rule-p nil backward-rule-p-supplied-p) (known-correspondences nil known-correspondences-supplied-p) (common-concept-assertions nil common-concept-assertions-supplied-p) (common-role-assertions nil common-role-assertions-supplied-p) (common-same-as-assertions nil common-same-as-assertions-supplied-p) (common-different-from-assertions nil common-different-from-assertions-supplied-p) (common-as-strict-atoms-p nil common-as-strict-atoms-p-supplied-p) (injective-variables-p nil injective-variables-p-supplied-p) (forward-rule-consequence-p nil forward-rule-consequence-p-supplied-p))
 (declare (ignorable  forward-rule-p backward-rule-p known-correspondences common-concept-assertions common-role-assertions common-same-as-assertions common-different-from-assertions common-as-strict-atoms-p injective-variables-p forward-rule-consequence-p precond-abox postcond-abox for-abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "make-abduction-rule-from-aboxes"
      (myformat nil " ~S" (transform-s-expr precond-abox))
      (myformat nil " ~S" (transform-s-expr postcond-abox))
      (myformat nil " ~S" (transform-s-expr for-abox))
      (when forward-rule-p-supplied-p (myformat nil " :forward-rule-p ~S" (transform-s-expr forward-rule-p)))
      (when backward-rule-p-supplied-p (myformat nil " :backward-rule-p ~S" (transform-s-expr backward-rule-p)))
      (when known-correspondences-supplied-p (myformat nil " :known-correspondences ~S" (transform-s-expr known-correspondences)))
      (when common-concept-assertions-supplied-p (myformat nil " :common-concept-assertions ~S" (transform-s-expr common-concept-assertions)))
      (when common-role-assertions-supplied-p (myformat nil " :common-role-assertions ~S" (transform-s-expr common-role-assertions)))
      (when common-same-as-assertions-supplied-p (myformat nil " :common-same-as-assertions ~S" (transform-s-expr common-same-as-assertions)))
      (when common-different-from-assertions-supplied-p (myformat nil " :common-different-from-assertions ~S" (transform-s-expr common-different-from-assertions)))
      (when common-as-strict-atoms-p-supplied-p (myformat nil " :common-as-strict-atoms-p ~S" (transform-s-expr common-as-strict-atoms-p)))
      (when injective-variables-p-supplied-p (myformat nil " :injective-variables-p ~S" (transform-s-expr injective-variables-p)))
      (when forward-rule-consequence-p-supplied-p (myformat nil " :forward-rule-consequence-p ~S" (transform-s-expr forward-rule-consequence-p)))
      ")" )))

   (service-request req-string))))

(defun make-backward-rule-from-aboxes ( precond-abox postcond-abox for-abox &key  (known-correspondences nil known-correspondences-supplied-p) (common-concept-assertions nil common-concept-assertions-supplied-p) (common-role-assertions nil common-role-assertions-supplied-p) (common-same-as-assertions nil common-same-as-assertions-supplied-p) (common-different-from-assertions nil common-different-from-assertions-supplied-p) (common-as-strict-atoms-p nil common-as-strict-atoms-p-supplied-p) (injective-variables-p nil injective-variables-p-supplied-p) (forward-rule-consequence-p nil forward-rule-consequence-p-supplied-p))
 (declare (ignorable  known-correspondences common-concept-assertions common-role-assertions common-same-as-assertions common-different-from-assertions common-as-strict-atoms-p injective-variables-p forward-rule-consequence-p precond-abox postcond-abox for-abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "make-backward-rule-from-aboxes"
      (myformat nil " ~S" (transform-s-expr precond-abox))
      (myformat nil " ~S" (transform-s-expr postcond-abox))
      (myformat nil " ~S" (transform-s-expr for-abox))
      (when known-correspondences-supplied-p (myformat nil " :known-correspondences ~S" (transform-s-expr known-correspondences)))
      (when common-concept-assertions-supplied-p (myformat nil " :common-concept-assertions ~S" (transform-s-expr common-concept-assertions)))
      (when common-role-assertions-supplied-p (myformat nil " :common-role-assertions ~S" (transform-s-expr common-role-assertions)))
      (when common-same-as-assertions-supplied-p (myformat nil " :common-same-as-assertions ~S" (transform-s-expr common-same-as-assertions)))
      (when common-different-from-assertions-supplied-p (myformat nil " :common-different-from-assertions ~S" (transform-s-expr common-different-from-assertions)))
      (when common-as-strict-atoms-p-supplied-p (myformat nil " :common-as-strict-atoms-p ~S" (transform-s-expr common-as-strict-atoms-p)))
      (when injective-variables-p-supplied-p (myformat nil " :injective-variables-p ~S" (transform-s-expr injective-variables-p)))
      (when forward-rule-consequence-p-supplied-p (myformat nil " :forward-rule-consequence-p ~S" (transform-s-expr forward-rule-consequence-p)))
      ")" )))

   (service-request req-string))))

(defun make-forward-rule-from-aboxes ( precond-abox postcond-abox for-abox &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p) (known-correspondences nil known-correspondences-supplied-p) (common-concept-assertions nil common-concept-assertions-supplied-p) (common-role-assertions nil common-role-assertions-supplied-p) (common-same-as-assertions nil common-same-as-assertions-supplied-p) (common-different-from-assertions nil common-different-from-assertions-supplied-p) (common-as-strict-atoms-p nil common-as-strict-atoms-p-supplied-p) (injective-variables-p nil injective-variables-p-supplied-p) (forward-rule-consequence-p nil forward-rule-consequence-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p known-correspondences common-concept-assertions common-role-assertions common-same-as-assertions common-different-from-assertions common-as-strict-atoms-p injective-variables-p forward-rule-consequence-p precond-abox postcond-abox for-abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "make-forward-rule-from-aboxes"
      (myformat nil " ~S" (transform-s-expr precond-abox))
      (myformat nil " ~S" (transform-s-expr postcond-abox))
      (myformat nil " ~S" (transform-s-expr for-abox))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      (when known-correspondences-supplied-p (myformat nil " :known-correspondences ~S" (transform-s-expr known-correspondences)))
      (when common-concept-assertions-supplied-p (myformat nil " :common-concept-assertions ~S" (transform-s-expr common-concept-assertions)))
      (when common-role-assertions-supplied-p (myformat nil " :common-role-assertions ~S" (transform-s-expr common-role-assertions)))
      (when common-same-as-assertions-supplied-p (myformat nil " :common-same-as-assertions ~S" (transform-s-expr common-same-as-assertions)))
      (when common-different-from-assertions-supplied-p (myformat nil " :common-different-from-assertions ~S" (transform-s-expr common-different-from-assertions)))
      (when common-as-strict-atoms-p-supplied-p (myformat nil " :common-as-strict-atoms-p ~S" (transform-s-expr common-as-strict-atoms-p)))
      (when injective-variables-p-supplied-p (myformat nil " :injective-variables-p ~S" (transform-s-expr injective-variables-p)))
      (when forward-rule-consequence-p-supplied-p (myformat nil " :forward-rule-consequence-p ~S" (transform-s-expr forward-rule-consequence-p)))
      ")" )))

   (service-request req-string))))

(defun make-plugin-from-fasl-file ( fn2 &key  (plugin-name nil plugin-name-supplied-p) (rand nil rand-supplied-p) (type nil type-supplied-p) (extension nil extension-supplied-p) (text-description nil text-description-supplied-p) (short-description nil short-description-supplied-p) (id nil id-supplied-p) (patch-name nil patch-name-supplied-p) (for-version nil for-version-supplied-p) (for-build nil for-build-supplied-p) (platform nil platform-supplied-p))
 (declare (ignorable  plugin-name rand type extension text-description short-description id patch-name for-version for-build platform fn2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "make-plugin-from-fasl-file"
      (myformat nil " ~S" (transform-s-expr fn2))
      (when plugin-name-supplied-p (myformat nil " :plugin-name ~S" (transform-s-expr plugin-name)))
      (when rand-supplied-p (myformat nil " :rand ~S" (transform-s-expr rand)))
      (when type-supplied-p (myformat nil " :type ~S" (transform-s-expr type)))
      (when extension-supplied-p (myformat nil " :extension ~S" (transform-s-expr extension)))
      (when text-description-supplied-p (myformat nil " :text-description ~S" (transform-s-expr text-description)))
      (when short-description-supplied-p (myformat nil " :short-description ~S" (transform-s-expr short-description)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when patch-name-supplied-p (myformat nil " :patch-name ~S" (transform-s-expr patch-name)))
      (when for-version-supplied-p (myformat nil " :for-version ~S" (transform-s-expr for-version)))
      (when for-build-supplied-p (myformat nil " :for-build ~S" (transform-s-expr for-build)))
      (when platform-supplied-p (myformat nil " :platform ~S" (transform-s-expr platform)))
      ")" )))

   (service-request req-string))))

(defun make-query-from-abox ( abox-or-name &key  (known-correspondences nil known-correspondences-supplied-p) (common-concept-assertions nil common-concept-assertions-supplied-p) (common-role-assertions nil common-role-assertions-supplied-p) (common-same-as-assertions nil common-same-as-assertions-supplied-p) (common-different-from-assertions nil common-different-from-assertions-supplied-p) (common-as-strict-atoms-p nil common-as-strict-atoms-p-supplied-p) (injective-variables-p nil injective-variables-p-supplied-p) (forward-rule-consequence-p nil forward-rule-consequence-p-supplied-p))
 (declare (ignorable  known-correspondences common-concept-assertions common-role-assertions common-same-as-assertions common-different-from-assertions common-as-strict-atoms-p injective-variables-p forward-rule-consequence-p abox-or-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "make-query-from-abox"
      (myformat nil " ~S" (transform-s-expr abox-or-name))
      (when known-correspondences-supplied-p (myformat nil " :known-correspondences ~S" (transform-s-expr known-correspondences)))
      (when common-concept-assertions-supplied-p (myformat nil " :common-concept-assertions ~S" (transform-s-expr common-concept-assertions)))
      (when common-role-assertions-supplied-p (myformat nil " :common-role-assertions ~S" (transform-s-expr common-role-assertions)))
      (when common-same-as-assertions-supplied-p (myformat nil " :common-same-as-assertions ~S" (transform-s-expr common-same-as-assertions)))
      (when common-different-from-assertions-supplied-p (myformat nil " :common-different-from-assertions ~S" (transform-s-expr common-different-from-assertions)))
      (when common-as-strict-atoms-p-supplied-p (myformat nil " :common-as-strict-atoms-p ~S" (transform-s-expr common-as-strict-atoms-p)))
      (when injective-variables-p-supplied-p (myformat nil " :injective-variables-p ~S" (transform-s-expr injective-variables-p)))
      (when forward-rule-consequence-p-supplied-p (myformat nil " :forward-rule-consequence-p ~S" (transform-s-expr forward-rule-consequence-p)))
      ")" )))

   (service-request req-string))))

(defun materialize-inferences ( kb-name &key  (db nil db-supplied-p) (directory nil directory-supplied-p) (index-p nil index-p-supplied-p) (abox-told-only-p nil abox-told-only-p-supplied-p) (abox nil abox-supplied-p) (tbox nil tbox-supplied-p) (if-exists nil if-exists-supplied-p) (if-does-not-exist nil if-does-not-exist-supplied-p) (all-different-p nil all-different-p-supplied-p) (same-individual-as nil same-individual-as-supplied-p) (role-fillers nil role-fillers-supplied-p) (told-datatype-fillers nil told-datatype-fillers-supplied-p) (subgraph-markers nil subgraph-markers-supplied-p) (rename-individuals nil rename-individuals-supplied-p) (in-case-individuals-are-renamed-keep-originals nil in-case-individuals-are-renamed-keep-originals-supplied-p) (data-version-level nil data-version-level-supplied-p))
 (declare (ignorable  db directory index-p abox-told-only-p abox tbox if-exists if-does-not-exist all-different-p same-individual-as role-fillers told-datatype-fillers subgraph-markers rename-individuals in-case-individuals-are-renamed-keep-originals data-version-level kb-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "materialize-inferences"
      (myformat nil " ~S" (transform-s-expr kb-name))
      (when db-supplied-p (myformat nil " :db ~S" (transform-s-expr db)))
      (when directory-supplied-p (myformat nil " :directory ~S" (transform-s-expr directory)))
      (when index-p-supplied-p (myformat nil " :index-p ~S" (transform-s-expr index-p)))
      (when abox-told-only-p-supplied-p (myformat nil " :abox-told-only-p ~S" (transform-s-expr abox-told-only-p)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when if-exists-supplied-p (myformat nil " :if-exists ~S" (transform-s-expr if-exists)))
      (when if-does-not-exist-supplied-p (myformat nil " :if-does-not-exist ~S" (transform-s-expr if-does-not-exist)))
      (when all-different-p-supplied-p (myformat nil " :all-different-p ~S" (transform-s-expr all-different-p)))
      (when same-individual-as-supplied-p (myformat nil " :same-individual-as ~S" (transform-s-expr same-individual-as)))
      (when role-fillers-supplied-p (myformat nil " :role-fillers ~S" (transform-s-expr role-fillers)))
      (when told-datatype-fillers-supplied-p (myformat nil " :told-datatype-fillers ~S" (transform-s-expr told-datatype-fillers)))
      (when subgraph-markers-supplied-p (myformat nil " :subgraph-markers ~S" (transform-s-expr subgraph-markers)))
      (when rename-individuals-supplied-p (myformat nil " :rename-individuals ~S" (transform-s-expr rename-individuals)))
      (when in-case-individuals-are-renamed-keep-originals-supplied-p (myformat nil " :in-case-individuals-are-renamed-keep-originals ~S" (transform-s-expr in-case-individuals-are-renamed-keep-originals)))
      (when data-version-level-supplied-p (myformat nil " :data-version-level ~S" (transform-s-expr data-version-level)))
      ")" )))

   (service-request req-string))))

(defun mirror ( url-spec1 url-or-filename)
 (declare (ignorable  url-spec1 url-or-filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "mirror"
      (myformat nil " ~S" (transform-s-expr url-spec1))
      (myformat nil " ~S" (transform-s-expr url-or-filename))
      ")" )))

   (service-request req-string))))

(defun most-specific-instantiators ( individual-name abox)
 (declare (ignorable  individual-name abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "most-specific-instantiators"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun move-rules ( from-abox to-abox &key  (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  type-of-substrate from-abox to-abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "move-rules"
      (myformat nil " ~S" (transform-s-expr from-abox))
      (myformat nil " ~S" (transform-s-expr to-abox))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun msc-k ( individual k &rest  args &key  (include-direct-types nil include-direct-types-supplied-p) (abox nil abox-supplied-p) (name nil name-supplied-p))
 (declare (ignorable  include-direct-types abox name args individual k))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "msc-k"
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr k))
      (when include-direct-types-supplied-p (myformat nil " :include-direct-types ~S" (transform-s-expr include-direct-types)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when name-supplied-p (myformat nil " :name ~S" (transform-s-expr name)))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   (service-request req-string))))

(defun next-set-of-rule-consequences-available-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "next-set-of-rule-consequences-available-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun next-tuple-available-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "next-tuple-available-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun node-description1 ( name &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "node-description1"
      (myformat nil " ~S" (transform-s-expr name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun node-label1 ( name &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "node-label1"
      (myformat nil " ~S" (transform-s-expr name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun open-triple-store ( name &key  (directory nil directory-supplied-p) (rdfs-reasoning nil rdfs-reasoning-supplied-p))
 (declare (ignorable  directory rdfs-reasoning name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "open-triple-store"
      (myformat nil " ~S" (transform-s-expr name))
      (when directory-supplied-p (myformat nil " :directory ~S" (transform-s-expr directory)))
      (when rdfs-reasoning-supplied-p (myformat nil " :rdfs-reasoning ~S" (transform-s-expr rdfs-reasoning)))
      ")" )))

   (service-request req-string))))

(defun optimizer-dont-ensure-late-lambda-evaluation ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "optimizer-dont-ensure-late-lambda-evaluation"
      ")" )))

   (service-request req-string))))

(defun optimizer-dont-use-cardinality-heuristics ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "optimizer-dont-use-cardinality-heuristics"
      ")" )))

   (service-request req-string))))

(defun optimizer-ensure-late-lambda-evaluation ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "optimizer-ensure-late-lambda-evaluation"
      ")" )))

   (service-request req-string))))

(defun optimizer-get-no-of-plans-upper-bound ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "optimizer-get-no-of-plans-upper-bound"
      ")" )))

   (service-request req-string))))

(defun optimizer-get-time-bound ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "optimizer-get-time-bound"
      ")" )))

   (service-request req-string))))

(defun optimizer-set-no-of-plans-upper-bound ( n)
 (declare (ignorable  n))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "optimizer-set-no-of-plans-upper-bound"
      (myformat nil " ~S" (transform-s-expr n))
      ")" )))

   (service-request req-string))))

(defun optimizer-set-time-bound ( n)
 (declare (ignorable  n))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "optimizer-set-time-bound"
      (myformat nil " ~S" (transform-s-expr n))
      ")" )))

   (service-request req-string))))

(defun optimizer-use-cardinality-heuristics ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "optimizer-use-cardinality-heuristics"
      ")" )))

   (service-request req-string))))

(defun original-query-body ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "original-query-body"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun original-query-head ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "original-query-head"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun original-rule-antecedence ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "original-rule-antecedence"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun original-rule-consequence ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "original-rule-consequence"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun owl-read-document ( url-spec &rest  args &key  (verbose nil verbose-supplied-p) (init nil init-supplied-p) (kb-name nil kb-name-supplied-p) (locator nil locator-supplied-p) (recursive nil recursive-supplied-p) (ignore-import nil ignore-import-supplied-p) (ontology-name nil ontology-name-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p) (import-meta-ontologies nil import-meta-ontologies-supplied-p) (excluded-meta-ontologies nil excluded-meta-ontologies-supplied-p) (fire-rules nil fire-rules-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p))
 (declare (ignorable  verbose init kb-name locator recursive ignore-import ontology-name merge-imported-ontologies-p import-meta-ontologies excluded-meta-ontologies fire-rules maintain-owlapi-axioms ignore-annotations args url-spec))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owl-read-document"
      (myformat nil " ~S" (transform-s-expr url-spec))
      (when verbose-supplied-p (myformat nil " :verbose ~S" (transform-s-expr verbose)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when locator-supplied-p (myformat nil " :locator ~S" (transform-s-expr locator)))
      (when recursive-supplied-p (myformat nil " :recursive ~S" (transform-s-expr recursive)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      (when import-meta-ontologies-supplied-p (myformat nil " :import-meta-ontologies ~S" (transform-s-expr import-meta-ontologies)))
      (when excluded-meta-ontologies-supplied-p (myformat nil " :excluded-meta-ontologies ~S" (transform-s-expr excluded-meta-ontologies)))
      (when fire-rules-supplied-p (myformat nil " :fire-rules ~S" (transform-s-expr fire-rules)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   (service-request req-string))))

(defun owl-read-file ( filename &key  (verbose nil verbose-supplied-p) (init nil init-supplied-p) (kb-name nil kb-name-supplied-p) (locator nil locator-supplied-p) (recursive nil recursive-supplied-p) (ignore-import nil ignore-import-supplied-p) (import-meta-ontologies nil import-meta-ontologies-supplied-p) (excluded-meta-ontologies nil excluded-meta-ontologies-supplied-p) (fire-rules nil fire-rules-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p) (ontology-name nil ontology-name-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p))
 (declare (ignorable  verbose init kb-name locator recursive ignore-import import-meta-ontologies excluded-meta-ontologies fire-rules maintain-owlapi-axioms ignore-annotations ontology-name merge-imported-ontologies-p filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owl-read-file"
      (myformat nil " ~S" (transform-s-expr filename))
      (when verbose-supplied-p (myformat nil " :verbose ~S" (transform-s-expr verbose)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when locator-supplied-p (myformat nil " :locator ~S" (transform-s-expr locator)))
      (when recursive-supplied-p (myformat nil " :recursive ~S" (transform-s-expr recursive)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when import-meta-ontologies-supplied-p (myformat nil " :import-meta-ontologies ~S" (transform-s-expr import-meta-ontologies)))
      (when excluded-meta-ontologies-supplied-p (myformat nil " :excluded-meta-ontologies ~S" (transform-s-expr excluded-meta-ontologies)))
      (when fire-rules-supplied-p (myformat nil " :fire-rules ~S" (transform-s-expr fire-rules)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-abort| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-abort|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-abort ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-abort"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-add-axiom ( ont axiom &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axiom))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-add-axiom"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axiom))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-add-axioms ( ont axioms &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axioms))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-add-axioms"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axioms))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-add-prefix ( prefix namespace &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner prefix namespace))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-add-prefix"
      (myformat nil " ~S" (transform-s-expr prefix))
      (myformat nil " ~S" (transform-s-expr namespace))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-addAxiom| ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-addAxiom|"
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-AddAxiom| ( ont axiom &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axiom))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-AddAxiom|"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axiom))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-addAxioms| ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-addAxioms|"
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-AddAxioms| ( ont axioms &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axioms))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-AddAxioms|"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axioms))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-addPrefix| ( prefix namespace &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner prefix namespace))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-addPrefix|"
      (myformat nil " ~S" (transform-s-expr prefix))
      (myformat nil " ~S" (transform-s-expr namespace))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-advance-progress ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-advance-progress"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-advanceProgress| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-advanceProgress|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-apply-changes ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-apply-changes"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-applyChanges| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-applyChanges|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-auto-add-axioms-to ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-auto-add-axioms-to"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-auto-apply-changes ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-auto-apply-changes"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-auto-batch-add-axioms-to ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-auto-batch-add-axioms-to"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-auto-batch-remove-axioms-from ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-auto-batch-remove-axioms-from"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-auto-remove-axioms-from ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-auto-remove-axioms-from"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-autoAddAxiomsTo| ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-autoAddAxiomsTo|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-autoApplyChanges| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-autoApplyChanges|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-autoBatchAddAxiomsTo| ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-autoBatchAddAxiomsTo|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-autoBatchRemoveAxiomsFrom| ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-autoBatchRemoveAxiomsFrom|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-autoRemoveAxiomsFrom| ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-autoRemoveAxiomsFrom|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-axiom-loaded? ( id &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner id))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-axiom-loaded?"
      (myformat nil " ~S" (transform-s-expr id))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-axiom-to-id ( axiom-constructor-call &optional  (reasoner nil reasoner-supplied-p) (ont nil ont-supplied-p))
 (declare (ignorable  reasoner ont axiom-constructor-call))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-axiom-to-id"
      (myformat nil " ~S" (transform-s-expr axiom-constructor-call))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when ont-supplied-p (myformat nil " ~S" (transform-s-expr ont)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-AxiomLoaded?| ( id &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner id))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-AxiomLoaded?|"
      (myformat nil " ~S" (transform-s-expr id))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-AxiomToID| ( axiom-constructor-call &optional  (reasoner nil reasoner-supplied-p) (ont nil ont-supplied-p))
 (declare (ignorable  reasoner ont axiom-constructor-call))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-AxiomToID|"
      (myformat nil " ~S" (transform-s-expr axiom-constructor-call))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when ont-supplied-p (myformat nil " ~S" (transform-s-expr ont)))
      ")" )))

   (service-request req-string))))

(defun owlapi-batch-synchronize ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-batch-synchronize"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-batchSynchronize| ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-batchSynchronize|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-classify| ( &optional  (reasoner nil reasoner-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p))
 (declare (ignorable  reasoner check-abox-consistency-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-classify|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when check-abox-consistency-p-supplied-p (myformat nil " ~S" (transform-s-expr check-abox-consistency-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-classify ( &optional  (reasoner nil reasoner-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p))
 (declare (ignorable  reasoner check-abox-consistency-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-classify"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when check-abox-consistency-p-supplied-p (myformat nil " ~S" (transform-s-expr check-abox-consistency-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-clear-changes ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-clear-changes"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-clear-ontologies ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-clear-ontologies"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-clear-registry ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-clear-registry"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-clearChanges| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-clearChanges|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-clearOntologies| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-clearOntologies|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-clearRegistry| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-clearRegistry|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-consider-declarations ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-consider-declarations"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-considerDeclarations| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-considerDeclarations|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-contains| ( ont-name &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-contains|"
      (myformat nil " ~S" (transform-s-expr ont-name))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-contains ( ont-name &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-contains"
      (myformat nil " ~S" (transform-s-expr ont-name))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-describe-ontologies ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-describe-ontologies"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-describe-ontology ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-describe-ontology"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-describe-reasoner ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-describe-reasoner"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-describe-reasoners ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-describe-reasoners"
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-describeOntologies| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-describeOntologies|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-describeOntology| ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-describeOntology|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-describeReasoner| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-describeReasoner|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-describeReasoners| ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-describeReasoners|"
      ")" )))

   (service-request req-string))))

(defun owlapi-disable-auto-mode ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-disable-auto-mode"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-disable-incremental-updates ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-disable-incremental-updates"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-disable-lookup-mode ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-disable-lookup-mode"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-disable-memory-saving-mode ( reasoner)
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-disable-memory-saving-mode"
      (myformat nil " ~S" (transform-s-expr reasoner))
      ")" )))

   (service-request req-string))))

(defun owlapi-disable-simplified-protocol ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-disable-simplified-protocol"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-disable-transient-axiom-mode ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-disable-transient-axiom-mode"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-disableAutoMode| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-disableAutoMode|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-disableIncrementalUpdates| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-disableIncrementalUpdates|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-disableLookupMode| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-disableLookupMode|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-disableMemorySavingMode| ( reasoner)
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-disableMemorySavingMode|"
      (myformat nil " ~S" (transform-s-expr reasoner))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-disableSimplifiedProtocol| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-disableSimplifiedProtocol|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-disableTransientAxiomMode| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-disableTransientAxiomMode|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-dispose| ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-dispose|"
      ")" )))

   (service-request req-string))))

(defun owlapi-dispose ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-dispose"
      ")" )))

   (service-request req-string))))

(defun owlapi-dispose-axiom ( id-or-constructor &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner id-or-constructor))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-dispose-axiom"
      (myformat nil " ~S" (transform-s-expr id-or-constructor))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-dispose-axioms ( ids-or-constructors &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ids-or-constructors))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-dispose-axioms"
      (myformat nil " ~S" (transform-s-expr ids-or-constructors))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-dispose-ontologies ( ontologies &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontologies))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-dispose-ontologies"
      (myformat nil " ~S" (transform-s-expr ontologies))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-dispose-ontology ( ont-name &optional  (reasoner nil reasoner-supplied-p) (dispose-axioms-p nil dispose-axioms-p-supplied-p))
 (declare (ignorable  reasoner dispose-axioms-p ont-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-dispose-ontology"
      (myformat nil " ~S" (transform-s-expr ont-name))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when dispose-axioms-p-supplied-p (myformat nil " ~S" (transform-s-expr dispose-axioms-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-dispose-reasoner ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-dispose-reasoner"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-disposeAxiom| ( id-or-constructor &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner id-or-constructor))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-disposeAxiom|"
      (myformat nil " ~S" (transform-s-expr id-or-constructor))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-disposeAxioms| ( ids-or-constructors &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ids-or-constructors))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-disposeAxioms|"
      (myformat nil " ~S" (transform-s-expr ids-or-constructors))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-disposeOntologies| ( ontologies &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontologies))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-disposeOntologies|"
      (myformat nil " ~S" (transform-s-expr ontologies))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-disposeOntology| ( ont-name &optional  (reasoner nil reasoner-supplied-p) (dispose-axioms-p nil dispose-axioms-p-supplied-p))
 (declare (ignorable  reasoner dispose-axioms-p ont-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-disposeOntology|"
      (myformat nil " ~S" (transform-s-expr ont-name))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when dispose-axioms-p-supplied-p (myformat nil " ~S" (transform-s-expr dispose-axioms-p)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-disposeReasoner| ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-disposeReasoner|"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   (service-request req-string))))

(defun owlapi-dont-register-declared-entities ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-dont-register-declared-entities"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-dont-register-referenced-entities ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-dont-register-referenced-entities"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-dontRegisterDeclaredEntities| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-dontRegisterDeclaredEntities|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-dontRegisterReferencedEntities| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-dontRegisterReferencedEntities|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-enable-incremental-updates ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-enable-incremental-updates"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-enable-lookup-mode ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-enable-lookup-mode"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-enable-memory-saving-mode ( ontology &optional  (reasoner nil reasoner-supplied-p) (use-less-tbox-memory-p nil use-less-tbox-memory-p-supplied-p))
 (declare (ignorable  reasoner use-less-tbox-memory-p ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-enable-memory-saving-mode"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when use-less-tbox-memory-p-supplied-p (myformat nil " ~S" (transform-s-expr use-less-tbox-memory-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-enable-simplified-protocol ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-enable-simplified-protocol"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-enable-transient-axiom-mode ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-enable-transient-axiom-mode"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-enableIncrementalUpdates| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-enableIncrementalUpdates|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-enableLookupMode| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-enableLookupMode|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-enableMemorySavingMode| ( ontology &optional  (reasoner nil reasoner-supplied-p) (use-less-tbox-memory-p nil use-less-tbox-memory-p-supplied-p))
 (declare (ignorable  reasoner use-less-tbox-memory-p ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-enableMemorySavingMode|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when use-less-tbox-memory-p-supplied-p (myformat nil " ~S" (transform-s-expr use-less-tbox-memory-p)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-enableSimplifiedProtocol| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-enableSimplifiedProtocol|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-enableTransientAxiomMode| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-enableTransientAxiomMode|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-export-ontology ( ontology fn &key  (reasoner nil reasoner-supplied-p) (syntax nil syntax-supplied-p) (quoted nil quoted-supplied-p) (init nil init-supplied-p) (header nil header-supplied-p))
 (declare (ignorable  reasoner syntax quoted init header ontology fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-export-ontology"
      (myformat nil " ~S" (transform-s-expr ontology))
      (myformat nil " ~S" (transform-s-expr fn))
      (when reasoner-supplied-p (myformat nil " :reasoner ~S" (transform-s-expr reasoner)))
      (when syntax-supplied-p (myformat nil " :syntax ~S" (transform-s-expr syntax)))
      (when quoted-supplied-p (myformat nil " :quoted ~S" (transform-s-expr quoted)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when header-supplied-p (myformat nil " :header ~S" (transform-s-expr header)))
      ")" )))

   (service-request req-string))))

(defun owlapi-export-reasoner ( reasoner fn &key  (syntax nil syntax-supplied-p) (quoted nil quoted-supplied-p) (init nil init-supplied-p))
 (declare (ignorable  syntax quoted init reasoner fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-export-reasoner"
      (myformat nil " ~S" (transform-s-expr reasoner))
      (myformat nil " ~S" (transform-s-expr fn))
      (when syntax-supplied-p (myformat nil " :syntax ~S" (transform-s-expr syntax)))
      (when quoted-supplied-p (myformat nil " :quoted ~S" (transform-s-expr quoted)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-exportOntology| ( ontology fn &key  (reasoner nil reasoner-supplied-p) (syntax nil syntax-supplied-p) (quoted nil quoted-supplied-p) (init nil init-supplied-p) (header nil header-supplied-p))
 (declare (ignorable  reasoner syntax quoted init header ontology fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-exportOntology|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (myformat nil " ~S" (transform-s-expr fn))
      (when reasoner-supplied-p (myformat nil " :reasoner ~S" (transform-s-expr reasoner)))
      (when syntax-supplied-p (myformat nil " :syntax ~S" (transform-s-expr syntax)))
      (when quoted-supplied-p (myformat nil " :quoted ~S" (transform-s-expr quoted)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when header-supplied-p (myformat nil " :header ~S" (transform-s-expr header)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-exportReasoner| ( reasoner fn &key  (syntax nil syntax-supplied-p) (quoted nil quoted-supplied-p) (init nil init-supplied-p))
 (declare (ignorable  syntax quoted init reasoner fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-exportReasoner|"
      (myformat nil " ~S" (transform-s-expr reasoner))
      (myformat nil " ~S" (transform-s-expr fn))
      (when syntax-supplied-p (myformat nil " :syntax ~S" (transform-s-expr syntax)))
      (when quoted-supplied-p (myformat nil " :quoted ~S" (transform-s-expr quoted)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      ")" )))

   (service-request req-string))))

(defun owlapi-find-id-from-object ( obj)
 (declare (ignorable  obj))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-find-id-from-object"
      (myformat nil " ~S" (transform-s-expr obj))
      ")" )))

   (service-request req-string))))

(defun owlapi-find-object-from-id ( id)
 (declare (ignorable  id))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-find-object-from-id"
      (myformat nil " ~S" (transform-s-expr id))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-findIDFromObject| ( obj)
 (declare (ignorable  obj))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-findIDFromObject|"
      (myformat nil " ~S" (transform-s-expr obj))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-findObjectFromID| ( id)
 (declare (ignorable  id))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-findObjectFromID|"
      (myformat nil " ~S" (transform-s-expr id))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-all-ontologies ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-all-ontologies"
      ")" )))

   (service-request req-string))))

(defun owlapi-get-ancestor-classes ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-ancestor-classes"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-ancestor-properties ( property &optional  (reasoner nil reasoner-supplied-p) (remove-self-p nil remove-self-p-supplied-p))
 (declare (ignorable  reasoner remove-self-p property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-ancestor-properties"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when remove-self-p-supplied-p (myformat nil " ~S" (transform-s-expr remove-self-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-annotation-axioms-for-axiom ( axiom-id &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner axiom-id))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-annotation-axioms-for-axiom"
      (myformat nil " ~S" (transform-s-expr axiom-id))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-auto-declare-data-properties ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-auto-declare-data-properties"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-auto-ontology ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-auto-ontology"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-axiom-counter ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-axiom-counter"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-axioms ( &optional  (reasoner nil reasoner-supplied-p) (with-ids-p nil with-ids-p-supplied-p) (with-ont-names-p nil with-ont-names-p-supplied-p) (status nil status-supplied-p))
 (declare (ignorable  reasoner with-ids-p with-ont-names-p status))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-axioms"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when with-ids-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ids-p)))
      (when with-ont-names-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ont-names-p)))
      (when status-supplied-p (myformat nil " ~S" (transform-s-expr status)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-axioms-in ( ont &optional  (reasoner nil reasoner-supplied-p) (with-ids-p nil with-ids-p-supplied-p) (status nil status-supplied-p))
 (declare (ignorable  reasoner with-ids-p status ont))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-axioms-in"
      (myformat nil " ~S" (transform-s-expr ont))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when with-ids-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ids-p)))
      (when status-supplied-p (myformat nil " ~S" (transform-s-expr status)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-axioms-of-type ( type-or-types &optional  (reasoner nil reasoner-supplied-p) (with-ids-p nil with-ids-p-supplied-p) (with-ont-names-p nil with-ont-names-p-supplied-p) (status nil status-supplied-p))
 (declare (ignorable  reasoner with-ids-p with-ont-names-p status type-or-types))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-axioms-of-type"
      (myformat nil " ~S" (transform-s-expr type-or-types))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when with-ids-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ids-p)))
      (when with-ont-names-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ont-names-p)))
      (when status-supplied-p (myformat nil " ~S" (transform-s-expr status)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-axioms-of-type-in ( type-or-types ont &optional  (reasoner nil reasoner-supplied-p) (with-ids-p nil with-ids-p-supplied-p) (status nil status-supplied-p))
 (declare (ignorable  reasoner with-ids-p status type-or-types ont))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-axioms-of-type-in"
      (myformat nil " ~S" (transform-s-expr type-or-types))
      (myformat nil " ~S" (transform-s-expr ont))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when with-ids-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ids-p)))
      (when status-supplied-p (myformat nil " ~S" (transform-s-expr status)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-axioms-per-ontology ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-axioms-per-ontology"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-changes ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-changes"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-current-reasoner ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-current-reasoner"
      ")" )))

   (service-request req-string))))

(defun owlapi-get-data-property-relationships ( ind &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-data-property-relationships"
      (myformat nil " ~S" (transform-s-expr ind))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-data-property-values ( ind property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-data-property-values"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-descendant-classes ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-descendant-classes"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-descendant-properties ( property &optional  (reasoner nil reasoner-supplied-p) (remove-self-p nil remove-self-p-supplied-p))
 (declare (ignorable  reasoner remove-self-p property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-descendant-properties"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when remove-self-p-supplied-p (myformat nil " ~S" (transform-s-expr remove-self-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-different-individuals ( ind &optional  (reasoner nil reasoner-supplied-p) (synonyms nil synonyms-supplied-p))
 (declare (ignorable  reasoner synonyms ind))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-different-individuals"
      (myformat nil " ~S" (transform-s-expr ind))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when synonyms-supplied-p (myformat nil " ~S" (transform-s-expr synonyms)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-disjoint-classes ( concept &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-disjoint-classes"
      (myformat nil " ~S" (transform-s-expr concept))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-disjoint-data-properties ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-disjoint-data-properties"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-disjoint-object-properties ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-disjoint-object-properties"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-domains ( property &optional  (reasoner nil reasoner-supplied-p) (owlapi-hacking-mode nil owlapi-hacking-mode-supplied-p))
 (declare (ignorable  reasoner owlapi-hacking-mode property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-domains"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when owlapi-hacking-mode-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-hacking-mode)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-equivalent-classes ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-equivalent-classes"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-equivalent-properties ( property &optional  (reasoner nil reasoner-supplied-p) (remove-self-p nil remove-self-p-supplied-p))
 (declare (ignorable  reasoner remove-self-p property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-equivalent-properties"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when remove-self-p-supplied-p (myformat nil " ~S" (transform-s-expr remove-self-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-inconsistent-classes ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-inconsistent-classes"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-individuals ( class direct &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner class direct))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-individuals"
      (myformat nil " ~S" (transform-s-expr class))
      (myformat nil " ~S" (transform-s-expr direct))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-instances ( class direct &optional  (reasoner nil reasoner-supplied-p) (synonyms nil synonyms-supplied-p))
 (declare (ignorable  reasoner synonyms class direct))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-instances"
      (myformat nil " ~S" (transform-s-expr class))
      (myformat nil " ~S" (transform-s-expr direct))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when synonyms-supplied-p (myformat nil " ~S" (transform-s-expr synonyms)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-inverse-properties ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-inverse-properties"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-loaded-ontologies ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-loaded-ontologies"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-object-property-relationships ( ind &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-object-property-relationships"
      (myformat nil " ~S" (transform-s-expr ind))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-object-property-values ( ind property &optional  (reasoner nil reasoner-supplied-p) (synonyms nil synonyms-supplied-p))
 (declare (ignorable  reasoner synonyms ind property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-object-property-values"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when synonyms-supplied-p (myformat nil " ~S" (transform-s-expr synonyms)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-ontologies ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-ontologies"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-annotation-assertion-axiom ( annotation-subject annotation-property annotation-value &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner annotation-subject annotation-property annotation-value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-annotation-assertion-axiom"
      (myformat nil " ~S" (transform-s-expr annotation-subject))
      (myformat nil " ~S" (transform-s-expr annotation-property))
      (myformat nil " ~S" (transform-s-expr annotation-value))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-annotation-property-domain-axiom ( annotation-property annotation-property-domain &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner annotation-property annotation-property-domain))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-annotation-property-domain-axiom"
      (myformat nil " ~S" (transform-s-expr annotation-property))
      (myformat nil " ~S" (transform-s-expr annotation-property-domain))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-annotation-property-range-axiom ( annotation-property annotation-property-range &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner annotation-property annotation-property-range))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-annotation-property-range-axiom"
      (myformat nil " ~S" (transform-s-expr annotation-property))
      (myformat nil " ~S" (transform-s-expr annotation-property-range))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-asymmetric-object-property-axiom ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-asymmetric-object-property-axiom"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-axiom-annotation-axiom ( axiom-id annotation &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner axiom-id annotation))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-axiom-annotation-axiom"
      (myformat nil " ~S" (transform-s-expr axiom-id))
      (myformat nil " ~S" (transform-s-expr annotation))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-class-assertion-axiom ( individual description &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner individual description))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-class-assertion-axiom"
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr description))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-data-property-assertion-axiom ( subject rel-data-property value &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject rel-data-property value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-data-property-assertion-axiom"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr rel-data-property))
      (myformat nil " ~S" (transform-s-expr value))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-data-property-domain-axiom ( data-property data-property-domain &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-property data-property-domain))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-data-property-domain-axiom"
      (myformat nil " ~S" (transform-s-expr data-property))
      (myformat nil " ~S" (transform-s-expr data-property-domain))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-data-property-range-axiom ( data-property data-range &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-property data-range))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-data-property-range-axiom"
      (myformat nil " ~S" (transform-s-expr data-property))
      (myformat nil " ~S" (transform-s-expr data-range))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-data-sub-property-axiom ( data-sub-property data-super-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-sub-property data-super-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-data-sub-property-axiom"
      (myformat nil " ~S" (transform-s-expr data-sub-property))
      (myformat nil " ~S" (transform-s-expr data-super-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-datatype-definition-axiom ( datatype-name data-range &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner datatype-name data-range))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-datatype-definition-axiom"
      (myformat nil " ~S" (transform-s-expr datatype-name))
      (myformat nil " ~S" (transform-s-expr data-range))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-declaration-axiom ( entity &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner entity))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-declaration-axiom"
      (myformat nil " ~S" (transform-s-expr entity))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-different-individuals-axiom ( individuals &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner individuals))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-different-individuals-axiom"
      (myformat nil " ~S" (transform-s-expr individuals))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-disjoint-classes-axiom ( descriptions &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner descriptions))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-disjoint-classes-axiom"
      (myformat nil " ~S" (transform-s-expr descriptions))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-disjoint-data-properties-axiom ( data-properties &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-properties))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-disjoint-data-properties-axiom"
      (myformat nil " ~S" (transform-s-expr data-properties))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-disjoint-object-properties-axiom ( object-properties &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-properties))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-disjoint-object-properties-axiom"
      (myformat nil " ~S" (transform-s-expr object-properties))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-disjoint-union-axiom ( description descriptions &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner description descriptions))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-disjoint-union-axiom"
      (myformat nil " ~S" (transform-s-expr description))
      (myformat nil " ~S" (transform-s-expr descriptions))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-entity-annotation-axiom ( entity annotation &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner entity annotation))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-entity-annotation-axiom"
      (myformat nil " ~S" (transform-s-expr entity))
      (myformat nil " ~S" (transform-s-expr annotation))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-equivalent-classes-axiom ( descriptions &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner descriptions))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-equivalent-classes-axiom"
      (myformat nil " ~S" (transform-s-expr descriptions))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-equivalent-data-properties-axiom ( data-properties &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-properties))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-equivalent-data-properties-axiom"
      (myformat nil " ~S" (transform-s-expr data-properties))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-equivalent-object-properties-axiom ( object-properties &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-properties))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-equivalent-object-properties-axiom"
      (myformat nil " ~S" (transform-s-expr object-properties))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-functional-data-property-axiom ( data-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-functional-data-property-axiom"
      (myformat nil " ~S" (transform-s-expr data-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-functional-object-property-axiom ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-functional-object-property-axiom"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-has-key-axiom ( key-class key-object-properties key-data-properties &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner key-class key-object-properties key-data-properties))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-has-key-axiom"
      (myformat nil " ~S" (transform-s-expr key-class))
      (myformat nil " ~S" (transform-s-expr key-object-properties))
      (myformat nil " ~S" (transform-s-expr key-data-properties))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-implicit-declaration-axiom ( entity &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner entity))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-implicit-declaration-axiom"
      (myformat nil " ~S" (transform-s-expr entity))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-imports-declaration-axiom ( ontology-import-uri &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology-import-uri))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-imports-declaration-axiom"
      (myformat nil " ~S" (transform-s-expr ontology-import-uri))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-inverse-functional-object-property-axiom ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-inverse-functional-object-property-axiom"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-inverse-object-properties-axiom ( first-object-property second-object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner first-object-property second-object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-inverse-object-properties-axiom"
      (myformat nil " ~S" (transform-s-expr first-object-property))
      (myformat nil " ~S" (transform-s-expr second-object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-irreflexive-object-property-axiom ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-irreflexive-object-property-axiom"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-negative-data-property-assertion-axiom ( subject rel-data-property value &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject rel-data-property value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-negative-data-property-assertion-axiom"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr rel-data-property))
      (myformat nil " ~S" (transform-s-expr value))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-negative-object-property-assertion-axiom ( subject rel-object-property object &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject rel-object-property object))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-negative-object-property-assertion-axiom"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr rel-object-property))
      (myformat nil " ~S" (transform-s-expr object))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-object-property-assertion-axiom ( subject rel-object-property object &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject rel-object-property object))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-object-property-assertion-axiom"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr rel-object-property))
      (myformat nil " ~S" (transform-s-expr object))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-object-property-chain-sub-property-axiom ( object-property-chain object-super-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property-chain object-super-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-object-property-chain-sub-property-axiom"
      (myformat nil " ~S" (transform-s-expr object-property-chain))
      (myformat nil " ~S" (transform-s-expr object-super-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-object-property-domain-axiom ( object-property object-property-domain &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property object-property-domain))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-object-property-domain-axiom"
      (myformat nil " ~S" (transform-s-expr object-property))
      (myformat nil " ~S" (transform-s-expr object-property-domain))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-object-property-range-axiom ( object-property object-property-range &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property object-property-range))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-object-property-range-axiom"
      (myformat nil " ~S" (transform-s-expr object-property))
      (myformat nil " ~S" (transform-s-expr object-property-range))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-object-sub-property-axiom ( object-sub-property object-super-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-sub-property object-super-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-object-sub-property-axiom"
      (myformat nil " ~S" (transform-s-expr object-sub-property))
      (myformat nil " ~S" (transform-s-expr object-super-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-ontology-annotation-axiom ( annotation &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner annotation))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-ontology-annotation-axiom"
      (myformat nil " ~S" (transform-s-expr annotation))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-ontology-version-declaration-axiom ( ontology-version-uri &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology-version-uri))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-ontology-version-declaration-axiom"
      (myformat nil " ~S" (transform-s-expr ontology-version-uri))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-prefix-declaration-axiom ( namespace-prefix namespace &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner namespace-prefix namespace))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-prefix-declaration-axiom"
      (myformat nil " ~S" (transform-s-expr namespace-prefix))
      (myformat nil " ~S" (transform-s-expr namespace))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-really-implicit-declaration-axiom ( entity &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner entity))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-really-implicit-declaration-axiom"
      (myformat nil " ~S" (transform-s-expr entity))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-reflexive-object-property-axiom ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-reflexive-object-property-axiom"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-same-individuals-axiom ( individuals &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner individuals))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-same-individuals-axiom"
      (myformat nil " ~S" (transform-s-expr individuals))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-sub-annotation-property-axiom ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-sub-annotation-property-axiom"
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-sub-annotation-property-of-axiom ( annotation-sub-property annotation-super-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner annotation-sub-property annotation-super-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-sub-annotation-property-of-axiom"
      (myformat nil " ~S" (transform-s-expr annotation-sub-property))
      (myformat nil " ~S" (transform-s-expr annotation-super-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-sub-class-axiom ( sub-class super-class &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner sub-class super-class))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-sub-class-axiom"
      (myformat nil " ~S" (transform-s-expr sub-class))
      (myformat nil " ~S" (transform-s-expr super-class))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-symmetric-object-property-axiom ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-symmetric-object-property-axiom"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-owl-transitive-object-property-axiom ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-owl-transitive-object-property-axiom"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-prefixes ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-prefixes"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-ranges ( property &optional  (reasoner nil reasoner-supplied-p) (owlapi-hacking-mode nil owlapi-hacking-mode-supplied-p))
 (declare (ignorable  reasoner owlapi-hacking-mode property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-ranges"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when owlapi-hacking-mode-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-hacking-mode)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-reasoners ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-reasoners"
      ")" )))

   (service-request req-string))))

(defun owlapi-get-related-individuals ( subject object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-related-individuals"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-related-values ( subject data-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject data-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-related-values"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr data-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-same-individuals ( ind &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-same-individuals"
      (myformat nil " ~S" (transform-s-expr ind))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-sub-classes ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-sub-classes"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-sub-properties ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-sub-properties"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-super-classes ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-super-classes"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-super-properties ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-super-properties"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-get-types ( individual direct &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner individual direct))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-get-types"
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr direct))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAllOntologies| ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAllOntologies|"
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAncestorClasses| ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAncestorClasses|"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAncestorProperties| ( property &optional  (reasoner nil reasoner-supplied-p) (remove-self-p nil remove-self-p-supplied-p))
 (declare (ignorable  reasoner remove-self-p property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAncestorProperties|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when remove-self-p-supplied-p (myformat nil " ~S" (transform-s-expr remove-self-p)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAnnotationAxiomsForAxiom| ( axiom-id &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner axiom-id))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAnnotationAxiomsForAxiom|"
      (myformat nil " ~S" (transform-s-expr axiom-id))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAutoDeclareDataProperties| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAutoDeclareDataProperties|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAutoOntology| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAutoOntology|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAxiomCounter| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAxiomCounter|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAxioms| ( &optional  (reasoner nil reasoner-supplied-p) (with-ids-p nil with-ids-p-supplied-p) (with-ont-names-p nil with-ont-names-p-supplied-p) (status nil status-supplied-p))
 (declare (ignorable  reasoner with-ids-p with-ont-names-p status))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAxioms|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when with-ids-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ids-p)))
      (when with-ont-names-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ont-names-p)))
      (when status-supplied-p (myformat nil " ~S" (transform-s-expr status)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAxiomsIn| ( ont &optional  (reasoner nil reasoner-supplied-p) (with-ids-p nil with-ids-p-supplied-p) (status nil status-supplied-p))
 (declare (ignorable  reasoner with-ids-p status ont))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAxiomsIn|"
      (myformat nil " ~S" (transform-s-expr ont))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when with-ids-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ids-p)))
      (when status-supplied-p (myformat nil " ~S" (transform-s-expr status)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAxiomsOfType| ( type-or-types &optional  (reasoner nil reasoner-supplied-p) (with-ids-p nil with-ids-p-supplied-p) (with-ont-names-p nil with-ont-names-p-supplied-p) (status nil status-supplied-p))
 (declare (ignorable  reasoner with-ids-p with-ont-names-p status type-or-types))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAxiomsOfType|"
      (myformat nil " ~S" (transform-s-expr type-or-types))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when with-ids-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ids-p)))
      (when with-ont-names-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ont-names-p)))
      (when status-supplied-p (myformat nil " ~S" (transform-s-expr status)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAxiomsOfTypeIn| ( type-or-types ont &optional  (reasoner nil reasoner-supplied-p) (with-ids-p nil with-ids-p-supplied-p) (status nil status-supplied-p))
 (declare (ignorable  reasoner with-ids-p status type-or-types ont))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAxiomsOfTypeIn|"
      (myformat nil " ~S" (transform-s-expr type-or-types))
      (myformat nil " ~S" (transform-s-expr ont))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when with-ids-p-supplied-p (myformat nil " ~S" (transform-s-expr with-ids-p)))
      (when status-supplied-p (myformat nil " ~S" (transform-s-expr status)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getAxiomsPerOntology| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getAxiomsPerOntology|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getChanges| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getChanges|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getCurrentReasoner| ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getCurrentReasoner|"
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getDataPropertyRelationships| ( ind &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getDataPropertyRelationships|"
      (myformat nil " ~S" (transform-s-expr ind))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getDataPropertyValues| ( ind property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getDataPropertyValues|"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getDescendantClasses| ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getDescendantClasses|"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getDescendantProperties| ( property &optional  (reasoner nil reasoner-supplied-p) (remove-self-p nil remove-self-p-supplied-p))
 (declare (ignorable  reasoner remove-self-p property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getDescendantProperties|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when remove-self-p-supplied-p (myformat nil " ~S" (transform-s-expr remove-self-p)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getDifferentIndividuals| ( ind &optional  (reasoner nil reasoner-supplied-p) (synonyms nil synonyms-supplied-p))
 (declare (ignorable  reasoner synonyms ind))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getDifferentIndividuals|"
      (myformat nil " ~S" (transform-s-expr ind))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when synonyms-supplied-p (myformat nil " ~S" (transform-s-expr synonyms)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getDisjointClasses| ( concept &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getDisjointClasses|"
      (myformat nil " ~S" (transform-s-expr concept))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getDisjointDataProperties| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getDisjointDataProperties|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getDisjointObjectProperties| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getDisjointObjectProperties|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getDomains| ( property &optional  (reasoner nil reasoner-supplied-p) (owlapi-hacking-mode nil owlapi-hacking-mode-supplied-p))
 (declare (ignorable  reasoner owlapi-hacking-mode property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getDomains|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when owlapi-hacking-mode-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-hacking-mode)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getEquivalentClasses| ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getEquivalentClasses|"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getEquivalentProperties| ( property &optional  (reasoner nil reasoner-supplied-p) (remove-self-p nil remove-self-p-supplied-p))
 (declare (ignorable  reasoner remove-self-p property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getEquivalentProperties|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when remove-self-p-supplied-p (myformat nil " ~S" (transform-s-expr remove-self-p)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getInconsistentClasses| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getInconsistentClasses|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getIndividuals| ( class direct &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner class direct))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getIndividuals|"
      (myformat nil " ~S" (transform-s-expr class))
      (myformat nil " ~S" (transform-s-expr direct))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getInstances| ( class direct &optional  (reasoner nil reasoner-supplied-p) (synonyms nil synonyms-supplied-p))
 (declare (ignorable  reasoner synonyms class direct))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getInstances|"
      (myformat nil " ~S" (transform-s-expr class))
      (myformat nil " ~S" (transform-s-expr direct))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when synonyms-supplied-p (myformat nil " ~S" (transform-s-expr synonyms)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getInverseProperties| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getInverseProperties|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getLoadedOntologies| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getLoadedOntologies|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getObjectPropertyRelationships| ( ind &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getObjectPropertyRelationships|"
      (myformat nil " ~S" (transform-s-expr ind))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getObjectPropertyValues| ( ind property &optional  (reasoner nil reasoner-supplied-p) (synonyms nil synonyms-supplied-p))
 (declare (ignorable  reasoner synonyms ind property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getObjectPropertyValues|"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when synonyms-supplied-p (myformat nil " ~S" (transform-s-expr synonyms)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOntologies| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOntologies|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLAnnotationAssertionAxiom| ( annotation-subject annotation-property annotation-value &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner annotation-subject annotation-property annotation-value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLAnnotationAssertionAxiom|"
      (myformat nil " ~S" (transform-s-expr annotation-subject))
      (myformat nil " ~S" (transform-s-expr annotation-property))
      (myformat nil " ~S" (transform-s-expr annotation-value))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLAnnotationPropertyDomainAxiom| ( annotation-property annotation-property-domain &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner annotation-property annotation-property-domain))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLAnnotationPropertyDomainAxiom|"
      (myformat nil " ~S" (transform-s-expr annotation-property))
      (myformat nil " ~S" (transform-s-expr annotation-property-domain))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLAnnotationPropertyRangeAxiom| ( annotation-property annotation-property-range &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner annotation-property annotation-property-range))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLAnnotationPropertyRangeAxiom|"
      (myformat nil " ~S" (transform-s-expr annotation-property))
      (myformat nil " ~S" (transform-s-expr annotation-property-range))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLAsymmetricObjectPropertyAxiom| ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLAsymmetricObjectPropertyAxiom|"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLAxiomAnnotationAxiom| ( axiom-id annotation &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner axiom-id annotation))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLAxiomAnnotationAxiom|"
      (myformat nil " ~S" (transform-s-expr axiom-id))
      (myformat nil " ~S" (transform-s-expr annotation))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLClassAssertionAxiom| ( individual description &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner individual description))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLClassAssertionAxiom|"
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr description))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLDataPropertyAssertionAxiom| ( subject rel-data-property value &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject rel-data-property value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLDataPropertyAssertionAxiom|"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr rel-data-property))
      (myformat nil " ~S" (transform-s-expr value))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLDataPropertyDomainAxiom| ( data-property data-property-domain &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-property data-property-domain))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLDataPropertyDomainAxiom|"
      (myformat nil " ~S" (transform-s-expr data-property))
      (myformat nil " ~S" (transform-s-expr data-property-domain))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLDataPropertyRangeAxiom| ( data-property data-range &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-property data-range))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLDataPropertyRangeAxiom|"
      (myformat nil " ~S" (transform-s-expr data-property))
      (myformat nil " ~S" (transform-s-expr data-range))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLDataSubPropertyAxiom| ( data-sub-property data-super-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-sub-property data-super-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLDataSubPropertyAxiom|"
      (myformat nil " ~S" (transform-s-expr data-sub-property))
      (myformat nil " ~S" (transform-s-expr data-super-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLDatatypeDefinitionAxiom| ( datatype-name data-range &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner datatype-name data-range))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLDatatypeDefinitionAxiom|"
      (myformat nil " ~S" (transform-s-expr datatype-name))
      (myformat nil " ~S" (transform-s-expr data-range))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLDeclarationAxiom| ( entity &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner entity))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLDeclarationAxiom|"
      (myformat nil " ~S" (transform-s-expr entity))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLDifferentIndividualsAxiom| ( individuals &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner individuals))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLDifferentIndividualsAxiom|"
      (myformat nil " ~S" (transform-s-expr individuals))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLDisjointClassesAxiom| ( descriptions &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner descriptions))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLDisjointClassesAxiom|"
      (myformat nil " ~S" (transform-s-expr descriptions))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLDisjointDataPropertiesAxiom| ( data-properties &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-properties))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLDisjointDataPropertiesAxiom|"
      (myformat nil " ~S" (transform-s-expr data-properties))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLDisjointObjectPropertiesAxiom| ( object-properties &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-properties))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLDisjointObjectPropertiesAxiom|"
      (myformat nil " ~S" (transform-s-expr object-properties))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLDisjointUnionAxiom| ( description descriptions &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner description descriptions))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLDisjointUnionAxiom|"
      (myformat nil " ~S" (transform-s-expr description))
      (myformat nil " ~S" (transform-s-expr descriptions))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLEntityAnnotationAxiom| ( entity annotation &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner entity annotation))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLEntityAnnotationAxiom|"
      (myformat nil " ~S" (transform-s-expr entity))
      (myformat nil " ~S" (transform-s-expr annotation))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLEquivalentClassesAxiom| ( descriptions &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner descriptions))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLEquivalentClassesAxiom|"
      (myformat nil " ~S" (transform-s-expr descriptions))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLEquivalentDataPropertiesAxiom| ( data-properties &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-properties))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLEquivalentDataPropertiesAxiom|"
      (myformat nil " ~S" (transform-s-expr data-properties))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLEquivalentObjectPropertiesAxiom| ( object-properties &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-properties))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLEquivalentObjectPropertiesAxiom|"
      (myformat nil " ~S" (transform-s-expr object-properties))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLFunctionalDataPropertyAxiom| ( data-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner data-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLFunctionalDataPropertyAxiom|"
      (myformat nil " ~S" (transform-s-expr data-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLFunctionalObjectPropertyAxiom| ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLFunctionalObjectPropertyAxiom|"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLHasKeyAxiom| ( key-class key-object-properties key-data-properties &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner key-class key-object-properties key-data-properties))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLHasKeyAxiom|"
      (myformat nil " ~S" (transform-s-expr key-class))
      (myformat nil " ~S" (transform-s-expr key-object-properties))
      (myformat nil " ~S" (transform-s-expr key-data-properties))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLImplicitDeclarationAxiom| ( entity &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner entity))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLImplicitDeclarationAxiom|"
      (myformat nil " ~S" (transform-s-expr entity))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLImportsDeclarationAxiom| ( ontology-import-uri &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology-import-uri))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLImportsDeclarationAxiom|"
      (myformat nil " ~S" (transform-s-expr ontology-import-uri))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLInverseFunctionalObjectPropertyAxiom| ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLInverseFunctionalObjectPropertyAxiom|"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLInverseObjectPropertiesAxiom| ( first-object-property second-object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner first-object-property second-object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLInverseObjectPropertiesAxiom|"
      (myformat nil " ~S" (transform-s-expr first-object-property))
      (myformat nil " ~S" (transform-s-expr second-object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLIrreflexiveObjectPropertyAxiom| ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLIrreflexiveObjectPropertyAxiom|"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLNegativeDataPropertyAssertionAxiom| ( subject rel-data-property value &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject rel-data-property value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLNegativeDataPropertyAssertionAxiom|"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr rel-data-property))
      (myformat nil " ~S" (transform-s-expr value))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLNegativeObjectPropertyAssertionAxiom| ( subject rel-object-property object &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject rel-object-property object))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLNegativeObjectPropertyAssertionAxiom|"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr rel-object-property))
      (myformat nil " ~S" (transform-s-expr object))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLObjectPropertyAssertionAxiom| ( subject rel-object-property object &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject rel-object-property object))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLObjectPropertyAssertionAxiom|"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr rel-object-property))
      (myformat nil " ~S" (transform-s-expr object))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLObjectPropertyChainSubPropertyAxiom| ( object-property-chain object-super-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property-chain object-super-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLObjectPropertyChainSubPropertyAxiom|"
      (myformat nil " ~S" (transform-s-expr object-property-chain))
      (myformat nil " ~S" (transform-s-expr object-super-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLObjectPropertyDomainAxiom| ( object-property object-property-domain &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property object-property-domain))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLObjectPropertyDomainAxiom|"
      (myformat nil " ~S" (transform-s-expr object-property))
      (myformat nil " ~S" (transform-s-expr object-property-domain))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLObjectPropertyRangeAxiom| ( object-property object-property-range &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property object-property-range))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLObjectPropertyRangeAxiom|"
      (myformat nil " ~S" (transform-s-expr object-property))
      (myformat nil " ~S" (transform-s-expr object-property-range))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLObjectSubPropertyAxiom| ( object-sub-property object-super-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-sub-property object-super-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLObjectSubPropertyAxiom|"
      (myformat nil " ~S" (transform-s-expr object-sub-property))
      (myformat nil " ~S" (transform-s-expr object-super-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLOntologyAnnotationAxiom| ( annotation &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner annotation))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLOntologyAnnotationAxiom|"
      (myformat nil " ~S" (transform-s-expr annotation))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLOntologyVersionDeclarationAxiom| ( ontology-version-uri &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology-version-uri))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLOntologyVersionDeclarationAxiom|"
      (myformat nil " ~S" (transform-s-expr ontology-version-uri))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLPrefixDeclarationAxiom| ( namespace-prefix namespace &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner namespace-prefix namespace))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLPrefixDeclarationAxiom|"
      (myformat nil " ~S" (transform-s-expr namespace-prefix))
      (myformat nil " ~S" (transform-s-expr namespace))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLReallyImplicitDeclarationAxiom| ( entity &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner entity))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLReallyImplicitDeclarationAxiom|"
      (myformat nil " ~S" (transform-s-expr entity))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLReflexiveObjectPropertyAxiom| ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLReflexiveObjectPropertyAxiom|"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLSameIndividualsAxiom| ( individuals &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner individuals))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLSameIndividualsAxiom|"
      (myformat nil " ~S" (transform-s-expr individuals))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLSubAnnotationPropertyAxiom| ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLSubAnnotationPropertyAxiom|"
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLSubAnnotationPropertyOfAxiom| ( annotation-sub-property annotation-super-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner annotation-sub-property annotation-super-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLSubAnnotationPropertyOfAxiom|"
      (myformat nil " ~S" (transform-s-expr annotation-sub-property))
      (myformat nil " ~S" (transform-s-expr annotation-super-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLSubClassAxiom| ( sub-class super-class &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner sub-class super-class))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLSubClassAxiom|"
      (myformat nil " ~S" (transform-s-expr sub-class))
      (myformat nil " ~S" (transform-s-expr super-class))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLSymmetricObjectPropertyAxiom| ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLSymmetricObjectPropertyAxiom|"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getOWLTransitiveObjectPropertyAxiom| ( object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getOWLTransitiveObjectPropertyAxiom|"
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getPrefixes| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getPrefixes|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getRanges| ( property &optional  (reasoner nil reasoner-supplied-p) (owlapi-hacking-mode nil owlapi-hacking-mode-supplied-p))
 (declare (ignorable  reasoner owlapi-hacking-mode property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getRanges|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when owlapi-hacking-mode-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-hacking-mode)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getReasoners| ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getReasoners|"
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getRelatedIndividuals| ( subject object-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject object-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getRelatedIndividuals|"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr object-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getRelatedValues| ( subject data-property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject data-property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getRelatedValues|"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr data-property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getSameIndividuals| ( ind &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getSameIndividuals|"
      (myformat nil " ~S" (transform-s-expr ind))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getSubClasses| ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getSubClasses|"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getSubProperties| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getSubProperties|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getSuperClasses| ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getSuperClasses|"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getSuperProperties| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getSuperProperties|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-getTypes| ( individual direct &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner individual direct))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getTypes|"
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr direct))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-has-data-property-relationship ( subject property object &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject property object))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-has-data-property-relationship"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr property))
      (myformat nil " ~S" (transform-s-expr object))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-has-object-property-relationship ( subject property object &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject property object))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-has-object-property-relationship"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr property))
      (myformat nil " ~S" (transform-s-expr object))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-has-type ( ind type direct &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind type direct))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-has-type"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr type))
      (myformat nil " ~S" (transform-s-expr direct))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-hasDataPropertyRelationship| ( subject property object &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject property object))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-hasDataPropertyRelationship|"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr property))
      (myformat nil " ~S" (transform-s-expr object))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-hasObjectPropertyRelationship| ( subject property object &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner subject property object))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-hasObjectPropertyRelationship|"
      (myformat nil " ~S" (transform-s-expr subject))
      (myformat nil " ~S" (transform-s-expr property))
      (myformat nil " ~S" (transform-s-expr object))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-hasType| ( ind type direct &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind type direct))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-hasType|"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr type))
      (myformat nil " ~S" (transform-s-expr direct))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-id-to-axiom ( id &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner id))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-id-to-axiom"
      (myformat nil " ~S" (transform-s-expr id))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-IDToAxiom| ( id &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner id))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-IDToAxiom|"
      (myformat nil " ~S" (transform-s-expr id))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-ignore-annotations ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-ignore-annotations"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-ignore-declarations ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-ignore-declarations"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-ignoreAnnotations| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-ignoreAnnotations|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-ignoreDeclarations| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-ignoreDeclarations|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-init| ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-init|"
      ")" )))

   (service-request req-string))))

(defun owlapi-init ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-init"
      ")" )))

   (service-request req-string))))

(defun owlapi-is-asymmetric ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-asymmetric"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-class ( clsc &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner clsc))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-class"
      (myformat nil " ~S" (transform-s-expr clsc))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-classified ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-classified"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-consistent ( ontology &optional  (reasoner nil reasoner-supplied-p) (force-p nil force-p-supplied-p))
 (declare (ignorable  reasoner force-p ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-consistent"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when force-p-supplied-p (myformat nil " ~S" (transform-s-expr force-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-defined-class ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-defined-class"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-defined-data-property ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-defined-data-property"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-defined-individual ( ind &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-defined-individual"
      (myformat nil " ~S" (transform-s-expr ind))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-defined-object-property ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-defined-object-property"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-different-individual ( i j &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner i j))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-different-individual"
      (myformat nil " ~S" (transform-s-expr i))
      (myformat nil " ~S" (transform-s-expr j))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-entailed ( axiom-id-or-constructor &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner axiom-id-or-constructor))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-entailed"
      (myformat nil " ~S" (transform-s-expr axiom-id-or-constructor))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-equivalent-class ( clsc clsd &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner clsc clsd))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-equivalent-class"
      (myformat nil " ~S" (transform-s-expr clsc))
      (myformat nil " ~S" (transform-s-expr clsd))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-functional ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-functional"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-inverse-functional ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-inverse-functional"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-irreflexive ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-irreflexive"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-realised ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-realised"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-reflexive ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-reflexive"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-same-individual ( i j &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner i j))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-same-individual"
      (myformat nil " ~S" (transform-s-expr i))
      (myformat nil " ~S" (transform-s-expr j))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-satisfiable ( description &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner description))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-satisfiable"
      (myformat nil " ~S" (transform-s-expr description))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-sub-class-of ( clsc clsd &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner clsc clsd))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-sub-class-of"
      (myformat nil " ~S" (transform-s-expr clsc))
      (myformat nil " ~S" (transform-s-expr clsd))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-symmetric ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-symmetric"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-is-transitive ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-is-transitive"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isAsymmetric| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isAsymmetric|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isClass| ( clsc &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner clsc))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isClass|"
      (myformat nil " ~S" (transform-s-expr clsc))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isClassified| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isClassified|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isConsistent| ( ontology &optional  (reasoner nil reasoner-supplied-p) (force-p nil force-p-supplied-p))
 (declare (ignorable  reasoner force-p ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isConsistent|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when force-p-supplied-p (myformat nil " ~S" (transform-s-expr force-p)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isDefinedClass| ( cls &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner cls))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isDefinedClass|"
      (myformat nil " ~S" (transform-s-expr cls))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isDefinedDataProperty| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isDefinedDataProperty|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isDefinedIndividual| ( ind &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ind))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isDefinedIndividual|"
      (myformat nil " ~S" (transform-s-expr ind))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isDefinedObjectProperty| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isDefinedObjectProperty|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isDifferentIndividual| ( i j &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner i j))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isDifferentIndividual|"
      (myformat nil " ~S" (transform-s-expr i))
      (myformat nil " ~S" (transform-s-expr j))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isEntailed| ( axiom-id-or-constructor &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner axiom-id-or-constructor))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isEntailed|"
      (myformat nil " ~S" (transform-s-expr axiom-id-or-constructor))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isEquivalentClass| ( clsc clsd &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner clsc clsd))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isEquivalentClass|"
      (myformat nil " ~S" (transform-s-expr clsc))
      (myformat nil " ~S" (transform-s-expr clsd))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isFunctional| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isFunctional|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isInverseFunctional| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isInverseFunctional|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isIrreflexive| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isIrreflexive|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isRealised| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isRealised|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isReflexive| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isReflexive|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isSameIndividual| ( i j &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner i j))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isSameIndividual|"
      (myformat nil " ~S" (transform-s-expr i))
      (myformat nil " ~S" (transform-s-expr j))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isSatisfiable| ( description &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner description))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isSatisfiable|"
      (myformat nil " ~S" (transform-s-expr description))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isSubClassOf| ( clsc clsd &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner clsc clsd))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isSubClassOf|"
      (myformat nil " ~S" (transform-s-expr clsc))
      (myformat nil " ~S" (transform-s-expr clsd))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isSymmetric| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isSymmetric|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-isTransitive| ( property &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner property))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-isTransitive|"
      (myformat nil " ~S" (transform-s-expr property))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-keep-annotations ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-keep-annotations"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-keepAnnotations| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-keepAnnotations|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-load-axiom ( ont axiom &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axiom))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-load-axiom"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axiom))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-load-axioms ( ont axioms &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axioms))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-load-axioms"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axioms))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-load-ontologies ( ontologies &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontologies))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-load-ontologies"
      (myformat nil " ~S" (transform-s-expr ontologies))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-load-ontology ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-load-ontology"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-loadAxiom| ( ont axiom &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axiom))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-loadAxiom|"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axiom))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-loadAxioms| ( ont axioms &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axioms))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-loadAxioms|"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axioms))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-loadOntologies| ( ontologies &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontologies))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-loadOntologies|"
      (myformat nil " ~S" (transform-s-expr ontologies))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-loadOntology| ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-loadOntology|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-manually-apply-changes ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-manually-apply-changes"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-manuallyApplyChanges| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-manuallyApplyChanges|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-merge-ontologies ( ont1 ont2 &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont1 ont2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-merge-ontologies"
      (myformat nil " ~S" (transform-s-expr ont1))
      (myformat nil " ~S" (transform-s-expr ont2))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-mergeOntologies| ( ont1 ont2 &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont1 ont2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-mergeOntologies|"
      (myformat nil " ~S" (transform-s-expr ont1))
      (myformat nil " ~S" (transform-s-expr ont2))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-new-ontology ( name &optional  (reasoner nil reasoner-supplied-p) (secondary-p nil secondary-p-supplied-p))
 (declare (ignorable  reasoner secondary-p name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-new-ontology"
      (myformat nil " ~S" (transform-s-expr name))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when secondary-p-supplied-p (myformat nil " ~S" (transform-s-expr secondary-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-new-reasoner ( &optional  (owlapi-reasoner-name nil owlapi-reasoner-name-supplied-p) (make-racer-kb-current-p nil make-racer-kb-current-p-supplied-p) (init nil init-supplied-p) (owlapi-tbox nil owlapi-tbox-supplied-p) (owlapi-abox nil owlapi-abox-supplied-p) (own-racer-p nil own-racer-p-supplied-p))
 (declare (ignorable  owlapi-reasoner-name make-racer-kb-current-p init owlapi-tbox owlapi-abox own-racer-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-new-reasoner"
      (when owlapi-reasoner-name-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-reasoner-name)))
      (when make-racer-kb-current-p-supplied-p (myformat nil " ~S" (transform-s-expr make-racer-kb-current-p)))
      (when init-supplied-p (myformat nil " ~S" (transform-s-expr init)))
      (when owlapi-tbox-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-tbox)))
      (when owlapi-abox-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-abox)))
      (when own-racer-p-supplied-p (myformat nil " ~S" (transform-s-expr own-racer-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-new-reasoner1 ( &optional  (owlapi-reasoner-name nil owlapi-reasoner-name-supplied-p) (make-racer-kb-current-p nil make-racer-kb-current-p-supplied-p) (init nil init-supplied-p) (owlapi-tbox nil owlapi-tbox-supplied-p) (owlapi-abox nil owlapi-abox-supplied-p))
 (declare (ignorable  owlapi-reasoner-name make-racer-kb-current-p init owlapi-tbox owlapi-abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-new-reasoner1"
      (when owlapi-reasoner-name-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-reasoner-name)))
      (when make-racer-kb-current-p-supplied-p (myformat nil " ~S" (transform-s-expr make-racer-kb-current-p)))
      (when init-supplied-p (myformat nil " ~S" (transform-s-expr init)))
      (when owlapi-tbox-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-tbox)))
      (when owlapi-abox-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-abox)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-newOntology| ( name &optional  (reasoner nil reasoner-supplied-p) (secondary-p nil secondary-p-supplied-p))
 (declare (ignorable  reasoner secondary-p name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-newOntology|"
      (myformat nil " ~S" (transform-s-expr name))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when secondary-p-supplied-p (myformat nil " ~S" (transform-s-expr secondary-p)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-newReasoner| ( &optional  (owlapi-reasoner-name nil owlapi-reasoner-name-supplied-p) (make-racer-kb-current-p nil make-racer-kb-current-p-supplied-p) (init nil init-supplied-p) (owlapi-tbox nil owlapi-tbox-supplied-p) (owlapi-abox nil owlapi-abox-supplied-p) (own-racer-p nil own-racer-p-supplied-p))
 (declare (ignorable  owlapi-reasoner-name make-racer-kb-current-p init owlapi-tbox owlapi-abox own-racer-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-newReasoner|"
      (when owlapi-reasoner-name-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-reasoner-name)))
      (when make-racer-kb-current-p-supplied-p (myformat nil " ~S" (transform-s-expr make-racer-kb-current-p)))
      (when init-supplied-p (myformat nil " ~S" (transform-s-expr init)))
      (when owlapi-tbox-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-tbox)))
      (when owlapi-abox-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-abox)))
      (when own-racer-p-supplied-p (myformat nil " ~S" (transform-s-expr own-racer-p)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-newReasoner1| ( &optional  (owlapi-reasoner-name nil owlapi-reasoner-name-supplied-p) (make-racer-kb-current-p nil make-racer-kb-current-p-supplied-p) (init nil init-supplied-p) (owlapi-tbox nil owlapi-tbox-supplied-p) (owlapi-abox nil owlapi-abox-supplied-p))
 (declare (ignorable  owlapi-reasoner-name make-racer-kb-current-p init owlapi-tbox owlapi-abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-newReasoner1|"
      (when owlapi-reasoner-name-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-reasoner-name)))
      (when make-racer-kb-current-p-supplied-p (myformat nil " ~S" (transform-s-expr make-racer-kb-current-p)))
      (when init-supplied-p (myformat nil " ~S" (transform-s-expr init)))
      (when owlapi-tbox-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-tbox)))
      (when owlapi-abox-supplied-p (myformat nil " ~S" (transform-s-expr owlapi-abox)))
      ")" )))

   (service-request req-string))))

(defun owlapi-next-axiom-use-id ( id &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner id))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-next-axiom-use-id"
      (myformat nil " ~S" (transform-s-expr id))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-nextAxiomUseID| ( id &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner id))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-nextAxiomUseID|"
      (myformat nil " ~S" (transform-s-expr id))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-parse| ( args &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-parse|"
      (myformat nil " ~S" (transform-s-expr args))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-parse ( args &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-parse"
      (myformat nil " ~S" (transform-s-expr args))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-parse-native ( string &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner string))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-parse-native"
      (myformat nil " ~S" (transform-s-expr string))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-parseNative| ( string &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner string))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-parseNative|"
      (myformat nil " ~S" (transform-s-expr string))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-read-functional-ontology-document ( url &key  (strict-syntax-p nil strict-syntax-p-supplied-p) (use-flipped-class-assertions-p nil use-flipped-class-assertions-p-supplied-p) (ignore-import nil ignore-import-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (kb-name nil kb-name-supplied-p) (reasoner-name nil reasoner-name-supplied-p) (ontology-name nil ontology-name-supplied-p) (init nil init-supplied-p) (parser nil parser-supplied-p))
 (declare (ignorable  strict-syntax-p use-flipped-class-assertions-p ignore-import ignore-annotations merge-imported-ontologies-p maintain-owlapi-axioms kb-name reasoner-name ontology-name init parser url))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-read-functional-ontology-document"
      (myformat nil " ~S" (transform-s-expr url))
      (when strict-syntax-p-supplied-p (myformat nil " :strict-syntax-p ~S" (transform-s-expr strict-syntax-p)))
      (when use-flipped-class-assertions-p-supplied-p (myformat nil " :use-flipped-class-assertions-p ~S" (transform-s-expr use-flipped-class-assertions-p)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when reasoner-name-supplied-p (myformat nil " :reasoner-name ~S" (transform-s-expr reasoner-name)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      ")" )))

   (service-request req-string))))

(defun owlapi-read-functional-ontology-file ( fn &key  (strict-syntax-p nil strict-syntax-p-supplied-p) (use-flipped-class-assertions-p nil use-flipped-class-assertions-p-supplied-p) (ignore-import nil ignore-import-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (kb-name nil kb-name-supplied-p) (reasoner-name nil reasoner-name-supplied-p) (ontology-name nil ontology-name-supplied-p) (init nil init-supplied-p) (parser nil parser-supplied-p))
 (declare (ignorable  strict-syntax-p use-flipped-class-assertions-p ignore-import ignore-annotations merge-imported-ontologies-p maintain-owlapi-axioms kb-name reasoner-name ontology-name init parser fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-read-functional-ontology-file"
      (myformat nil " ~S" (transform-s-expr fn))
      (when strict-syntax-p-supplied-p (myformat nil " :strict-syntax-p ~S" (transform-s-expr strict-syntax-p)))
      (when use-flipped-class-assertions-p-supplied-p (myformat nil " :use-flipped-class-assertions-p ~S" (transform-s-expr use-flipped-class-assertions-p)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when reasoner-name-supplied-p (myformat nil " :reasoner-name ~S" (transform-s-expr reasoner-name)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      ")" )))

   (service-request req-string))))

(defun owlapi-read-ontology ( url &key  (syntax nil syntax-supplied-p) (strict-syntax-p nil strict-syntax-p-supplied-p) (use-flipped-class-assertions-p nil use-flipped-class-assertions-p-supplied-p) (reasoner-name nil reasoner-name-supplied-p) (parser nil parser-supplied-p) (verbose nil verbose-supplied-p) (init nil init-supplied-p) (kb-name nil kb-name-supplied-p) (locator nil locator-supplied-p) (recursive nil recursive-supplied-p) (ignore-import nil ignore-import-supplied-p) (ontology-name nil ontology-name-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p) (import-meta-ontologies nil import-meta-ontologies-supplied-p) (excluded-meta-ontologies nil excluded-meta-ontologies-supplied-p) (fire-rules nil fire-rules-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p))
 (declare (ignorable  syntax strict-syntax-p use-flipped-class-assertions-p reasoner-name parser verbose init kb-name locator recursive ignore-import ontology-name merge-imported-ontologies-p import-meta-ontologies excluded-meta-ontologies fire-rules maintain-owlapi-axioms ignore-annotations url))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-read-ontology"
      (myformat nil " ~S" (transform-s-expr url))
      (when syntax-supplied-p (myformat nil " :syntax ~S" (transform-s-expr syntax)))
      (when strict-syntax-p-supplied-p (myformat nil " :strict-syntax-p ~S" (transform-s-expr strict-syntax-p)))
      (when use-flipped-class-assertions-p-supplied-p (myformat nil " :use-flipped-class-assertions-p ~S" (transform-s-expr use-flipped-class-assertions-p)))
      (when reasoner-name-supplied-p (myformat nil " :reasoner-name ~S" (transform-s-expr reasoner-name)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when verbose-supplied-p (myformat nil " :verbose ~S" (transform-s-expr verbose)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when locator-supplied-p (myformat nil " :locator ~S" (transform-s-expr locator)))
      (when recursive-supplied-p (myformat nil " :recursive ~S" (transform-s-expr recursive)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      (when import-meta-ontologies-supplied-p (myformat nil " :import-meta-ontologies ~S" (transform-s-expr import-meta-ontologies)))
      (when excluded-meta-ontologies-supplied-p (myformat nil " :excluded-meta-ontologies ~S" (transform-s-expr excluded-meta-ontologies)))
      (when fire-rules-supplied-p (myformat nil " :fire-rules ~S" (transform-s-expr fire-rules)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      ")" )))

   (service-request req-string))))

(defun owlapi-read-xml-ontology-document ( url &key  (strict-syntax-p nil strict-syntax-p-supplied-p) (use-flipped-class-assertions-p nil use-flipped-class-assertions-p-supplied-p) (ignore-import nil ignore-import-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (kb-name nil kb-name-supplied-p) (reasoner-name nil reasoner-name-supplied-p) (ontology-name nil ontology-name-supplied-p) (init nil init-supplied-p) (parser nil parser-supplied-p))
 (declare (ignorable  strict-syntax-p use-flipped-class-assertions-p ignore-import ignore-annotations merge-imported-ontologies-p maintain-owlapi-axioms kb-name reasoner-name ontology-name init parser url))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-read-xml-ontology-document"
      (myformat nil " ~S" (transform-s-expr url))
      (when strict-syntax-p-supplied-p (myformat nil " :strict-syntax-p ~S" (transform-s-expr strict-syntax-p)))
      (when use-flipped-class-assertions-p-supplied-p (myformat nil " :use-flipped-class-assertions-p ~S" (transform-s-expr use-flipped-class-assertions-p)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when reasoner-name-supplied-p (myformat nil " :reasoner-name ~S" (transform-s-expr reasoner-name)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      ")" )))

   (service-request req-string))))

(defun owlapi-read-xml-ontology-file ( fn &key  (strict-syntax-p nil strict-syntax-p-supplied-p) (use-flipped-class-assertions-p nil use-flipped-class-assertions-p-supplied-p) (ignore-import nil ignore-import-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (kb-name nil kb-name-supplied-p) (reasoner-name nil reasoner-name-supplied-p) (ontology-name nil ontology-name-supplied-p) (init nil init-supplied-p) (parser nil parser-supplied-p))
 (declare (ignorable  strict-syntax-p use-flipped-class-assertions-p ignore-import ignore-annotations merge-imported-ontologies-p maintain-owlapi-axioms kb-name reasoner-name ontology-name init parser fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-read-xml-ontology-file"
      (myformat nil " ~S" (transform-s-expr fn))
      (when strict-syntax-p-supplied-p (myformat nil " :strict-syntax-p ~S" (transform-s-expr strict-syntax-p)))
      (when use-flipped-class-assertions-p-supplied-p (myformat nil " :use-flipped-class-assertions-p ~S" (transform-s-expr use-flipped-class-assertions-p)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when reasoner-name-supplied-p (myformat nil " :reasoner-name ~S" (transform-s-expr reasoner-name)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-readFunctionalOntologyDocument| ( url &key  (strict-syntax-p nil strict-syntax-p-supplied-p) (use-flipped-class-assertions-p nil use-flipped-class-assertions-p-supplied-p) (ignore-import nil ignore-import-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (kb-name nil kb-name-supplied-p) (reasoner-name nil reasoner-name-supplied-p) (ontology-name nil ontology-name-supplied-p) (init nil init-supplied-p) (parser nil parser-supplied-p))
 (declare (ignorable  strict-syntax-p use-flipped-class-assertions-p ignore-import ignore-annotations merge-imported-ontologies-p maintain-owlapi-axioms kb-name reasoner-name ontology-name init parser url))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-readFunctionalOntologyDocument|"
      (myformat nil " ~S" (transform-s-expr url))
      (when strict-syntax-p-supplied-p (myformat nil " :strict-syntax-p ~S" (transform-s-expr strict-syntax-p)))
      (when use-flipped-class-assertions-p-supplied-p (myformat nil " :use-flipped-class-assertions-p ~S" (transform-s-expr use-flipped-class-assertions-p)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when reasoner-name-supplied-p (myformat nil " :reasoner-name ~S" (transform-s-expr reasoner-name)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-readFunctionalOntologyFile| ( fn &key  (strict-syntax-p nil strict-syntax-p-supplied-p) (use-flipped-class-assertions-p nil use-flipped-class-assertions-p-supplied-p) (ignore-import nil ignore-import-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (kb-name nil kb-name-supplied-p) (reasoner-name nil reasoner-name-supplied-p) (ontology-name nil ontology-name-supplied-p) (init nil init-supplied-p) (parser nil parser-supplied-p))
 (declare (ignorable  strict-syntax-p use-flipped-class-assertions-p ignore-import ignore-annotations merge-imported-ontologies-p maintain-owlapi-axioms kb-name reasoner-name ontology-name init parser fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-readFunctionalOntologyFile|"
      (myformat nil " ~S" (transform-s-expr fn))
      (when strict-syntax-p-supplied-p (myformat nil " :strict-syntax-p ~S" (transform-s-expr strict-syntax-p)))
      (when use-flipped-class-assertions-p-supplied-p (myformat nil " :use-flipped-class-assertions-p ~S" (transform-s-expr use-flipped-class-assertions-p)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when reasoner-name-supplied-p (myformat nil " :reasoner-name ~S" (transform-s-expr reasoner-name)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-readOntology| ( url &key  (syntax nil syntax-supplied-p) (strict-syntax-p nil strict-syntax-p-supplied-p) (use-flipped-class-assertions-p nil use-flipped-class-assertions-p-supplied-p) (reasoner-name nil reasoner-name-supplied-p) (parser nil parser-supplied-p) (verbose nil verbose-supplied-p) (init nil init-supplied-p) (kb-name nil kb-name-supplied-p) (locator nil locator-supplied-p) (recursive nil recursive-supplied-p) (ignore-import nil ignore-import-supplied-p) (ontology-name nil ontology-name-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p) (import-meta-ontologies nil import-meta-ontologies-supplied-p) (excluded-meta-ontologies nil excluded-meta-ontologies-supplied-p) (fire-rules nil fire-rules-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p))
 (declare (ignorable  syntax strict-syntax-p use-flipped-class-assertions-p reasoner-name parser verbose init kb-name locator recursive ignore-import ontology-name merge-imported-ontologies-p import-meta-ontologies excluded-meta-ontologies fire-rules maintain-owlapi-axioms ignore-annotations url))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-readOntology|"
      (myformat nil " ~S" (transform-s-expr url))
      (when syntax-supplied-p (myformat nil " :syntax ~S" (transform-s-expr syntax)))
      (when strict-syntax-p-supplied-p (myformat nil " :strict-syntax-p ~S" (transform-s-expr strict-syntax-p)))
      (when use-flipped-class-assertions-p-supplied-p (myformat nil " :use-flipped-class-assertions-p ~S" (transform-s-expr use-flipped-class-assertions-p)))
      (when reasoner-name-supplied-p (myformat nil " :reasoner-name ~S" (transform-s-expr reasoner-name)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when verbose-supplied-p (myformat nil " :verbose ~S" (transform-s-expr verbose)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when locator-supplied-p (myformat nil " :locator ~S" (transform-s-expr locator)))
      (when recursive-supplied-p (myformat nil " :recursive ~S" (transform-s-expr recursive)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      (when import-meta-ontologies-supplied-p (myformat nil " :import-meta-ontologies ~S" (transform-s-expr import-meta-ontologies)))
      (when excluded-meta-ontologies-supplied-p (myformat nil " :excluded-meta-ontologies ~S" (transform-s-expr excluded-meta-ontologies)))
      (when fire-rules-supplied-p (myformat nil " :fire-rules ~S" (transform-s-expr fire-rules)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-readXMLOntologyDocument| ( url &key  (strict-syntax-p nil strict-syntax-p-supplied-p) (use-flipped-class-assertions-p nil use-flipped-class-assertions-p-supplied-p) (ignore-import nil ignore-import-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (kb-name nil kb-name-supplied-p) (reasoner-name nil reasoner-name-supplied-p) (ontology-name nil ontology-name-supplied-p) (init nil init-supplied-p) (parser nil parser-supplied-p))
 (declare (ignorable  strict-syntax-p use-flipped-class-assertions-p ignore-import ignore-annotations merge-imported-ontologies-p maintain-owlapi-axioms kb-name reasoner-name ontology-name init parser url))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-readXMLOntologyDocument|"
      (myformat nil " ~S" (transform-s-expr url))
      (when strict-syntax-p-supplied-p (myformat nil " :strict-syntax-p ~S" (transform-s-expr strict-syntax-p)))
      (when use-flipped-class-assertions-p-supplied-p (myformat nil " :use-flipped-class-assertions-p ~S" (transform-s-expr use-flipped-class-assertions-p)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when reasoner-name-supplied-p (myformat nil " :reasoner-name ~S" (transform-s-expr reasoner-name)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-readXMLOntologyFile| ( fn &key  (strict-syntax-p nil strict-syntax-p-supplied-p) (use-flipped-class-assertions-p nil use-flipped-class-assertions-p-supplied-p) (ignore-import nil ignore-import-supplied-p) (ignore-annotations nil ignore-annotations-supplied-p) (merge-imported-ontologies-p nil merge-imported-ontologies-p-supplied-p) (maintain-owlapi-axioms nil maintain-owlapi-axioms-supplied-p) (kb-name nil kb-name-supplied-p) (reasoner-name nil reasoner-name-supplied-p) (ontology-name nil ontology-name-supplied-p) (init nil init-supplied-p) (parser nil parser-supplied-p))
 (declare (ignorable  strict-syntax-p use-flipped-class-assertions-p ignore-import ignore-annotations merge-imported-ontologies-p maintain-owlapi-axioms kb-name reasoner-name ontology-name init parser fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-readXMLOntologyFile|"
      (myformat nil " ~S" (transform-s-expr fn))
      (when strict-syntax-p-supplied-p (myformat nil " :strict-syntax-p ~S" (transform-s-expr strict-syntax-p)))
      (when use-flipped-class-assertions-p-supplied-p (myformat nil " :use-flipped-class-assertions-p ~S" (transform-s-expr use-flipped-class-assertions-p)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      (when ignore-annotations-supplied-p (myformat nil " :ignore-annotations ~S" (transform-s-expr ignore-annotations)))
      (when merge-imported-ontologies-p-supplied-p (myformat nil " :merge-imported-ontologies-p ~S" (transform-s-expr merge-imported-ontologies-p)))
      (when maintain-owlapi-axioms-supplied-p (myformat nil " :maintain-owlapi-axioms ~S" (transform-s-expr maintain-owlapi-axioms)))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when reasoner-name-supplied-p (myformat nil " :reasoner-name ~S" (transform-s-expr reasoner-name)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-realize| ( &optional  (reasoner nil reasoner-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p))
 (declare (ignorable  reasoner check-abox-consistency-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-realize|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when check-abox-consistency-p-supplied-p (myformat nil " ~S" (transform-s-expr check-abox-consistency-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-realize ( &optional  (reasoner nil reasoner-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p))
 (declare (ignorable  reasoner check-abox-consistency-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-realize"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      (when check-abox-consistency-p-supplied-p (myformat nil " ~S" (transform-s-expr check-abox-consistency-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-register-declared-entities ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-register-declared-entities"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-register-last-answer ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-register-last-answer"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-register-object ( obj)
 (declare (ignorable  obj))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-register-object"
      (myformat nil " ~S" (transform-s-expr obj))
      ")" )))

   (service-request req-string))))

(defun owlapi-register-referenced-entities ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-register-referenced-entities"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-registerDeclaredEntities| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-registerDeclaredEntities|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-registerLastAnswer| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-registerLastAnswer|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-registerObject| ( obj)
 (declare (ignorable  obj))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-registerObject|"
      (myformat nil " ~S" (transform-s-expr obj))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-registerReferencedEntities| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-registerReferencedEntities|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-reload-loaded-ontologies ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-reload-loaded-ontologies"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-reloadLoadedOntologies| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-reloadLoadedOntologies|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-remove-axiom ( ont axiom &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axiom))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-remove-axiom"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axiom))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-remove-axioms ( ont axioms &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axioms))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-remove-axioms"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axioms))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-remove-prefix ( prefix &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner prefix))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-remove-prefix"
      (myformat nil " ~S" (transform-s-expr prefix))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-removeAxiom| ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-removeAxiom|"
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-RemoveAxiom| ( ont axiom &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axiom))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-RemoveAxiom|"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axiom))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-removeAxioms| ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-removeAxioms|"
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-RemoveAxioms| ( ont axioms &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axioms))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-RemoveAxioms|"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axioms))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-removePrefix| ( prefix &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner prefix))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-removePrefix|"
      (myformat nil " ~S" (transform-s-expr prefix))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-reset-axiom-counter ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-reset-axiom-counter"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-resetAxiomCounter| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-resetAxiomCounter|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-restore-image ( fn)
 (declare (ignorable  fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-restore-image"
      (myformat nil " ~S" (transform-s-expr fn))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-restoreImage| ( fn)
 (declare (ignorable  fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-restoreImage|"
      (myformat nil " ~S" (transform-s-expr fn))
      ")" )))

   (service-request req-string))))

(defun owlapi-save-ontology ( ontology fn &key  (reasoner nil reasoner-supplied-p) (syntax nil syntax-supplied-p) (prefixes nil prefixes-supplied-p) (p4-mode nil p4-mode-supplied-p) (comments nil comments-supplied-p))
 (declare (ignorable  reasoner syntax prefixes p4-mode comments ontology fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-save-ontology"
      (myformat nil " ~S" (transform-s-expr ontology))
      (myformat nil " ~S" (transform-s-expr fn))
      (when reasoner-supplied-p (myformat nil " :reasoner ~S" (transform-s-expr reasoner)))
      (when syntax-supplied-p (myformat nil " :syntax ~S" (transform-s-expr syntax)))
      (when prefixes-supplied-p (myformat nil " :prefixes ~S" (transform-s-expr prefixes)))
      (when p4-mode-supplied-p (myformat nil " :p4-mode ~S" (transform-s-expr p4-mode)))
      (when comments-supplied-p (myformat nil " :comments ~S" (transform-s-expr comments)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-saveOntology| ( ontology fn &key  (reasoner nil reasoner-supplied-p) (syntax nil syntax-supplied-p) (prefixes nil prefixes-supplied-p) (p4-mode nil p4-mode-supplied-p) (comments nil comments-supplied-p))
 (declare (ignorable  reasoner syntax prefixes p4-mode comments ontology fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-saveOntology|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (myformat nil " ~S" (transform-s-expr fn))
      (when reasoner-supplied-p (myformat nil " :reasoner ~S" (transform-s-expr reasoner)))
      (when syntax-supplied-p (myformat nil " :syntax ~S" (transform-s-expr syntax)))
      (when prefixes-supplied-p (myformat nil " :prefixes ~S" (transform-s-expr prefixes)))
      (when p4-mode-supplied-p (myformat nil " :p4-mode ~S" (transform-s-expr p4-mode)))
      (when comments-supplied-p (myformat nil " :comments ~S" (transform-s-expr comments)))
      ")" )))

   (service-request req-string))))

(defun owlapi-set-auto-declare-data-properties ( val &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner val))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-set-auto-declare-data-properties"
      (myformat nil " ~S" (transform-s-expr val))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-set-axiom-counter ( n &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner n))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-set-axiom-counter"
      (myformat nil " ~S" (transform-s-expr n))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-set-current-reasoner ( name &optional  (make-racer-kb-current-p nil make-racer-kb-current-p-supplied-p))
 (declare (ignorable  make-racer-kb-current-p name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-set-current-reasoner"
      (myformat nil " ~S" (transform-s-expr name))
      (when make-racer-kb-current-p-supplied-p (myformat nil " ~S" (transform-s-expr make-racer-kb-current-p)))
      ")" )))

   (service-request req-string))))

(defun owlapi-set-ontology-uri ( ont uri &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont uri))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-set-ontology-uri"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr uri))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-set-progress ( n &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner n))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-set-progress"
      (myformat nil " ~S" (transform-s-expr n))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-set-progress-range ( steps from to &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner steps from to))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-set-progress-range"
      (myformat nil " ~S" (transform-s-expr steps))
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-set-return-policy ( type &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner type))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-set-return-policy"
      (myformat nil " ~S" (transform-s-expr type))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-setAutoDeclareDataProperties| ( val &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner val))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-setAutoDeclareDataProperties|"
      (myformat nil " ~S" (transform-s-expr val))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-setAxiomCounter| ( n &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner n))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-setAxiomCounter|"
      (myformat nil " ~S" (transform-s-expr n))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-setCurrentReasoner| ( name &optional  (make-racer-kb-current-p nil make-racer-kb-current-p-supplied-p))
 (declare (ignorable  make-racer-kb-current-p name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-setCurrentReasoner|"
      (myformat nil " ~S" (transform-s-expr name))
      (when make-racer-kb-current-p-supplied-p (myformat nil " ~S" (transform-s-expr make-racer-kb-current-p)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-SetOntologyURI| ( ont uri &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont uri))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-SetOntologyURI|"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr uri))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-setProgress| ( n &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner n))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-setProgress|"
      (myformat nil " ~S" (transform-s-expr n))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-setProgressRange| ( steps from to &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner steps from to))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-setProgressRange|"
      (myformat nil " ~S" (transform-s-expr steps))
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-setReturnPolicy| ( type &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner type))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-setReturnPolicy|"
      (myformat nil " ~S" (transform-s-expr type))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-sleep| ( seconds &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner seconds))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-sleep|"
      (myformat nil " ~S" (transform-s-expr seconds))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-sleep ( seconds &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner seconds))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-sleep"
      (myformat nil " ~S" (transform-s-expr seconds))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-store-image ( fn &optional  (reasoners nil reasoners-supplied-p))
 (declare (ignorable  reasoners fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-store-image"
      (myformat nil " ~S" (transform-s-expr fn))
      (when reasoners-supplied-p (myformat nil " ~S" (transform-s-expr reasoners)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-storeImage| ( fn &optional  (reasoners nil reasoners-supplied-p))
 (declare (ignorable  reasoners fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-storeImage|"
      (myformat nil " ~S" (transform-s-expr fn))
      (when reasoners-supplied-p (myformat nil " ~S" (transform-s-expr reasoners)))
      ")" )))

   (service-request req-string))))

(defun owlapi-unload-axiom ( ont axiom &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axiom))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-unload-axiom"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axiom))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-unload-axioms ( ont axioms &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axioms))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-unload-axioms"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axioms))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-unload-ontologies ( ontologies &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontologies))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-unload-ontologies"
      (myformat nil " ~S" (transform-s-expr ontologies))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-unload-ontology ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-unload-ontology"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-unloadAxiom| ( ont axiom &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axiom))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-unloadAxiom|"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axiom))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-unloadAxioms| ( ont axioms &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ont axioms))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-unloadAxioms|"
      (myformat nil " ~S" (transform-s-expr ont))
      (myformat nil " ~S" (transform-s-expr axioms))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-unloadOntologies| ( ontologies &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontologies))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-unloadOntologies|"
      (myformat nil " ~S" (transform-s-expr ontologies))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-unloadOntology| ( ontology &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner ontology))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-unloadOntology|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-uses-incremental-updates ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-uses-incremental-updates"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-uses-simplified-protocol ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-uses-simplified-protocol"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-usesIncrementalUpdates| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-usesIncrementalUpdates|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-usesSimplifiedProtocol| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-usesSimplifiedProtocol|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   (service-request req-string))))

(defun owlapi-write-functional-ontology-file ( ontology fn &key  (prefixes nil prefixes-supplied-p) (p4-mode nil p4-mode-supplied-p) (comments nil comments-supplied-p))
 (declare (ignorable  prefixes p4-mode comments ontology fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-write-functional-ontology-file"
      (myformat nil " ~S" (transform-s-expr ontology))
      (myformat nil " ~S" (transform-s-expr fn))
      (when prefixes-supplied-p (myformat nil " :prefixes ~S" (transform-s-expr prefixes)))
      (when p4-mode-supplied-p (myformat nil " :p4-mode ~S" (transform-s-expr p4-mode)))
      (when comments-supplied-p (myformat nil " :comments ~S" (transform-s-expr comments)))
      ")" )))

   (service-request req-string))))

(defun owlapi-write-ontology-file ( ontology fn &key  (prefixes nil prefixes-supplied-p) (p4-mode nil p4-mode-supplied-p) (comments nil comments-supplied-p))
 (declare (ignorable  prefixes p4-mode comments ontology fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-write-ontology-file"
      (myformat nil " ~S" (transform-s-expr ontology))
      (myformat nil " ~S" (transform-s-expr fn))
      (when prefixes-supplied-p (myformat nil " :prefixes ~S" (transform-s-expr prefixes)))
      (when p4-mode-supplied-p (myformat nil " :p4-mode ~S" (transform-s-expr p4-mode)))
      (when comments-supplied-p (myformat nil " :comments ~S" (transform-s-expr comments)))
      ")" )))

   (service-request req-string))))

(defun owlapi-write-xml-ontology-file ( ontology fn &key  (prefixes nil prefixes-supplied-p) (p4-mode nil p4-mode-supplied-p) (comments nil comments-supplied-p))
 (declare (ignorable  prefixes p4-mode comments ontology fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owlapi-write-xml-ontology-file"
      (myformat nil " ~S" (transform-s-expr ontology))
      (myformat nil " ~S" (transform-s-expr fn))
      (when prefixes-supplied-p (myformat nil " :prefixes ~S" (transform-s-expr prefixes)))
      (when p4-mode-supplied-p (myformat nil " :p4-mode ~S" (transform-s-expr p4-mode)))
      (when comments-supplied-p (myformat nil " :comments ~S" (transform-s-expr comments)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-writeFunctionalOntologyFile| ( ontology fn &key  (prefixes nil prefixes-supplied-p) (p4-mode nil p4-mode-supplied-p) (comments nil comments-supplied-p))
 (declare (ignorable  prefixes p4-mode comments ontology fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-writeFunctionalOntologyFile|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (myformat nil " ~S" (transform-s-expr fn))
      (when prefixes-supplied-p (myformat nil " :prefixes ~S" (transform-s-expr prefixes)))
      (when p4-mode-supplied-p (myformat nil " :p4-mode ~S" (transform-s-expr p4-mode)))
      (when comments-supplied-p (myformat nil " :comments ~S" (transform-s-expr comments)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-writeOntologyFile| ( ontology fn &key  (prefixes nil prefixes-supplied-p) (p4-mode nil p4-mode-supplied-p) (comments nil comments-supplied-p))
 (declare (ignorable  prefixes p4-mode comments ontology fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-writeOntologyFile|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (myformat nil " ~S" (transform-s-expr fn))
      (when prefixes-supplied-p (myformat nil " :prefixes ~S" (transform-s-expr prefixes)))
      (when p4-mode-supplied-p (myformat nil " :p4-mode ~S" (transform-s-expr p4-mode)))
      (when comments-supplied-p (myformat nil " :comments ~S" (transform-s-expr comments)))
      ")" )))

   (service-request req-string))))

(defun |OWLAPI-writeXMLOntologyFile| ( ontology fn &key  (prefixes nil prefixes-supplied-p) (p4-mode nil p4-mode-supplied-p) (comments nil comments-supplied-p))
 (declare (ignorable  prefixes p4-mode comments ontology fn))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-writeXMLOntologyFile|"
      (myformat nil " ~S" (transform-s-expr ontology))
      (myformat nil " ~S" (transform-s-expr fn))
      (when prefixes-supplied-p (myformat nil " :prefixes ~S" (transform-s-expr prefixes)))
      (when p4-mode-supplied-p (myformat nil " :p4-mode ~S" (transform-s-expr p4-mode)))
      (when comments-supplied-p (myformat nil " :comments ~S" (transform-s-expr comments)))
      ")" )))

   (service-request req-string))))

(defun owllink-read-document ( url &rest  args)
 (declare (ignorable  args url))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owllink-read-document"
      (myformat nil " ~S" (transform-s-expr url))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   (service-request req-string))))

(defun owllink-read-file ( filename &rest  args)
 (declare (ignorable  args filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "owllink-read-file"
      (myformat nil " ~S" (transform-s-expr filename))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   (service-request req-string))))

(defun pracer-answer-query ( res-args query &key  (id nil id-supplied-p) (print-query nil print-query-supplied-p) (use-optimizer nil use-optimizer-supplied-p))
 (declare (ignorable  id print-query use-optimizer res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "pracer-answer-query"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when print-query-supplied-p (myformat nil " :print-query ~S" (transform-s-expr print-query)))
      (when use-optimizer-supplied-p (myformat nil " :use-optimizer ~S" (transform-s-expr use-optimizer)))
      ")" )))

   (service-request req-string))))

(defun prefer-defined-queries ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prefer-defined-queries"
      ")" )))

   (service-request req-string))))

(defun prepare-abox ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-abox"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun prepare-nrql-engine ( &key  (mode nil mode-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-lambdas nil dont-show-lambdas-supplied-p) (dont-show-head-projection-operators nil dont-show-head-projection-operators-supplied-p) (abox-mirroring nil abox-mirroring-supplied-p) (query-optimization nil query-optimization-supplied-p) (optimizer-use-cardinality-heuristics nil optimizer-use-cardinality-heuristics-supplied-p) (how-many-tuples nil how-many-tuples-supplied-p) (timeout nil timeout-supplied-p) (warnings nil warnings-supplied-p) (add-rule-consequences-automatically nil add-rule-consequences-automatically-supplied-p) (dont-add-abox-duplicates nil dont-add-abox-duplicates-supplied-p) (two-phase-query-processing-mode nil two-phase-query-processing-mode-supplied-p) (phase-two-starts-warning-tokens nil phase-two-starts-warning-tokens-supplied-p) (kb-has-changed-warning-tokens nil kb-has-changed-warning-tokens-supplied-p) (told-information-querying nil told-information-querying-supplied-p) (tuple-computation-mode nil tuple-computation-mode-supplied-p) (exclude-permutations nil exclude-permutations-supplied-p) (query-repository nil query-repository-supplied-p) (report-inconsistent-queries nil report-inconsistent-queries-supplied-p) (report-tautological-queries nil report-tautological-queries-supplied-p) (query-realization nil query-realization-supplied-p) (bindings nil bindings-supplied-p) (check-abox-consistency nil check-abox-consistency-supplied-p) (use-individual-equivalence-classes nil use-individual-equivalence-classes-supplied-p) (rewrite-to-dnf nil rewrite-to-dnf-supplied-p) (tbox nil tbox-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  mode dont-show-variables dont-show-lambdas dont-show-head-projection-operators abox-mirroring query-optimization optimizer-use-cardinality-heuristics how-many-tuples timeout warnings add-rule-consequences-automatically dont-add-abox-duplicates two-phase-query-processing-mode phase-two-starts-warning-tokens kb-has-changed-warning-tokens told-information-querying tuple-computation-mode exclude-permutations query-repository report-inconsistent-queries report-tautological-queries query-realization bindings check-abox-consistency use-individual-equivalence-classes rewrite-to-dnf tbox substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-nrql-engine"
      (when mode-supplied-p (myformat nil " :mode ~S" (transform-s-expr mode)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-lambdas-supplied-p (myformat nil " :dont-show-lambdas ~S" (transform-s-expr dont-show-lambdas)))
      (when dont-show-head-projection-operators-supplied-p (myformat nil " :dont-show-head-projection-operators ~S" (transform-s-expr dont-show-head-projection-operators)))
      (when abox-mirroring-supplied-p (myformat nil " :abox-mirroring ~S" (transform-s-expr abox-mirroring)))
      (when query-optimization-supplied-p (myformat nil " :query-optimization ~S" (transform-s-expr query-optimization)))
      (when optimizer-use-cardinality-heuristics-supplied-p (myformat nil " :optimizer-use-cardinality-heuristics ~S" (transform-s-expr optimizer-use-cardinality-heuristics)))
      (when how-many-tuples-supplied-p (myformat nil " :how-many-tuples ~S" (transform-s-expr how-many-tuples)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when warnings-supplied-p (myformat nil " :warnings ~S" (transform-s-expr warnings)))
      (when add-rule-consequences-automatically-supplied-p (myformat nil " :add-rule-consequences-automatically ~S" (transform-s-expr add-rule-consequences-automatically)))
      (when dont-add-abox-duplicates-supplied-p (myformat nil " :dont-add-abox-duplicates ~S" (transform-s-expr dont-add-abox-duplicates)))
      (when two-phase-query-processing-mode-supplied-p (myformat nil " :two-phase-query-processing-mode ~S" (transform-s-expr two-phase-query-processing-mode)))
      (when phase-two-starts-warning-tokens-supplied-p (myformat nil " :phase-two-starts-warning-tokens ~S" (transform-s-expr phase-two-starts-warning-tokens)))
      (when kb-has-changed-warning-tokens-supplied-p (myformat nil " :kb-has-changed-warning-tokens ~S" (transform-s-expr kb-has-changed-warning-tokens)))
      (when told-information-querying-supplied-p (myformat nil " :told-information-querying ~S" (transform-s-expr told-information-querying)))
      (when tuple-computation-mode-supplied-p (myformat nil " :tuple-computation-mode ~S" (transform-s-expr tuple-computation-mode)))
      (when exclude-permutations-supplied-p (myformat nil " :exclude-permutations ~S" (transform-s-expr exclude-permutations)))
      (when query-repository-supplied-p (myformat nil " :query-repository ~S" (transform-s-expr query-repository)))
      (when report-inconsistent-queries-supplied-p (myformat nil " :report-inconsistent-queries ~S" (transform-s-expr report-inconsistent-queries)))
      (when report-tautological-queries-supplied-p (myformat nil " :report-tautological-queries ~S" (transform-s-expr report-tautological-queries)))
      (when query-realization-supplied-p (myformat nil " :query-realization ~S" (transform-s-expr query-realization)))
      (when bindings-supplied-p (myformat nil " :bindings ~S" (transform-s-expr bindings)))
      (when check-abox-consistency-supplied-p (myformat nil " :check-abox-consistency ~S" (transform-s-expr check-abox-consistency)))
      (when use-individual-equivalence-classes-supplied-p (myformat nil " :use-individual-equivalence-classes ~S" (transform-s-expr use-individual-equivalence-classes)))
      (when rewrite-to-dnf-supplied-p (myformat nil " :rewrite-to-dnf ~S" (transform-s-expr rewrite-to-dnf)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun prepare-query ( &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-query"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun prepare-query1 ( &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-query1"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun prepare-racer-engine ( &key  (abox nil abox-supplied-p) (classify-tbox-p nil classify-tbox-p-supplied-p))
 (declare (ignorable  abox classify-tbox-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-racer-engine"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when classify-tbox-p-supplied-p (myformat nil " :classify-tbox-p ~S" (transform-s-expr classify-tbox-p)))
      ")" )))

   (service-request req-string))))

(defun prepare-rule ( &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-rule"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun prepare-rule1 ( &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-rule1"
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun prepared-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepared-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun prepared-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepared-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun print-abox-individuals ( &key  (stream nil stream-supplied-p) (abox nil abox-supplied-p) (concept-mapping nil concept-mapping-supplied-p) (ind-mapping nil ind-mapping-supplied-p) (pretty nil pretty-supplied-p))
 (declare (ignorable  stream abox concept-mapping ind-mapping pretty))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "print-abox-individuals"
      (when stream-supplied-p (myformat nil " :stream ~S" (transform-s-expr stream)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when concept-mapping-supplied-p (myformat nil " :concept-mapping ~S" (transform-s-expr concept-mapping)))
      (when ind-mapping-supplied-p (myformat nil " :ind-mapping ~S" (transform-s-expr ind-mapping)))
      (when pretty-supplied-p (myformat nil " :pretty ~S" (transform-s-expr pretty)))
      ")" )))

   (service-request req-string))))

(defun print-tbox-tree ( &optional  (tbox nil tbox-supplied-p) (stream nil stream-supplied-p) (hide-role-inverses nil hide-role-inverses-supplied-p))
 (declare (ignorable  tbox stream hide-role-inverses))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "print-tbox-tree"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when stream-supplied-p (myformat nil " ~S" (transform-s-expr stream)))
      (when hide-role-inverses-supplied-p (myformat nil " ~S" (transform-s-expr hide-role-inverses)))
      ")" )))

   (service-request req-string))))

(defun process-set-at-a-time ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "process-set-at-a-time"
      ")" )))

   (service-request req-string))))

(defun process-tuple-at-a-time ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "process-tuple-at-a-time"
      ")" )))

   (service-request req-string))))

(defun processed-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "processed-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun processed-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "processed-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun publish-1 ( individual &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "publish-1"
      (myformat nil " ~S" (transform-s-expr individual))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun publish-file ( filename url content-type)
 (declare (ignorable  filename url content-type))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "publish-file"
      (myformat nil " ~S" (transform-s-expr filename))
      (myformat nil " ~S" (transform-s-expr url))
      (myformat nil " ~S" (transform-s-expr content-type))
      ")" )))

   (service-request req-string))))

(defun query-accurate-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-accurate-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-active-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-active-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-ancestors ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-ancestors"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-body ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-body"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-children ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-children"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-consistent-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-consistent-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-descendants ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-descendants"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-entails-p ( a b)
 (declare (ignorable  a b))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-entails-p"
      (myformat nil " ~S" (transform-s-expr a))
      (myformat nil " ~S" (transform-s-expr b))
      ")" )))

   (service-request req-string))))

(defun query-equivalent-p ( a b)
 (declare (ignorable  a b))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-equivalent-p"
      (myformat nil " ~S" (transform-s-expr a))
      (myformat nil " ~S" (transform-s-expr b))
      ")" )))

   (service-request req-string))))

(defun query-equivalents ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-equivalents"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-head ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-head"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-parents ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-parents"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-prepared-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-prepared-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-processed-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-processed-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-ready-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-ready-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-running-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-running-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-sleeping-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-sleeping-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-subscribers ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-subscribers"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-terminated-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-terminated-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun query-waiting-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "query-waiting-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun racer-answer-query ( res-args query &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-answer-query"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-answer-query-under-premise ( res-args query &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-answer-query-under-premise"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-answer-query-under-premise1 ( query res-args &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-answer-query-under-premise1"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-answer-query-with-explanation ( res-args query &rest  args &key  (cutoff-fn nil cutoff-fn-supplied-p) (hypo-mode-stack nil hypo-mode-stack-supplied-p) (c-mode nil c-mode-supplied-p) (r-mode nil r-mode-supplied-p) (only-best-p nil only-best-p-supplied-p) (order-by nil order-by-supplied-p) (reverse-order-p nil reverse-order-p-supplied-p) (ensure-permutations-p nil ensure-permutations-p-supplied-p) (how-many nil how-many-supplied-p) (strategy nil strategy-supplied-p) (simple-result-p nil simple-result-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (same-as-only-p nil same-as-only-p-supplied-p) (candidate-individuals nil candidate-individuals-supplied-p) (binding-validator nil binding-validator-supplied-p))
 (declare (ignorable  cutoff-fn hypo-mode-stack c-mode r-mode only-best-p order-by reverse-order-p ensure-permutations-p how-many strategy simple-result-p runtime-consistency-checking-p final-consistency-checking-p same-as-only-p candidate-individuals binding-validator args res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-answer-query-with-explanation"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when cutoff-fn-supplied-p (myformat nil " :cutoff-fn ~S" (transform-s-expr cutoff-fn)))
      (when hypo-mode-stack-supplied-p (myformat nil " :hypo-mode-stack ~S" (transform-s-expr hypo-mode-stack)))
      (when c-mode-supplied-p (myformat nil " :c-mode ~S" (transform-s-expr c-mode)))
      (when r-mode-supplied-p (myformat nil " :r-mode ~S" (transform-s-expr r-mode)))
      (when only-best-p-supplied-p (myformat nil " :only-best-p ~S" (transform-s-expr only-best-p)))
      (when order-by-supplied-p (myformat nil " :order-by ~S" (transform-s-expr order-by)))
      (when reverse-order-p-supplied-p (myformat nil " :reverse-order-p ~S" (transform-s-expr reverse-order-p)))
      (when ensure-permutations-p-supplied-p (myformat nil " :ensure-permutations-p ~S" (transform-s-expr ensure-permutations-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when strategy-supplied-p (myformat nil " :strategy ~S" (transform-s-expr strategy)))
      (when simple-result-p-supplied-p (myformat nil " :simple-result-p ~S" (transform-s-expr simple-result-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when same-as-only-p-supplied-p (myformat nil " :same-as-only-p ~S" (transform-s-expr same-as-only-p)))
      (when candidate-individuals-supplied-p (myformat nil " :candidate-individuals ~S" (transform-s-expr candidate-individuals)))
      (when binding-validator-supplied-p (myformat nil " :binding-validator ~S" (transform-s-expr binding-validator)))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   (service-request req-string))))

(defun racer-answer-query1 ( query res-args &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-answer-query1"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-answer-tbox-query ( res-args query &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (tbox nil tbox-supplied-p) (package nil package-supplied-p) (create-tbox-if-not-found-p nil create-tbox-if-not-found-p-supplied-p) (substrate nil substrate-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois tbox package create-tbox-if-not-found-p substrate res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-answer-tbox-query"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when create-tbox-if-not-found-p-supplied-p (myformat nil " :create-tbox-if-not-found-p ~S" (transform-s-expr create-tbox-if-not-found-p)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      ")" )))

   (service-request req-string))))

(defun racer-answer-tbox-query1 ( query res-args &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (tbox nil tbox-supplied-p) (package nil package-supplied-p) (create-tbox-if-not-found-p nil create-tbox-if-not-found-p-supplied-p) (substrate nil substrate-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois tbox package create-tbox-if-not-found-p substrate query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-answer-tbox-query1"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when create-tbox-if-not-found-p-supplied-p (myformat nil " :create-tbox-if-not-found-p ~S" (transform-s-expr create-tbox-if-not-found-p)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      ")" )))

   (service-request req-string))))

(defun racer-apply-rule ( query res-args &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-apply-rule"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-apply-rule-under-premise ( query res-args &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-apply-rule-under-premise"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-apply-rule-under-premise1 ( res-args query &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-apply-rule-under-premise1"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-apply-rule1 ( res-args query &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-apply-rule1"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-prepare-query ( res-args query &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-prepare-query"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-prepare-query1 ( query res-args &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-prepare-query1"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-prepare-rule ( query res-args &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-prepare-rule"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-prepare-rule1 ( res-args query &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-prepare-rule1"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   (service-request req-string))))

(defun racer-prepare-tbox-query ( res-args query &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (tbox nil tbox-supplied-p) (package nil package-supplied-p) (create-tbox-if-not-found-p nil create-tbox-if-not-found-p-supplied-p) (substrate nil substrate-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois tbox package create-tbox-if-not-found-p substrate res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-prepare-tbox-query"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when create-tbox-if-not-found-p-supplied-p (myformat nil " :create-tbox-if-not-found-p ~S" (transform-s-expr create-tbox-if-not-found-p)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      ")" )))

   (service-request req-string))))

(defun racer-prepare-tbox-query1 ( query res-args &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (tbox nil tbox-supplied-p) (package nil package-supplied-p) (create-tbox-if-not-found-p nil create-tbox-if-not-found-p-supplied-p) (substrate nil substrate-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois tbox package create-tbox-if-not-found-p substrate query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-prepare-tbox-query1"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when create-tbox-if-not-found-p-supplied-p (myformat nil " :create-tbox-if-not-found-p ~S" (transform-s-expr create-tbox-if-not-found-p)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      ")" )))

   (service-request req-string))))

(defun racer-read-document ( url-spec &key  (verbose nil verbose-supplied-p))
 (declare (ignorable  verbose url-spec))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-read-document"
      (myformat nil " ~S" (transform-s-expr url-spec))
      (when verbose-supplied-p (myformat nil " :verbose ~S" (transform-s-expr verbose)))
      ")" )))

   (service-request req-string))))

(defun racer-read-file ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "racer-read-file"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun rcc-consistent-p ( &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-consistent-p"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun rcc-edge-description1 ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-edge-description1"
      ")" )))

   (service-request req-string))))

(defun rcc-edge-label1 ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-edge-label1"
      ")" )))

   (service-request req-string))))

(defun rcc-edge1 ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-edge1"
      ")" )))

   (service-request req-string))))

(defun rcc-instance1 ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-instance1"
      ")" )))

   (service-request req-string))))

(defun rcc-node-description1 ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-node-description1"
      ")" )))

   (service-request req-string))))

(defun rcc-node-label1 ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-node-label1"
      ")" )))

   (service-request req-string))))

(defun rcc-node1 ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-node1"
      ")" )))

   (service-request req-string))))

(defun rcc-related1 ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-related1"
      ")" )))

   (service-request req-string))))

(defun rdfs-read-tbox-file ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rdfs-read-tbox-file"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun ready-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "ready-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun ready-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "ready-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun realize-abox ( &optional  (abox nil abox-supplied-p) (individual-name nil individual-name-supplied-p))
 (declare (ignorable  abox individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "realize-abox"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when individual-name-supplied-p (myformat nil " ~S" (transform-s-expr individual-name)))
      ")" )))

   (service-request req-string))))

(defun recognize-events ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "recognize-events"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun reexecute-all-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "reexecute-all-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun reexecute-all-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "reexecute-all-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun reexecute-query ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "reexecute-query"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun reexecute-rule ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "reexecute-rule"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun reflexive-p ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "reflexive-p"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun register-rcc-synonym ( role rcc-relation)
 (declare (ignorable  role rcc-relation))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "register-rcc-synonym"
      (myformat nil " ~S" (transform-s-expr role))
      (myformat nil " ~S" (transform-s-expr rcc-relation))
      ")" )))

   (service-request req-string))))

(defun remove-implied-concept-assertions ( abox)
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "remove-implied-concept-assertions"
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun report-inconsistent-queries-and-rules ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "report-inconsistent-queries-and-rules"
      ")" )))

   (service-request req-string))))

(defun reprepare-query ( query &key  (to-substrate nil to-substrate-supplied-p) (copy-p nil copy-p-supplied-p) (new-id nil new-id-supplied-p))
 (declare (ignorable  to-substrate copy-p new-id query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "reprepare-query"
      (myformat nil " ~S" (transform-s-expr query))
      (when to-substrate-supplied-p (myformat nil " :to-substrate ~S" (transform-s-expr to-substrate)))
      (when copy-p-supplied-p (myformat nil " :copy-p ~S" (transform-s-expr copy-p)))
      (when new-id-supplied-p (myformat nil " :new-id ~S" (transform-s-expr new-id)))
      ")" )))

   (service-request req-string))))

(defun reprepare-rule ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "reprepare-rule"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun reset-all-substrates ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "reset-all-substrates"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun reset-nrql-engine ( &key  (full-reset-p nil full-reset-p-supplied-p))
 (declare (ignorable  full-reset-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "reset-nrql-engine"
      (when full-reset-p-supplied-p (myformat nil " :full-reset-p ~S" (transform-s-expr full-reset-p)))
      ")" )))

   (service-request req-string))))

(defun restore-abox-image ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "restore-abox-image"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun restore-aboxes-image ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "restore-aboxes-image"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun restore-all-substrates ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "restore-all-substrates"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun restore-kb-image ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "restore-kb-image"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun restore-kbs-image ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "restore-kbs-image"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun restore-server-image ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "restore-server-image"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun restore-standard-settings ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "restore-standard-settings"
      ")" )))

   (service-request req-string))))

(defun restore-substrate ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "restore-substrate"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun restore-tbox-image ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "restore-tbox-image"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun restore-tboxes-image ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "restore-tboxes-image"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun retrieve-concept-instances ( concept-term abox &optional  (candidates nil candidates-supplied-p))
 (declare (ignorable  candidates concept-term abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-concept-instances"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (myformat nil " ~S" (transform-s-expr abox))
      (when candidates-supplied-p (myformat nil " ~S" (transform-s-expr candidates)))
      ")" )))

   (service-request req-string))))

(defun retrieve-direct-predecessors ( role-term ind-filler abox)
 (declare (ignorable  role-term ind-filler abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-direct-predecessors"
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr ind-filler))
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun retrieve-individual-annotation-property-fillers ( individual-name role abox &optional  (with-types-p nil with-types-p-supplied-p))
 (declare (ignorable  with-types-p individual-name role abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-individual-annotation-property-fillers"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (myformat nil " ~S" (transform-s-expr role))
      (myformat nil " ~S" (transform-s-expr abox))
      (when with-types-p-supplied-p (myformat nil " ~S" (transform-s-expr with-types-p)))
      ")" )))

   (service-request req-string))))

(defun retrieve-individual-antonyms ( individual &optional  (told-only nil told-only-supplied-p) (abox nil abox-supplied-p))
 (declare (ignorable  told-only abox individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-individual-antonyms"
      (myformat nil " ~S" (transform-s-expr individual))
      (when told-only-supplied-p (myformat nil " ~S" (transform-s-expr told-only)))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun retrieve-individual-attribute-fillers ( ind attribute abox)
 (declare (ignorable  ind attribute abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-individual-attribute-fillers"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr attribute))
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun retrieve-individual-filled-roles ( ind-predecessor ind-filler abox &key  (synsets-p nil synsets-p-supplied-p) (negated-p nil negated-p-supplied-p) (no-inverses-p nil no-inverses-p-supplied-p) (roles nil roles-supplied-p))
 (declare (ignorable  synsets-p negated-p no-inverses-p roles ind-predecessor ind-filler abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-individual-filled-roles"
      (myformat nil " ~S" (transform-s-expr ind-predecessor))
      (myformat nil " ~S" (transform-s-expr ind-filler))
      (myformat nil " ~S" (transform-s-expr abox))
      (when synsets-p-supplied-p (myformat nil " :synsets-p ~S" (transform-s-expr synsets-p)))
      (when negated-p-supplied-p (myformat nil " :negated-p ~S" (transform-s-expr negated-p)))
      (when no-inverses-p-supplied-p (myformat nil " :no-inverses-p ~S" (transform-s-expr no-inverses-p)))
      (when roles-supplied-p (myformat nil " :roles ~S" (transform-s-expr roles)))
      ")" )))

   (service-request req-string))))

(defun retrieve-individual-fillers ( ind-predecessor role-term abox &key  (told nil told-supplied-p))
 (declare (ignorable  told ind-predecessor role-term abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-individual-fillers"
      (myformat nil " ~S" (transform-s-expr ind-predecessor))
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr abox))
      (when told-supplied-p (myformat nil " :told ~S" (transform-s-expr told)))
      ")" )))

   (service-request req-string))))

(defun retrieve-individual-synonyms ( individual &optional  (told-only nil told-only-supplied-p) (abox nil abox-supplied-p))
 (declare (ignorable  told-only abox individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-individual-synonyms"
      (myformat nil " ~S" (transform-s-expr individual))
      (when told-only-supplied-p (myformat nil " ~S" (transform-s-expr told-only)))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun retrieve-individual-told-attribute-value ( ind attribute abox)
 (declare (ignorable  ind attribute abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-individual-told-attribute-value"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr attribute))
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun retrieve-individual-told-datatype-fillers ( ind datatype-role &optional  (direct-p nil direct-p-supplied-p) (abox nil abox-supplied-p) (with-types-p nil with-types-p-supplied-p))
 (declare (ignorable  direct-p abox with-types-p ind datatype-role))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-individual-told-datatype-fillers"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr datatype-role))
      (when direct-p-supplied-p (myformat nil " ~S" (transform-s-expr direct-p)))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when with-types-p-supplied-p (myformat nil " ~S" (transform-s-expr with-types-p)))
      ")" )))

   (service-request req-string))))

(defun retrieve-related-individuals ( role-term abox)
 (declare (ignorable  role-term abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-related-individuals"
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun rmi ( args)
 (declare (ignorable  args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rmi"
      (myformat nil " ~S" (transform-s-expr args))
      ")" )))

   (service-request req-string))))

(defun role-disjoint-p ( role-term-1 role-term-2 tbox)
 (declare (ignorable  role-term-1 role-term-2 tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-disjoint-p"
      (myformat nil " ~S" (transform-s-expr role-term-1))
      (myformat nil " ~S" (transform-s-expr role-term-2))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-equivalent-p ( role-1 role-2 tbox)
 (declare (ignorable  role-1 role-2 tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-equivalent-p"
      (myformat nil " ~S" (transform-s-expr role-1))
      (myformat nil " ~S" (transform-s-expr role-2))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-has-domain ( rolename concept tbox &optional  (errorp nil errorp-supplied-p))
 (declare (ignorable  errorp rolename concept tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-has-domain"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr concept))
      (myformat nil " ~S" (transform-s-expr tbox))
      (when errorp-supplied-p (myformat nil " ~S" (transform-s-expr errorp)))
      ")" )))

   (service-request req-string))))

(defun role-has-parent ( rolename-1 rolename-2 tbox)
 (declare (ignorable  rolename-1 rolename-2 tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-has-parent"
      (myformat nil " ~S" (transform-s-expr rolename-1))
      (myformat nil " ~S" (transform-s-expr rolename-2))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-has-range ( rolename concept tbox &optional  (errorp nil errorp-supplied-p))
 (declare (ignorable  errorp rolename concept tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-has-range"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr concept))
      (myformat nil " ~S" (transform-s-expr tbox))
      (when errorp-supplied-p (myformat nil " ~S" (transform-s-expr errorp)))
      ")" )))

   (service-request req-string))))

(defun role-is-asymmetric ( rolename tbox)
 (declare (ignorable  rolename tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-is-asymmetric"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-is-functional ( rolename tbox)
 (declare (ignorable  rolename tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-is-functional"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-is-irreflexive ( rolename tbox)
 (declare (ignorable  rolename tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-is-irreflexive"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-is-reflexive ( rolename tbox)
 (declare (ignorable  rolename tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-is-reflexive"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-is-symmetric ( rolename tbox)
 (declare (ignorable  rolename tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-is-symmetric"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-is-transitive ( rolename tbox)
 (declare (ignorable  rolename tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-is-transitive"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-is-used-as-annotation-property ( rolename tbox)
 (declare (ignorable  rolename tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-is-used-as-annotation-property"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-is-used-as-datatype-property ( rolename tbox)
 (declare (ignorable  rolename tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-is-used-as-datatype-property"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-p ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-p"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun role-satisfiable-p ( role tbox)
 (declare (ignorable  role tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-satisfiable-p"
      (myformat nil " ~S" (transform-s-expr role))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-subsumes-p ( role-term-1 role-term-2 tbox)
 (declare (ignorable  role-term-1 role-term-2 tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-subsumes-p"
      (myformat nil " ~S" (transform-s-expr role-term-1))
      (myformat nil " ~S" (transform-s-expr role-term-2))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-used-as-annotation-property-p ( role-name tbox)
 (declare (ignorable  role-name tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-used-as-annotation-property-p"
      (myformat nil " ~S" (transform-s-expr role-name))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun role-used-as-datatype-property-p ( role-name tbox)
 (declare (ignorable  role-name tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-used-as-datatype-property-p"
      (myformat nil " ~S" (transform-s-expr role-name))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun roles-disjoint-1 ( role1 role2 tbox)
 (declare (ignorable  role1 role2 tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "roles-disjoint-1"
      (myformat nil " ~S" (transform-s-expr role1))
      (myformat nil " ~S" (transform-s-expr role2))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun roles-equivalent-1 ( role1 role2 tbox)
 (declare (ignorable  role1 role2 tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "roles-equivalent-1"
      (myformat nil " ~S" (transform-s-expr role1))
      (myformat nil " ~S" (transform-s-expr role2))
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun rule-accurate-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-accurate-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-active-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-active-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-antecedence ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-antecedence"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-applicable-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-applicable-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-consequence ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-consequence"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-consistent-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-consistent-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-prepared-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-prepared-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-processed-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-processed-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-ready-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-ready-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-running-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-running-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-sleeping-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-sleeping-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-terminated-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-terminated-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-unapplicable-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-unapplicable-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun rule-waiting-p ( query)
 (declare (ignorable  query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rule-waiting-p"
      (myformat nil " ~S" (transform-s-expr query))
      ")" )))

   (service-request req-string))))

(defun run-all-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p))
 (declare (ignorable  abox type-of-substrate dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "run-all-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      ")" )))

   (service-request req-string))))

(defun run-all-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "run-all-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun running-cheap-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "running-cheap-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun running-cheap-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "running-cheap-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun running-expensive-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "running-expensive-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun running-expensive-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "running-expensive-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun running-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "running-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun running-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "running-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun save-abox ( pathname-or-stream &optional  (abox nil abox-supplied-p) &key  (syntax nil syntax-supplied-p) (transformed nil transformed-supplied-p) (if-exists nil if-exists-supplied-p) (if-does-not-exist nil if-does-not-exist-supplied-p) (header nil header-supplied-p) (uri nil uri-supplied-p) (import-list nil import-list-supplied-p) (ontology-name nil ontology-name-supplied-p))
 (declare (ignorable  abox syntax transformed if-exists if-does-not-exist header uri import-list ontology-name pathname-or-stream))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "save-abox"
      (myformat nil " ~S" (transform-s-expr pathname-or-stream))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when syntax-supplied-p (myformat nil " :syntax ~S" (transform-s-expr syntax)))
      (when transformed-supplied-p (myformat nil " :transformed ~S" (transform-s-expr transformed)))
      (when if-exists-supplied-p (myformat nil " :if-exists ~S" (transform-s-expr if-exists)))
      (when if-does-not-exist-supplied-p (myformat nil " :if-does-not-exist ~S" (transform-s-expr if-does-not-exist)))
      (when header-supplied-p (myformat nil " :header ~S" (transform-s-expr header)))
      (when uri-supplied-p (myformat nil " :uri ~S" (transform-s-expr uri)))
      (when import-list-supplied-p (myformat nil " :import-list ~S" (transform-s-expr import-list)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      ")" )))

   (service-request req-string))))

(defun save-kb ( pathname-or-stream &key  (tbox nil tbox-supplied-p) (abox nil abox-supplied-p) (if-exists nil if-exists-supplied-p) (if-does-not-exist nil if-does-not-exist-supplied-p) (uri nil uri-supplied-p) (syntax nil syntax-supplied-p) (ontology-name nil ontology-name-supplied-p) (header nil header-supplied-p))
 (declare (ignorable  tbox abox if-exists if-does-not-exist uri syntax ontology-name header pathname-or-stream))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "save-kb"
      (myformat nil " ~S" (transform-s-expr pathname-or-stream))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when if-exists-supplied-p (myformat nil " :if-exists ~S" (transform-s-expr if-exists)))
      (when if-does-not-exist-supplied-p (myformat nil " :if-does-not-exist ~S" (transform-s-expr if-does-not-exist)))
      (when uri-supplied-p (myformat nil " :uri ~S" (transform-s-expr uri)))
      (when syntax-supplied-p (myformat nil " :syntax ~S" (transform-s-expr syntax)))
      (when ontology-name-supplied-p (myformat nil " :ontology-name ~S" (transform-s-expr ontology-name)))
      (when header-supplied-p (myformat nil " :header ~S" (transform-s-expr header)))
      ")" )))

   (service-request req-string))))

(defun save-ontology-to-triple-store ( &rest  args)
 (declare (ignorable  args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "save-ontology-to-triple-store"
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   (service-request req-string))))

(defun save-tbox ( pathname-or-stream &optional  (tbox nil tbox-supplied-p) &key  (syntax nil syntax-supplied-p) (transformed nil transformed-supplied-p) (avoid-duplicate-definitions nil avoid-duplicate-definitions-supplied-p) (if-exists nil if-exists-supplied-p) (if-does-not-exist nil if-does-not-exist-supplied-p) (uri nil uri-supplied-p) (anonymized nil anonymized-supplied-p) (header nil header-supplied-p))
 (declare (ignorable  tbox syntax transformed avoid-duplicate-definitions if-exists if-does-not-exist uri anonymized header pathname-or-stream))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "save-tbox"
      (myformat nil " ~S" (transform-s-expr pathname-or-stream))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when syntax-supplied-p (myformat nil " :syntax ~S" (transform-s-expr syntax)))
      (when transformed-supplied-p (myformat nil " :transformed ~S" (transform-s-expr transformed)))
      (when avoid-duplicate-definitions-supplied-p (myformat nil " :avoid-duplicate-definitions ~S" (transform-s-expr avoid-duplicate-definitions)))
      (when if-exists-supplied-p (myformat nil " :if-exists ~S" (transform-s-expr if-exists)))
      (when if-does-not-exist-supplied-p (myformat nil " :if-does-not-exist ~S" (transform-s-expr if-does-not-exist)))
      (when uri-supplied-p (myformat nil " :uri ~S" (transform-s-expr uri)))
      (when anonymized-supplied-p (myformat nil " :anonymized ~S" (transform-s-expr anonymized)))
      (when header-supplied-p (myformat nil " :header ~S" (transform-s-expr header)))
      ")" )))

   (service-request req-string))))

(defun server-case ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "server-case"
      ")" )))

   (service-request req-string))))

(defun server-function ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "server-function"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   (service-request req-string))))

(defun server-value ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "server-value"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   (service-request req-string))))

(defun set-attribute-filler ( abox individual value attribute &optional  (type nil type-supplied-p))
 (declare (ignorable  type abox individual value attribute))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-attribute-filler"
      (myformat nil " ~S" (transform-s-expr abox))
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr value))
      (myformat nil " ~S" (transform-s-expr attribute))
      (when type-supplied-p (myformat nil " ~S" (transform-s-expr type)))
      ")" )))

   (service-request req-string))))

(defun set-current-abox ( abox)
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-current-abox"
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   (service-request req-string))))

(defun set-current-tbox ( tbox)
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-current-tbox"
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   (service-request req-string))))

(defun set-data-box ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-data-box"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   (service-request req-string))))

(defun set-edge-label-for-non-existent-edges ( edge-label &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate edge-label))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-edge-label-for-non-existent-edges"
      (myformat nil " ~S" (transform-s-expr edge-label))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun set-find-abox ( abox-name1 abox-name2)
 (declare (ignorable  abox-name1 abox-name2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-find-abox"
      (myformat nil " ~S" (transform-s-expr abox-name1))
      (myformat nil " ~S" (transform-s-expr abox-name2))
      ")" )))

   (service-request req-string))))

(defun set-find-tbox ( tbox-name1 tbox-name2)
 (declare (ignorable  tbox-name1 tbox-name2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-find-tbox"
      (myformat nil " ~S" (transform-s-expr tbox-name1))
      (myformat nil " ~S" (transform-s-expr tbox-name2))
      ")" )))

   (service-request req-string))))

(defun set-initial-size-of-process-pool ( n)
 (declare (ignorable  n))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-initial-size-of-process-pool"
      (myformat nil " ~S" (transform-s-expr n))
      ")" )))

   (service-request req-string))))

(defun set-max-no-of-tuples-bound ( &optional  (n nil n-supplied-p))
 (declare (ignorable  n))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-max-no-of-tuples-bound"
      (when n-supplied-p (myformat nil " ~S" (transform-s-expr n)))
      ")" )))

   (service-request req-string))))

(defun set-maximum-size-of-process-pool ( n)
 (declare (ignorable  n))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-maximum-size-of-process-pool"
      (myformat nil " ~S" (transform-s-expr n))
      ")" )))

   (service-request req-string))))

(defun set-mirror-data-box ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-mirror-data-box"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   (service-request req-string))))

(defun set-new-ind-counter ( n)
 (declare (ignorable  n))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-new-ind-counter"
      (myformat nil " ~S" (transform-s-expr n))
      ")" )))

   (service-request req-string))))

(defun set-new-ind-prefix ( prefix)
 (declare (ignorable  prefix))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-new-ind-prefix"
      (myformat nil " ~S" (transform-s-expr prefix))
      ")" )))

   (service-request req-string))))

(defun set-nrql-mode ( mode)
 (declare (ignorable  mode))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-nrql-mode"
      (myformat nil " ~S" (transform-s-expr mode))
      ")" )))

   (service-request req-string))))

(defun set-proxy-server ( proxy)
 (declare (ignorable  proxy))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-proxy-server"
      (myformat nil " ~S" (transform-s-expr proxy))
      ")" )))

   (service-request req-string))))

(defun set-racer-parameter ( name value)
 (declare (ignorable  name value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-racer-parameter"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr value))
      ")" )))

   (service-request req-string))))

(defun set-rcc-box ( name &optional  (rcc-type nil rcc-type-supplied-p) (type nil type-supplied-p))
 (declare (ignorable  rcc-type type name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-rcc-box"
      (myformat nil " ~S" (transform-s-expr name))
      (when rcc-type-supplied-p (myformat nil " ~S" (transform-s-expr rcc-type)))
      (when type-supplied-p (myformat nil " ~S" (transform-s-expr type)))
      ")" )))

   (service-request req-string))))

(defun set-rewrite-defined-concepts ( val)
 (declare (ignorable  val))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-rewrite-defined-concepts"
      (myformat nil " ~S" (transform-s-expr val))
      ")" )))

   (service-request req-string))))

(defun set-server-timeout ( timeout)
 (declare (ignorable  timeout))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-server-timeout"
      (myformat nil " ~S" (transform-s-expr timeout))
      ")" )))

   (service-request req-string))))

(defun set-substrate-type ( type)
 (declare (ignorable  type))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-substrate-type"
      (myformat nil " ~S" (transform-s-expr type))
      ")" )))

   (service-request req-string))))

(defun set-unique-name-assumption ( value)
 (declare (ignorable  value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "set-unique-name-assumption"
      (myformat nil " ~S" (transform-s-expr value))
      ")" )))

   (service-request req-string))))

(defun show-qbox-for-abox ( &optional  (abox nil abox-supplied-p) (definitions-p nil definitions-p-supplied-p))
 (declare (ignorable  abox definitions-p))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "show-qbox-for-abox"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when definitions-p-supplied-p (myformat nil " ~S" (transform-s-expr definitions-p)))
      ")" )))

   (service-request req-string))))

(defun sleeping-cheap-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "sleeping-cheap-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun sleeping-cheap-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "sleeping-cheap-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun sleeping-expensive-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "sleeping-expensive-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun sleeping-expensive-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "sleeping-expensive-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun sleeping-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "sleeping-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun sleeping-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "sleeping-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun store-abox-image ( filename &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "store-abox-image"
      (myformat nil " ~S" (transform-s-expr filename))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun store-aboxes-image ( filename aboxes)
 (declare (ignorable  filename aboxes))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "store-aboxes-image"
      (myformat nil " ~S" (transform-s-expr filename))
      (myformat nil " ~S" (transform-s-expr aboxes))
      ")" )))

   (service-request req-string))))

(defun store-all-substrates ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "store-all-substrates"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun store-kb-image ( filename &optional  (kb nil kb-supplied-p))
 (declare (ignorable  kb filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "store-kb-image"
      (myformat nil " ~S" (transform-s-expr filename))
      (when kb-supplied-p (myformat nil " ~S" (transform-s-expr kb)))
      ")" )))

   (service-request req-string))))

(defun store-kbs-image ( filename kbs)
 (declare (ignorable  filename kbs))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "store-kbs-image"
      (myformat nil " ~S" (transform-s-expr filename))
      (myformat nil " ~S" (transform-s-expr kbs))
      ")" )))

   (service-request req-string))))

(defun store-server-image ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "store-server-image"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun store-substrate-for-abox ( filename &optional  (for-abox nil for-abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  for-abox type-of-substrate filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "store-substrate-for-abox"
      (myformat nil " ~S" (transform-s-expr filename))
      (when for-abox-supplied-p (myformat nil " ~S" (transform-s-expr for-abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun store-tbox-image ( filename &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "store-tbox-image"
      (myformat nil " ~S" (transform-s-expr filename))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun store-tboxes-image ( tboxes filename)
 (declare (ignorable  tboxes filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "store-tboxes-image"
      (myformat nil " ~S" (transform-s-expr tboxes))
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defun subscribe-1 ( subscriber-name query-concept &optional  (abox nil abox-supplied-p) (ip nil ip-supplied-p) (port nil port-supplied-p) (simple-protocol-p nil simple-protocol-p-supplied-p))
 (declare (ignorable  abox ip port simple-protocol-p subscriber-name query-concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "subscribe-1"
      (myformat nil " ~S" (transform-s-expr subscriber-name))
      (myformat nil " ~S" (transform-s-expr query-concept))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when ip-supplied-p (myformat nil " ~S" (transform-s-expr ip)))
      (when port-supplied-p (myformat nil " ~S" (transform-s-expr port)))
      (when simple-protocol-p-supplied-p (myformat nil " ~S" (transform-s-expr simple-protocol-p)))
      ")" )))

   (service-request req-string))))

(defun subscribe-to ( query subscriber-name &key  (ip nil ip-supplied-p) (port nil port-supplied-p) (use-simplified-protocol-p nil use-simplified-protocol-p-supplied-p))
 (declare (ignorable  ip port use-simplified-protocol-p query subscriber-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "subscribe-to"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr subscriber-name))
      (when ip-supplied-p (myformat nil " :ip ~S" (transform-s-expr ip)))
      (when port-supplied-p (myformat nil " :port ~S" (transform-s-expr port)))
      (when use-simplified-protocol-p-supplied-p (myformat nil " :use-simplified-protocol-p ~S" (transform-s-expr use-simplified-protocol-p)))
      ")" )))

   (service-request req-string))))

(defun swrl-create-abduction-rules-if-possible ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "swrl-create-abduction-rules-if-possible"
      ")" )))

   (service-request req-string))))

(defun swrl-create-forward-chainging-rules ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "swrl-create-forward-chainging-rules"
      ")" )))

   (service-request req-string))))

(defun swrl-forward-chaining ( &key  (abox nil abox-supplied-p) (verbose nil verbose-supplied-p) (delete-rules nil delete-rules-supplied-p))
 (declare (ignorable  abox verbose delete-rules))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "swrl-forward-chaining"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when verbose-supplied-p (myformat nil " :verbose ~S" (transform-s-expr verbose)))
      (when delete-rules-supplied-p (myformat nil " :delete-rules ~S" (transform-s-expr delete-rules)))
      ")" )))

   (service-request req-string))))

(defun symmetric-p ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "symmetric-p"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun taxonomy ( &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "taxonomy"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun tbox-classified-p ( &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "tbox-classified-p"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun tbox-coherent-p ( &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "tbox-coherent-p"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun tbox-cyclic-p ( &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "tbox-cyclic-p"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun tbox-prepared-p ( &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "tbox-prepared-p"
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun terminated-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "terminated-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun terminated-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "terminated-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun timenet-answer-query ( query &key  (abox nil abox-supplied-p))
 (declare (ignorable  abox query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "timenet-answer-query"
      (myformat nil " ~S" (transform-s-expr query))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun told-value ( object &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox object))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "told-value"
      (myformat nil " ~S" (transform-s-expr object))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun transitive-p ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "transitive-p"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   (service-request req-string))))

(defun transmit-file ( extension n-bytes)
 (declare (ignorable  extension n-bytes))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "transmit-file"
      (myformat nil " ~S" (transform-s-expr extension))
      (myformat nil " ~S" (transform-s-expr n-bytes))
      ")" )))

   (service-request req-string))))

(defun triple-store-graphs ( &key  (db nil db-supplied-p) (directory nil directory-supplied-p))
 (declare (ignorable  db directory))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "triple-store-graphs"
      (when db-supplied-p (myformat nil " :db ~S" (transform-s-expr db)))
      (when directory-supplied-p (myformat nil " :directory ~S" (transform-s-expr directory)))
      ")" )))

   (service-request req-string))))

(defun triple-store-open-p ( &optional  (db-name nil db-name-supplied-p))
 (declare (ignorable  db-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "triple-store-open-p"
      (when db-name-supplied-p (myformat nil " ~S" (transform-s-expr db-name)))
      ")" )))

   (service-request req-string))))

(defun triple-store-read-file ( filename &key  (db nil db-supplied-p) (init nil init-supplied-p) (verbose nil verbose-supplied-p) (if-exists nil if-exists-supplied-p) (index-p nil index-p-supplied-p) (graph nil graph-supplied-p) (data-version-level nil data-version-level-supplied-p))
 (declare (ignorable  db init verbose if-exists index-p graph data-version-level filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "triple-store-read-file"
      (myformat nil " ~S" (transform-s-expr filename))
      (when db-supplied-p (myformat nil " :db ~S" (transform-s-expr db)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when verbose-supplied-p (myformat nil " :verbose ~S" (transform-s-expr verbose)))
      (when if-exists-supplied-p (myformat nil " :if-exists ~S" (transform-s-expr if-exists)))
      (when index-p-supplied-p (myformat nil " :index-p ~S" (transform-s-expr index-p)))
      (when graph-supplied-p (myformat nil " :graph ~S" (transform-s-expr graph)))
      (when data-version-level-supplied-p (myformat nil " :data-version-level ~S" (transform-s-expr data-version-level)))
      ")" )))

   (service-request req-string))))

(defun unapplicable-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "unapplicable-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun unbind-all ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "unbind-all"
      ")" )))

   (service-request req-string))))

(defun unbind1 ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "unbind1"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   (service-request req-string))))

(defun undefine-all ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "undefine-all"
      ")" )))

   (service-request req-string))))

(defun undefine-query ( name &key  (tbox nil tbox-supplied-p) (arity nil arity-supplied-p))
 (declare (ignorable  tbox arity name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "undefine-query"
      (myformat nil " ~S" (transform-s-expr name))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when arity-supplied-p (myformat nil " :arity ~S" (transform-s-expr arity)))
      ")" )))

   (service-request req-string))))

(defun undefine1 ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "undefine1"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   (service-request req-string))))

(defun unpublish-1 ( individual &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "unpublish-1"
      (myformat nil " ~S" (transform-s-expr individual))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun unsubscribe-1 ( subscriber-name &optional  (query-concept nil query-concept-supplied-p) (abox nil abox-supplied-p))
 (declare (ignorable  query-concept abox subscriber-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "unsubscribe-1"
      (myformat nil " ~S" (transform-s-expr subscriber-name))
      (when query-concept-supplied-p (myformat nil " ~S" (transform-s-expr query-concept)))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun unsubscribe-from ( query subscriber-name &key  (ip nil ip-supplied-p) (port nil port-supplied-p) (use-simplified-protocol-p nil use-simplified-protocol-p-supplied-p))
 (declare (ignorable  ip port use-simplified-protocol-p query subscriber-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "unsubscribe-from"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr subscriber-name))
      (when ip-supplied-p (myformat nil " :ip ~S" (transform-s-expr ip)))
      (when port-supplied-p (myformat nil " :port ~S" (transform-s-expr port)))
      (when use-simplified-protocol-p-supplied-p (myformat nil " :use-simplified-protocol-p ~S" (transform-s-expr use-simplified-protocol-p)))
      ")" )))

   (service-request req-string))))

(defun update-racer ( &key  (patchdir nil patchdir-supplied-p) (plugindir nil plugindir-supplied-p) (url nil url-supplied-p))
 (declare (ignorable  patchdir plugindir url))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "update-racer"
      (when patchdir-supplied-p (myformat nil " :patchdir ~S" (transform-s-expr patchdir)))
      (when plugindir-supplied-p (myformat nil " :plugindir ~S" (transform-s-expr plugindir)))
      (when url-supplied-p (myformat nil " :url ~S" (transform-s-expr url)))
      ")" )))

   (service-request req-string))))

(defun use-individual-synonym-equivalence-classes ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "use-individual-synonym-equivalence-classes"
      ")" )))

   (service-request req-string))))

(defun use-injective-variables-by-default ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "use-injective-variables-by-default"
      ")" )))

   (service-request req-string))))

(defun use-triple-store ( db &key  (kb-name nil kb-name-supplied-p) (graph nil graph-supplied-p) (subgraph nil subgraph-supplied-p) (partition nil partition-supplied-p) (told-only nil told-only-supplied-p) (init nil init-supplied-p) (verbose nil verbose-supplied-p) (directory nil directory-supplied-p) (ignore-import nil ignore-import-supplied-p))
 (declare (ignorable  kb-name graph subgraph partition told-only init verbose directory ignore-import db))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "use-triple-store"
      (myformat nil " ~S" (transform-s-expr db))
      (when kb-name-supplied-p (myformat nil " :kb-name ~S" (transform-s-expr kb-name)))
      (when graph-supplied-p (myformat nil " :graph ~S" (transform-s-expr graph)))
      (when subgraph-supplied-p (myformat nil " :subgraph ~S" (transform-s-expr subgraph)))
      (when partition-supplied-p (myformat nil " :partition ~S" (transform-s-expr partition)))
      (when told-only-supplied-p (myformat nil " :told-only ~S" (transform-s-expr told-only)))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when verbose-supplied-p (myformat nil " :verbose ~S" (transform-s-expr verbose)))
      (when directory-supplied-p (myformat nil " :directory ~S" (transform-s-expr directory)))
      (when ignore-import-supplied-p (myformat nil " :ignore-import ~S" (transform-s-expr ignore-import)))
      ")" )))

   (service-request req-string))))

(defun verify-with-abox-individuals-list ( individuals-list &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individuals-list))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "verify-with-abox-individuals-list"
      (myformat nil " ~S" (transform-s-expr individuals-list))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   (service-request req-string))))

(defun verify-with-concept-tree-list ( tree-list &optional  (tbox nil tbox-supplied-p) (ignore-error nil ignore-error-supplied-p))
 (declare (ignorable  tbox ignore-error tree-list))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "verify-with-concept-tree-list"
      (myformat nil " ~S" (transform-s-expr tree-list))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when ignore-error-supplied-p (myformat nil " ~S" (transform-s-expr ignore-error)))
      ")" )))

   (service-request req-string))))

(defun wait-for-queries-to-terminate ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "wait-for-queries-to-terminate"
      ")" )))

   (service-request req-string))))

(defun wait-for-rules-to-terminate ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "wait-for-rules-to-terminate"
      ")" )))

   (service-request req-string))))

(defun waiting-cheap-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "waiting-cheap-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun waiting-cheap-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "waiting-cheap-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun waiting-expensive-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "waiting-expensive-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun waiting-expensive-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "waiting-expensive-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun waiting-queries ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "waiting-queries"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun waiting-rules ( &key  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "waiting-rules"
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   (service-request req-string))))

(defun xml-read-tbox-file ( filename)
 (declare (ignorable  filename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "xml-read-tbox-file"
      (myformat nil " ~S" (transform-s-expr filename))
      ")" )))

   (service-request req-string))))

(defmacro abox-consistent? ( &optional  (abox-name nil abox-name-supplied-p))
 (declare (ignorable  abox-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abox-consistent?"
      (when abox-name-supplied-p (myformat nil " ~S" (transform-s-expr abox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro abox-prepared? ( &optional  (abox-name nil abox-name-supplied-p))
 (declare (ignorable  abox-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abox-prepared?"
      (when abox-name-supplied-p (myformat nil " ~S" (transform-s-expr abox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro abox-realized? ( &optional  (abox-name nil abox-name-supplied-p))
 (declare (ignorable  abox-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abox-realized?"
      (when abox-name-supplied-p (myformat nil " ~S" (transform-s-expr abox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro abox-una-consistent? ( &optional  (abox-name nil abox-name-supplied-p))
 (declare (ignorable  abox-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "abox-una-consistent?"
      (when abox-name-supplied-p (myformat nil " ~S" (transform-s-expr abox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro add-doc-entry ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-doc-entry"
      ")" )))

   `(service-request ,req-string))))

(defmacro add-doc-image-data ( url type bytes)
 (declare (ignorable  url type bytes))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-doc-image-data"
      (myformat nil " ~S" (transform-s-expr url))
      (myformat nil " ~S" (transform-s-expr type))
      (myformat nil " ~S" (transform-s-expr bytes))
      ")" )))

   `(service-request ,req-string))))

(defmacro add-doc-image-data-from-file ( url type pathname)
 (declare (ignorable  url type pathname))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-doc-image-data-from-file"
      (myformat nil " ~S" (transform-s-expr url))
      (myformat nil " ~S" (transform-s-expr type))
      (myformat nil " ~S" (transform-s-expr pathname))
      ")" )))

   `(service-request ,req-string))))

(defmacro add-doc-image-file ( url type pathname)
 (declare (ignorable  url type pathname))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-doc-image-file"
      (myformat nil " ~S" (transform-s-expr url))
      (myformat nil " ~S" (transform-s-expr type))
      (myformat nil " ~S" (transform-s-expr pathname))
      ")" )))

   `(service-request ,req-string))))

(defmacro add-doc-phrase ( label string)
 (declare (ignorable  label string))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "add-doc-phrase"
      (myformat nil " ~S" (transform-s-expr label))
      (myformat nil " ~S" (transform-s-expr string))
      ")" )))

   `(service-request ,req-string))))

(defmacro all-different ( &rest  individual-name-set)
 (declare (ignorable  individual-name-set))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "all-different"
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr individual-name-set))
      ")" )))

   `(service-request ,req-string))))

(defmacro apply-abox-rule ( query res-args &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "apply-abox-rule"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro apply-abox-rule-under-premise ( query res-args &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "apply-abox-rule-under-premise"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro apply-abox-rule-under-premise1 ( res-args query &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "apply-abox-rule-under-premise1"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro apply-abox-rule1 ( res-args query &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "apply-abox-rule1"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro asymmetric ( rolename &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox rolename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "asymmetric"
      (myformat nil " ~S" (transform-s-expr rolename))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro asymmetric? ( role-term &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "asymmetric?"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro attribute-domain ( attribute-name &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox attribute-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "attribute-domain"
      (myformat nil " ~S" (transform-s-expr attribute-name))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro attribute-filler ( individual value attribute &optional  (type nil type-supplied-p))
 (declare (ignorable  type individual value attribute))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "attribute-filler"
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr value))
      (myformat nil " ~S" (transform-s-expr attribute))
      (when type-supplied-p (myformat nil " ~S" (transform-s-expr type)))
      ")" )))

   `(service-request ,req-string))))

(defmacro cd-attribute? ( attribute &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name attribute))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "cd-attribute?"
      (myformat nil " ~S" (transform-s-expr attribute))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro cd-object? ( object-name &optional  (abox-name nil abox-name-supplied-p))
 (declare (ignorable  abox-name object-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "cd-object?"
      (myformat nil " ~S" (transform-s-expr object-name))
      (when abox-name-supplied-p (myformat nil " ~S" (transform-s-expr abox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro clone-abox ( abox &key  (new-name nil new-name-supplied-p) (overwrite nil overwrite-supplied-p))
 (declare (ignorable  new-name overwrite abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "clone-abox"
      (myformat nil " ~S" (transform-s-expr abox))
      (when new-name-supplied-p (myformat nil " :new-name ~S" (transform-s-expr new-name)))
      (when overwrite-supplied-p (myformat nil " :overwrite ~S" (transform-s-expr overwrite)))
      ")" )))

   `(service-request ,req-string))))

(defmacro clone-tbox ( tbox &key  (new-name nil new-name-supplied-p) (overwrite nil overwrite-supplied-p))
 (declare (ignorable  new-name overwrite tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "clone-tbox"
      (myformat nil " ~S" (transform-s-expr tbox))
      (when new-name-supplied-p (myformat nil " :new-name ~S" (transform-s-expr new-name)))
      (when overwrite-supplied-p (myformat nil " :overwrite ~S" (transform-s-expr overwrite)))
      ")" )))

   `(service-request ,req-string))))

(defmacro compute-abox-difference ( a b &key  (also-unmapped-differences-p nil also-unmapped-differences-p-supplied-p) (remove-redundant-diffs-p nil remove-redundant-diffs-p-supplied-p) (optimizer-max-plans nil optimizer-max-plans-supplied-p) (known-correspondances nil known-correspondances-supplied-p) (auto-correspondances-p nil auto-correspondances-p-supplied-p) (only-difference-p nil only-difference-p-supplied-p) (full-tuples-p nil full-tuples-p-supplied-p) (show-score-p nil show-score-p-supplied-p) (equi-order-by nil equi-order-by-supplied-p) (remove-implied-concept-assertions-p nil remove-implied-concept-assertions-p-supplied-p) (remove-common-assertions-p nil remove-common-assertions-p-supplied-p) (common-assertions-as-strict-atoms-p nil common-assertions-as-strict-atoms-p-supplied-p) (map-new-inds-to-new-inds-p nil map-new-inds-to-new-inds-p-supplied-p) (cutoff-fn nil cutoff-fn-supplied-p) (hypo-mode-stack nil hypo-mode-stack-supplied-p) (c-mode nil c-mode-supplied-p) (r-mode nil r-mode-supplied-p) (only-best-p nil only-best-p-supplied-p) (order-by nil order-by-supplied-p) (reverse-order-p nil reverse-order-p-supplied-p) (ensure-permutations-p nil ensure-permutations-p-supplied-p) (how-many nil how-many-supplied-p) (strategy nil strategy-supplied-p) (simple-result-p nil simple-result-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (same-as-only-p nil same-as-only-p-supplied-p) (candidate-individuals nil candidate-individuals-supplied-p) (binding-validator nil binding-validator-supplied-p))
 (declare (ignorable  also-unmapped-differences-p remove-redundant-diffs-p optimizer-max-plans known-correspondances auto-correspondances-p only-difference-p full-tuples-p show-score-p equi-order-by remove-implied-concept-assertions-p remove-common-assertions-p common-assertions-as-strict-atoms-p map-new-inds-to-new-inds-p cutoff-fn hypo-mode-stack c-mode r-mode only-best-p order-by reverse-order-p ensure-permutations-p how-many strategy simple-result-p runtime-consistency-checking-p final-consistency-checking-p same-as-only-p candidate-individuals binding-validator a b))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "compute-abox-difference"
      (myformat nil " ~S" (transform-s-expr a))
      (myformat nil " ~S" (transform-s-expr b))
      (when also-unmapped-differences-p-supplied-p (myformat nil " :also-unmapped-differences-p ~S" (transform-s-expr also-unmapped-differences-p)))
      (when remove-redundant-diffs-p-supplied-p (myformat nil " :remove-redundant-diffs-p ~S" (transform-s-expr remove-redundant-diffs-p)))
      (when optimizer-max-plans-supplied-p (myformat nil " :optimizer-max-plans ~S" (transform-s-expr optimizer-max-plans)))
      (when known-correspondances-supplied-p (myformat nil " :known-correspondances ~S" (transform-s-expr known-correspondances)))
      (when auto-correspondances-p-supplied-p (myformat nil " :auto-correspondances-p ~S" (transform-s-expr auto-correspondances-p)))
      (when only-difference-p-supplied-p (myformat nil " :only-difference-p ~S" (transform-s-expr only-difference-p)))
      (when full-tuples-p-supplied-p (myformat nil " :full-tuples-p ~S" (transform-s-expr full-tuples-p)))
      (when show-score-p-supplied-p (myformat nil " :show-score-p ~S" (transform-s-expr show-score-p)))
      (when equi-order-by-supplied-p (myformat nil " :equi-order-by ~S" (transform-s-expr equi-order-by)))
      (when remove-implied-concept-assertions-p-supplied-p (myformat nil " :remove-implied-concept-assertions-p ~S" (transform-s-expr remove-implied-concept-assertions-p)))
      (when remove-common-assertions-p-supplied-p (myformat nil " :remove-common-assertions-p ~S" (transform-s-expr remove-common-assertions-p)))
      (when common-assertions-as-strict-atoms-p-supplied-p (myformat nil " :common-assertions-as-strict-atoms-p ~S" (transform-s-expr common-assertions-as-strict-atoms-p)))
      (when map-new-inds-to-new-inds-p-supplied-p (myformat nil " :map-new-inds-to-new-inds-p ~S" (transform-s-expr map-new-inds-to-new-inds-p)))
      (when cutoff-fn-supplied-p (myformat nil " :cutoff-fn ~S" (transform-s-expr cutoff-fn)))
      (when hypo-mode-stack-supplied-p (myformat nil " :hypo-mode-stack ~S" (transform-s-expr hypo-mode-stack)))
      (when c-mode-supplied-p (myformat nil " :c-mode ~S" (transform-s-expr c-mode)))
      (when r-mode-supplied-p (myformat nil " :r-mode ~S" (transform-s-expr r-mode)))
      (when only-best-p-supplied-p (myformat nil " :only-best-p ~S" (transform-s-expr only-best-p)))
      (when order-by-supplied-p (myformat nil " :order-by ~S" (transform-s-expr order-by)))
      (when reverse-order-p-supplied-p (myformat nil " :reverse-order-p ~S" (transform-s-expr reverse-order-p)))
      (when ensure-permutations-p-supplied-p (myformat nil " :ensure-permutations-p ~S" (transform-s-expr ensure-permutations-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when strategy-supplied-p (myformat nil " :strategy ~S" (transform-s-expr strategy)))
      (when simple-result-p-supplied-p (myformat nil " :simple-result-p ~S" (transform-s-expr simple-result-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when same-as-only-p-supplied-p (myformat nil " :same-as-only-p ~S" (transform-s-expr same-as-only-p)))
      (when candidate-individuals-supplied-p (myformat nil " :candidate-individuals ~S" (transform-s-expr candidate-individuals)))
      (when binding-validator-supplied-p (myformat nil " :binding-validator ~S" (transform-s-expr binding-validator)))
      ")" )))

   `(service-request ,req-string))))

(defmacro compute-abox-difference-alternative ( a b &key  (also-unmapped-differences-p nil also-unmapped-differences-p-supplied-p) (remove-redundant-diffs-p nil remove-redundant-diffs-p-supplied-p) (optimizer-max-plans nil optimizer-max-plans-supplied-p) (known-correspondances nil known-correspondances-supplied-p) (auto-correspondances-p nil auto-correspondances-p-supplied-p) (only-difference-p nil only-difference-p-supplied-p) (full-tuples-p nil full-tuples-p-supplied-p) (show-score-p nil show-score-p-supplied-p) (equi-order-by nil equi-order-by-supplied-p) (remove-implied-concept-assertions-p nil remove-implied-concept-assertions-p-supplied-p) (remove-common-assertions-p nil remove-common-assertions-p-supplied-p) (common-assertions-as-strict-atoms-p nil common-assertions-as-strict-atoms-p-supplied-p) (map-new-inds-to-new-inds-p nil map-new-inds-to-new-inds-p-supplied-p) (cutoff-fn nil cutoff-fn-supplied-p) (hypo-mode-stack nil hypo-mode-stack-supplied-p) (c-mode nil c-mode-supplied-p) (r-mode nil r-mode-supplied-p) (only-best-p nil only-best-p-supplied-p) (order-by nil order-by-supplied-p) (reverse-order-p nil reverse-order-p-supplied-p) (ensure-permutations-p nil ensure-permutations-p-supplied-p) (how-many nil how-many-supplied-p) (strategy nil strategy-supplied-p) (simple-result-p nil simple-result-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (same-as-only-p nil same-as-only-p-supplied-p) (candidate-individuals nil candidate-individuals-supplied-p) (binding-validator nil binding-validator-supplied-p))
 (declare (ignorable  also-unmapped-differences-p remove-redundant-diffs-p optimizer-max-plans known-correspondances auto-correspondances-p only-difference-p full-tuples-p show-score-p equi-order-by remove-implied-concept-assertions-p remove-common-assertions-p common-assertions-as-strict-atoms-p map-new-inds-to-new-inds-p cutoff-fn hypo-mode-stack c-mode r-mode only-best-p order-by reverse-order-p ensure-permutations-p how-many strategy simple-result-p runtime-consistency-checking-p final-consistency-checking-p same-as-only-p candidate-individuals binding-validator a b))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "compute-abox-difference-alternative"
      (myformat nil " ~S" (transform-s-expr a))
      (myformat nil " ~S" (transform-s-expr b))
      (when also-unmapped-differences-p-supplied-p (myformat nil " :also-unmapped-differences-p ~S" (transform-s-expr also-unmapped-differences-p)))
      (when remove-redundant-diffs-p-supplied-p (myformat nil " :remove-redundant-diffs-p ~S" (transform-s-expr remove-redundant-diffs-p)))
      (when optimizer-max-plans-supplied-p (myformat nil " :optimizer-max-plans ~S" (transform-s-expr optimizer-max-plans)))
      (when known-correspondances-supplied-p (myformat nil " :known-correspondances ~S" (transform-s-expr known-correspondances)))
      (when auto-correspondances-p-supplied-p (myformat nil " :auto-correspondances-p ~S" (transform-s-expr auto-correspondances-p)))
      (when only-difference-p-supplied-p (myformat nil " :only-difference-p ~S" (transform-s-expr only-difference-p)))
      (when full-tuples-p-supplied-p (myformat nil " :full-tuples-p ~S" (transform-s-expr full-tuples-p)))
      (when show-score-p-supplied-p (myformat nil " :show-score-p ~S" (transform-s-expr show-score-p)))
      (when equi-order-by-supplied-p (myformat nil " :equi-order-by ~S" (transform-s-expr equi-order-by)))
      (when remove-implied-concept-assertions-p-supplied-p (myformat nil " :remove-implied-concept-assertions-p ~S" (transform-s-expr remove-implied-concept-assertions-p)))
      (when remove-common-assertions-p-supplied-p (myformat nil " :remove-common-assertions-p ~S" (transform-s-expr remove-common-assertions-p)))
      (when common-assertions-as-strict-atoms-p-supplied-p (myformat nil " :common-assertions-as-strict-atoms-p ~S" (transform-s-expr common-assertions-as-strict-atoms-p)))
      (when map-new-inds-to-new-inds-p-supplied-p (myformat nil " :map-new-inds-to-new-inds-p ~S" (transform-s-expr map-new-inds-to-new-inds-p)))
      (when cutoff-fn-supplied-p (myformat nil " :cutoff-fn ~S" (transform-s-expr cutoff-fn)))
      (when hypo-mode-stack-supplied-p (myformat nil " :hypo-mode-stack ~S" (transform-s-expr hypo-mode-stack)))
      (when c-mode-supplied-p (myformat nil " :c-mode ~S" (transform-s-expr c-mode)))
      (when r-mode-supplied-p (myformat nil " :r-mode ~S" (transform-s-expr r-mode)))
      (when only-best-p-supplied-p (myformat nil " :only-best-p ~S" (transform-s-expr only-best-p)))
      (when order-by-supplied-p (myformat nil " :order-by ~S" (transform-s-expr order-by)))
      (when reverse-order-p-supplied-p (myformat nil " :reverse-order-p ~S" (transform-s-expr reverse-order-p)))
      (when ensure-permutations-p-supplied-p (myformat nil " :ensure-permutations-p ~S" (transform-s-expr ensure-permutations-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when strategy-supplied-p (myformat nil " :strategy ~S" (transform-s-expr strategy)))
      (when simple-result-p-supplied-p (myformat nil " :simple-result-p ~S" (transform-s-expr simple-result-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when same-as-only-p-supplied-p (myformat nil " :same-as-only-p ~S" (transform-s-expr same-as-only-p)))
      (when candidate-individuals-supplied-p (myformat nil " :candidate-individuals ~S" (transform-s-expr candidate-individuals)))
      (when binding-validator-supplied-p (myformat nil " :binding-validator ~S" (transform-s-expr binding-validator)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept-ancestors ( concept-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-ancestors"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept-children ( concept-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-children"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept-descendants ( concept-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-descendants"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept-disjoint? ( concept-1 concept-2 &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name concept-1 concept-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-disjoint?"
      (myformat nil " ~S" (transform-s-expr concept-1))
      (myformat nil " ~S" (transform-s-expr concept-2))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept-equivalent? ( concept-1 concept-2 &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name concept-1 concept-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-equivalent?"
      (myformat nil " ~S" (transform-s-expr concept-1))
      (myformat nil " ~S" (transform-s-expr concept-2))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept-instances ( concept-term &optional  (abox nil abox-supplied-p) (candidates nil candidates-supplied-p))
 (declare (ignorable  abox candidates concept-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-instances"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when candidates-supplied-p (myformat nil " ~S" (transform-s-expr candidates)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept-is-primitive? ( concept-name &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-is-primitive?"
      (myformat nil " ~S" (transform-s-expr concept-name))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept-parents ( concept-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-parents"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept-satisfiable? ( concept-1 &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name concept-1))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-satisfiable?"
      (myformat nil " ~S" (transform-s-expr concept-1))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept-subsumes? ( concept-1 concept-2 &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name concept-1 concept-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-subsumes?"
      (myformat nil " ~S" (transform-s-expr concept-1))
      (myformat nil " ~S" (transform-s-expr concept-2))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept-synonyms ( concept-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept-synonyms"
      (myformat nil " ~S" (transform-s-expr concept-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro concept? ( concept-name &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name concept-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "concept?"
      (myformat nil " ~S" (transform-s-expr concept-name))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro constrained ( individual object attribute)
 (declare (ignorable  individual object attribute))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "constrained"
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr object))
      (myformat nil " ~S" (transform-s-expr attribute))
      ")" )))

   `(service-request ,req-string))))

(defmacro constraint-entailed? ( constraint &optional  (abox-name nil abox-name-supplied-p))
 (declare (ignorable  abox-name constraint))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "constraint-entailed?"
      (myformat nil " ~S" (transform-s-expr constraint))
      (when abox-name-supplied-p (myformat nil " ~S" (transform-s-expr abox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro constraints ( &rest  forms)
 (declare (ignorable  forms))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "constraints"
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr forms))
      ")" )))

   `(service-request ,req-string))))

(defmacro data-edge ( from to data-relation &optional  (racer-descr nil racer-descr-supplied-p) (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  racer-descr abox type-of-substrate from to data-relation))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "data-edge"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (myformat nil " ~S" (transform-s-expr data-relation))
      (when racer-descr-supplied-p (myformat nil " ~S" (transform-s-expr racer-descr)))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro data-node ( name &optional  (descr nil descr-supplied-p) (racer-descr nil racer-descr-supplied-p) (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  descr racer-descr abox type-of-substrate name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "data-node"
      (myformat nil " ~S" (transform-s-expr name))
      (when descr-supplied-p (myformat nil " ~S" (transform-s-expr descr)))
      (when racer-descr-supplied-p (myformat nil " ~S" (transform-s-expr racer-descr)))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro datatype-role-filler ( individual value role &optional  (type nil type-supplied-p))
 (declare (ignorable  type individual value role))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "datatype-role-filler"
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr value))
      (myformat nil " ~S" (transform-s-expr role))
      (when type-supplied-p (myformat nil " ~S" (transform-s-expr type)))
      ")" )))

   `(service-request ,req-string))))

(defmacro def-and-exec-query ( name head body &key  (keep-p nil keep-p-supplied-p) (tbox nil tbox-supplied-p) (consider-head-atom-for-consistency-check-p nil consider-head-atom-for-consistency-check-p-supplied-p) (allow-multiple-definitions-p nil allow-multiple-definitions-p-supplied-p))
 (declare (ignorable  keep-p tbox consider-head-atom-for-consistency-check-p allow-multiple-definitions-p name head body))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "def-and-exec-query"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr head))
      (myformat nil " ~S" (transform-s-expr body))
      (when keep-p-supplied-p (myformat nil " :keep-p ~S" (transform-s-expr keep-p)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when consider-head-atom-for-consistency-check-p-supplied-p (myformat nil " :consider-head-atom-for-consistency-check-p ~S" (transform-s-expr consider-head-atom-for-consistency-check-p)))
      (when allow-multiple-definitions-p-supplied-p (myformat nil " :allow-multiple-definitions-p ~S" (transform-s-expr allow-multiple-definitions-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro def-and-prep-query ( name head body &key  (keep-p nil keep-p-supplied-p) (tbox nil tbox-supplied-p) (consider-head-atom-for-consistency-check-p nil consider-head-atom-for-consistency-check-p-supplied-p) (allow-multiple-definitions-p nil allow-multiple-definitions-p-supplied-p))
 (declare (ignorable  keep-p tbox consider-head-atom-for-consistency-check-p allow-multiple-definitions-p name head body))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "def-and-prep-query"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr head))
      (myformat nil " ~S" (transform-s-expr body))
      (when keep-p-supplied-p (myformat nil " :keep-p ~S" (transform-s-expr keep-p)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when consider-head-atom-for-consistency-check-p-supplied-p (myformat nil " :consider-head-atom-for-consistency-check-p ~S" (transform-s-expr consider-head-atom-for-consistency-check-p)))
      (when allow-multiple-definitions-p-supplied-p (myformat nil " :allow-multiple-definitions-p ~S" (transform-s-expr allow-multiple-definitions-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro defcon ( name value)
 (declare (ignorable  name value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "defcon"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr value))
      ")" )))

   `(service-request ,req-string))))

(defmacro define ( name arglist)
 (declare (ignorable  name arglist))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr arglist))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-abox ( abox-name &rest  axioms)
 (declare (ignorable  axioms abox-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-abox"
      (myformat nil " ~S" (transform-s-expr abox-name))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr axioms))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-concept ( name definition)
 (declare (ignorable  name definition))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-concept"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr definition))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-concrete-domain-attribute ( name &key  (domain nil domain-supplied-p) (type nil type-supplied-p))
 (declare (ignorable  domain type name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-concrete-domain-attribute"
      (myformat nil " ~S" (transform-s-expr name))
      (when domain-supplied-p (myformat nil " :domain ~S" (transform-s-expr domain)))
      (when type-supplied-p (myformat nil " :type ~S" (transform-s-expr type)))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-datatype-property ( &rest  args)
 (declare (ignorable  args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-datatype-property"
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-disjoint-primitive-concept ( name disjoint-list definition)
 (declare (ignorable  name disjoint-list definition))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-disjoint-primitive-concept"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr disjoint-list))
      (myformat nil " ~S" (transform-s-expr definition))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-distinct-individual ( individual-name &optional  (concept nil concept-supplied-p))
 (declare (ignorable  concept individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-distinct-individual"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when concept-supplied-p (myformat nil " ~S" (transform-s-expr concept)))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-event-assertion ( assertion)
 (declare (ignorable  assertion))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-event-assertion"
      (myformat nil " ~S" (transform-s-expr assertion))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-event-rule ( head &rest  body)
 (declare (ignorable  body head))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-event-rule"
      (myformat nil " ~S" (transform-s-expr head))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr body))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-individual ( individual-name &optional  (concept nil concept-supplied-p))
 (declare (ignorable  concept individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-individual"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when concept-supplied-p (myformat nil " ~S" (transform-s-expr concept)))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-prefix ( prefix mapping)
 (declare (ignorable  prefix mapping))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-prefix"
      (myformat nil " ~S" (transform-s-expr prefix))
      (myformat nil " ~S" (transform-s-expr mapping))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-primitive-attribute ( name &key  (parent nil parent-supplied-p) (parents nil parents-supplied-p) (domain nil domain-supplied-p) (range nil range-supplied-p) (inverse nil inverse-supplied-p) (symmetric nil symmetric-supplied-p) (asymmetric nil asymmetric-supplied-p) (reflexive nil reflexive-supplied-p) (irreflexive nil irreflexive-supplied-p))
 (declare (ignorable  parent parents domain range inverse symmetric asymmetric reflexive irreflexive name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-primitive-attribute"
      (myformat nil " ~S" (transform-s-expr name))
      (when parent-supplied-p (myformat nil " :parent ~S" (transform-s-expr parent)))
      (when parents-supplied-p (myformat nil " :parents ~S" (transform-s-expr parents)))
      (when domain-supplied-p (myformat nil " :domain ~S" (transform-s-expr domain)))
      (when range-supplied-p (myformat nil " :range ~S" (transform-s-expr range)))
      (when inverse-supplied-p (myformat nil " :inverse ~S" (transform-s-expr inverse)))
      (when symmetric-supplied-p (myformat nil " :symmetric ~S" (transform-s-expr symmetric)))
      (when asymmetric-supplied-p (myformat nil " :asymmetric ~S" (transform-s-expr asymmetric)))
      (when reflexive-supplied-p (myformat nil " :reflexive ~S" (transform-s-expr reflexive)))
      (when irreflexive-supplied-p (myformat nil " :irreflexive ~S" (transform-s-expr irreflexive)))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-primitive-concept ( name &optional  (definition nil definition-supplied-p))
 (declare (ignorable  definition name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-primitive-concept"
      (myformat nil " ~S" (transform-s-expr name))
      (when definition-supplied-p (myformat nil " ~S" (transform-s-expr definition)))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-primitive-role ( name &key  (parents nil parents-supplied-p) (parent nil parent-supplied-p) (transitive nil transitive-supplied-p) (feature nil feature-supplied-p) (domain nil domain-supplied-p) (range nil range-supplied-p) (inverse nil inverse-supplied-p) (symmetric nil symmetric-supplied-p) (reflexive nil reflexive-supplied-p) (irreflexive nil irreflexive-supplied-p) (asymmetric nil asymmetric-supplied-p) (compositions nil compositions-supplied-p))
 (declare (ignorable  parents parent transitive feature domain range inverse symmetric reflexive irreflexive asymmetric compositions name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-primitive-role"
      (myformat nil " ~S" (transform-s-expr name))
      (when parents-supplied-p (myformat nil " :parents ~S" (transform-s-expr parents)))
      (when parent-supplied-p (myformat nil " :parent ~S" (transform-s-expr parent)))
      (when transitive-supplied-p (myformat nil " :transitive ~S" (transform-s-expr transitive)))
      (when feature-supplied-p (myformat nil " :feature ~S" (transform-s-expr feature)))
      (when domain-supplied-p (myformat nil " :domain ~S" (transform-s-expr domain)))
      (when range-supplied-p (myformat nil " :range ~S" (transform-s-expr range)))
      (when inverse-supplied-p (myformat nil " :inverse ~S" (transform-s-expr inverse)))
      (when symmetric-supplied-p (myformat nil " :symmetric ~S" (transform-s-expr symmetric)))
      (when reflexive-supplied-p (myformat nil " :reflexive ~S" (transform-s-expr reflexive)))
      (when irreflexive-supplied-p (myformat nil " :irreflexive ~S" (transform-s-expr irreflexive)))
      (when asymmetric-supplied-p (myformat nil " :asymmetric ~S" (transform-s-expr asymmetric)))
      (when compositions-supplied-p (myformat nil " :compositions ~S" (transform-s-expr compositions)))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-rule ( lefthand-side righthand-side &key  (forward-rule-p nil forward-rule-p-supplied-p) (backward-rule-p nil backward-rule-p-supplied-p))
 (declare (ignorable  forward-rule-p backward-rule-p lefthand-side righthand-side))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-rule"
      (myformat nil " ~S" (transform-s-expr lefthand-side))
      (myformat nil " ~S" (transform-s-expr righthand-side))
      (when forward-rule-p-supplied-p (myformat nil " :forward-rule-p ~S" (transform-s-expr forward-rule-p)))
      (when backward-rule-p-supplied-p (myformat nil " :backward-rule-p ~S" (transform-s-expr backward-rule-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro define-tbox ( name &rest  axioms)
 (declare (ignorable  axioms name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "define-tbox"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr axioms))
      ")" )))

   `(service-request ,req-string))))

(defmacro defpar ( name value)
 (declare (ignorable  name value))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "defpar"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr value))
      ")" )))

   `(service-request ,req-string))))

(defmacro defquery ( name head body &key  (keep-p nil keep-p-supplied-p) (tbox nil tbox-supplied-p) (consider-head-atom-for-consistency-check-p nil consider-head-atom-for-consistency-check-p-supplied-p) (allow-multiple-definitions-p nil allow-multiple-definitions-p-supplied-p))
 (declare (ignorable  keep-p tbox consider-head-atom-for-consistency-check-p allow-multiple-definitions-p name head body))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "defquery"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr head))
      (myformat nil " ~S" (transform-s-expr body))
      (when keep-p-supplied-p (myformat nil " :keep-p ~S" (transform-s-expr keep-p)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when consider-head-atom-for-consistency-check-p-supplied-p (myformat nil " :consider-head-atom-for-consistency-check-p ~S" (transform-s-expr consider-head-atom-for-consistency-check-p)))
      (when allow-multiple-definitions-p-supplied-p (myformat nil " :allow-multiple-definitions-p ~S" (transform-s-expr allow-multiple-definitions-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro del-data-edge ( from to &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate from to))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "del-data-edge"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro del-data-node ( name &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "del-data-node"
      (myformat nil " ~S" (transform-s-expr name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro del-doc-entry ( label)
 (declare (ignorable  label))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "del-doc-entry"
      (myformat nil " ~S" (transform-s-expr label))
      ")" )))

   `(service-request ,req-string))))

(defmacro del-rcc-edge ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "del-rcc-edge"
      ")" )))

   `(service-request ,req-string))))

(defmacro del-rcc-node ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "del-rcc-node"
      ")" )))

   `(service-request ,req-string))))

(defmacro delete-abox ( abox)
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-abox"
      (myformat nil " ~S" (transform-s-expr abox))
      ")" )))

   `(service-request ,req-string))))

(defmacro delete-tbox ( tbox)
 (declare (ignorable  tbox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "delete-tbox"
      (myformat nil " ~S" (transform-s-expr tbox))
      ")" )))

   `(service-request ,req-string))))

(defmacro description-implies? ( a b)
 (declare (ignorable  a b))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "description-implies?"
      (myformat nil " ~S" (transform-s-expr a))
      (myformat nil " ~S" (transform-s-expr b))
      ")" )))

   `(service-request ,req-string))))

(defmacro different-from ( individual-name-1 individual-name-2)
 (declare (ignorable  individual-name-1 individual-name-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "different-from"
      (myformat nil " ~S" (transform-s-expr individual-name-1))
      (myformat nil " ~S" (transform-s-expr individual-name-2))
      ")" )))

   `(service-request ,req-string))))

(defmacro direct-predecessors ( role-term ind-filler &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox role-term ind-filler))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "direct-predecessors"
      (myformat nil " ~S" (transform-s-expr role-term))
      (myformat nil " ~S" (transform-s-expr ind-filler))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro disjoint ( &rest  concept-names)
 (declare (ignorable  concept-names))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "disjoint"
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr concept-names))
      ")" )))

   `(service-request ,req-string))))

(defmacro domain ( rolename concept &optional  (tbox nil tbox-supplied-p) (errorp nil errorp-supplied-p))
 (declare (ignorable  tbox errorp rolename concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "domain"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr concept))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when errorp-supplied-p (myformat nil " ~S" (transform-s-expr errorp)))
      ")" )))

   `(service-request ,req-string))))

(defmacro edge-description ( from to &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate from to))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "edge-description"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro edge-label ( from to &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate from to))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "edge-label"
      (myformat nil " ~S" (transform-s-expr from))
      (myformat nil " ~S" (transform-s-expr to))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro equivalent ( left right)
 (declare (ignorable  left right))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "equivalent"
      (myformat nil " ~S" (transform-s-expr left))
      (myformat nil " ~S" (transform-s-expr right))
      ")" )))

   `(service-request ,req-string))))

(defmacro feature? ( role-term &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "feature?"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro firerule ( query res-args &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "firerule"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro firerule-under-premise ( query res-args &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "firerule-under-premise"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro firerule-under-premise1 ( res-args query &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "firerule-under-premise1"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro firerule1 ( res-args query &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "firerule1"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro forget ( &rest  assertions)
 (declare (ignorable  assertions))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "forget"
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr assertions))
      ")" )))

   `(service-request ,req-string))))

(defmacro functional ( rolename &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox rolename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "functional"
      (myformat nil " ~S" (transform-s-expr rolename))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro get-concept-definition ( concept-name &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-concept-definition"
      (myformat nil " ~S" (transform-s-expr concept-name))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro get-concept-negated-definition ( concept-name &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox concept-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-concept-negated-definition"
      (myformat nil " ~S" (transform-s-expr concept-name))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro implies ( left right)
 (declare (ignorable  left right))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "implies"
      (myformat nil " ~S" (transform-s-expr left))
      (myformat nil " ~S" (transform-s-expr right))
      ")" )))

   `(service-request ,req-string))))

(defmacro implies-role ( rolename-1 rolename-2 &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox rolename-1 rolename-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "implies-role"
      (myformat nil " ~S" (transform-s-expr rolename-1))
      (myformat nil " ~S" (transform-s-expr rolename-2))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro in-abox ( abox-name &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name abox-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "in-abox"
      (myformat nil " ~S" (transform-s-expr abox-name))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro in-data-box ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "in-data-box"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   `(service-request ,req-string))))

(defmacro in-knowledge-base ( tbox-name &rest  args)
 (declare (ignorable  args tbox-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "in-knowledge-base"
      (myformat nil " ~S" (transform-s-expr tbox-name))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   `(service-request ,req-string))))

(defmacro in-mirror-data-box ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "in-mirror-data-box"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   `(service-request ,req-string))))

(defmacro in-rcc-box ( name &optional  (rcc-type nil rcc-type-supplied-p) (type nil type-supplied-p))
 (declare (ignorable  rcc-type type name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "in-rcc-box"
      (myformat nil " ~S" (transform-s-expr name))
      (when rcc-type-supplied-p (myformat nil " ~S" (transform-s-expr rcc-type)))
      (when type-supplied-p (myformat nil " ~S" (transform-s-expr type)))
      ")" )))

   `(service-request ,req-string))))

(defmacro in-tbox ( name &key  (init nil init-supplied-p) (size nil size-supplied-p) (role-size nil role-size-supplied-p) (signature nil signature-supplied-p))
 (declare (ignorable  init size role-size signature name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "in-tbox"
      (myformat nil " ~S" (transform-s-expr name))
      (when init-supplied-p (myformat nil " :init ~S" (transform-s-expr init)))
      (when size-supplied-p (myformat nil " :size ~S" (transform-s-expr size)))
      (when role-size-supplied-p (myformat nil " :role-size ~S" (transform-s-expr role-size)))
      (when signature-supplied-p (myformat nil " :signature ~S" (transform-s-expr signature)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individual-antonyms ( individual &optional  (told-only nil told-only-supplied-p) (abox-name nil abox-name-supplied-p))
 (declare (ignorable  told-only abox-name individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-antonyms"
      (myformat nil " ~S" (transform-s-expr individual))
      (when told-only-supplied-p (myformat nil " ~S" (transform-s-expr told-only)))
      (when abox-name-supplied-p (myformat nil " ~S" (transform-s-expr abox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individual-attribute-fillers ( ind attribute &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox ind attribute))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-attribute-fillers"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr attribute))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individual-direct-types ( individual-name &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-direct-types"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individual-filled-roles ( ind-predecessor ind-filler &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox ind-predecessor ind-filler))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-filled-roles"
      (myformat nil " ~S" (transform-s-expr ind-predecessor))
      (myformat nil " ~S" (transform-s-expr ind-filler))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individual-fillers ( ind-predecessor role-term &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox ind-predecessor role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-fillers"
      (myformat nil " ~S" (transform-s-expr ind-predecessor))
      (myformat nil " ~S" (transform-s-expr role-term))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individual-instance? ( individual concept &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-instance?"
      (myformat nil " ~S" (transform-s-expr individual))
      (myformat nil " ~S" (transform-s-expr concept))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individual-synonyms ( individual &optional  (told-only nil told-only-supplied-p) (abox-name nil abox-name-supplied-p))
 (declare (ignorable  told-only abox-name individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-synonyms"
      (myformat nil " ~S" (transform-s-expr individual))
      (when told-only-supplied-p (myformat nil " ~S" (transform-s-expr told-only)))
      (when abox-name-supplied-p (myformat nil " ~S" (transform-s-expr abox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individual-told-attribute-value ( ind attribute &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox ind attribute))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-told-attribute-value"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr attribute))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individual-told-datatype-fillers ( ind datatype-role &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox ind datatype-role))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-told-datatype-fillers"
      (myformat nil " ~S" (transform-s-expr ind))
      (myformat nil " ~S" (transform-s-expr datatype-role))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individual-types ( individual-name &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual-types"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individual? ( individual-name &optional  (abox-name nil abox-name-supplied-p))
 (declare (ignorable  abox-name individual-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individual?"
      (myformat nil " ~S" (transform-s-expr individual-name))
      (when abox-name-supplied-p (myformat nil " ~S" (transform-s-expr abox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individuals-equal? ( individual-1 individual-2 &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual-1 individual-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individuals-equal?"
      (myformat nil " ~S" (transform-s-expr individual-1))
      (myformat nil " ~S" (transform-s-expr individual-2))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individuals-not-equal? ( individual-1 individual-2 &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual-1 individual-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individuals-not-equal?"
      (myformat nil " ~S" (transform-s-expr individual-1))
      (myformat nil " ~S" (transform-s-expr individual-2))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro individuals-related? ( individual-1 individual-2 role-term &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual-1 individual-2 role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "individuals-related?"
      (myformat nil " ~S" (transform-s-expr individual-1))
      (myformat nil " ~S" (transform-s-expr individual-2))
      (myformat nil " ~S" (transform-s-expr role-term))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro init-publications ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "init-publications"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro init-subscriptions ( &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "init-subscriptions"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro instance ( name concept)
 (declare (ignorable  name concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "instance"
      (myformat nil " ~S" (transform-s-expr name))
      (myformat nil " ~S" (transform-s-expr concept))
      ")" )))

   `(service-request ,req-string))))

(defmacro inverse ( rolename inverse-role &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox rolename inverse-role))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "inverse"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr inverse-role))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro irreflexive ( rolename &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox rolename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "irreflexive"
      (myformat nil " ~S" (transform-s-expr rolename))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro irreflexive? ( role-term &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "irreflexive?"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro node-description ( name &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "node-description"
      (myformat nil " ~S" (transform-s-expr name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro node-label ( name &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "node-label"
      (myformat nil " ~S" (transform-s-expr name))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro prepare-abox-query ( res-args query &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-abox-query"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro prepare-abox-query1 ( query res-args &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-abox-query1"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro prepare-abox-rule ( query res-args &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-abox-rule"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro prepare-abox-rule1 ( res-args query &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-abox-rule1"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro prepare-tbox-query ( res-args query &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (tbox nil tbox-supplied-p) (package nil package-supplied-p) (create-tbox-if-not-found-p nil create-tbox-if-not-found-p-supplied-p) (substrate nil substrate-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois tbox package create-tbox-if-not-found-p substrate res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-tbox-query"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when create-tbox-if-not-found-p-supplied-p (myformat nil " :create-tbox-if-not-found-p ~S" (transform-s-expr create-tbox-if-not-found-p)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro prepare-tbox-query1 ( query res-args &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (tbox nil tbox-supplied-p) (package nil package-supplied-p) (create-tbox-if-not-found-p nil create-tbox-if-not-found-p-supplied-p) (substrate nil substrate-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois tbox package create-tbox-if-not-found-p substrate query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "prepare-tbox-query1"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when create-tbox-if-not-found-p-supplied-p (myformat nil " :create-tbox-if-not-found-p ~S" (transform-s-expr create-tbox-if-not-found-p)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro preprule ( query res-args &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "preprule"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro preprule1 ( res-args query &key  (execute-p nil execute-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "preprule1"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro pretrieve ( head body &rest  args)
 (declare (ignorable  args head body))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "pretrieve"
      (myformat nil " ~S" (transform-s-expr head))
      (myformat nil " ~S" (transform-s-expr body))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   `(service-request ,req-string))))

(defmacro publish ( individual &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "publish"
      (myformat nil " ~S" (transform-s-expr individual))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro range ( rolename concept &optional  (tbox nil tbox-supplied-p) (errorp nil errorp-supplied-p))
 (declare (ignorable  tbox errorp rolename concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "range"
      (myformat nil " ~S" (transform-s-expr rolename))
      (myformat nil " ~S" (transform-s-expr concept))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      (when errorp-supplied-p (myformat nil " ~S" (transform-s-expr errorp)))
      ")" )))

   `(service-request ,req-string))))

(defmacro rcc-consistent? ( &optional  (abox nil abox-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p))
 (declare (ignorable  abox type-of-substrate))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-consistent?"
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when type-of-substrate-supplied-p (myformat nil " ~S" (transform-s-expr type-of-substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro rcc-edge ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-edge"
      ")" )))

   `(service-request ,req-string))))

(defmacro rcc-edge-description ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-edge-description"
      ")" )))

   `(service-request ,req-string))))

(defmacro rcc-edge-label ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-edge-label"
      ")" )))

   `(service-request ,req-string))))

(defmacro rcc-instance ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-instance"
      ")" )))

   `(service-request ,req-string))))

(defmacro rcc-node ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-node"
      ")" )))

   `(service-request ,req-string))))

(defmacro rcc-node-description ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-node-description"
      ")" )))

   `(service-request ,req-string))))

(defmacro rcc-node-label ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-node-label"
      ")" )))

   `(service-request ,req-string))))

(defmacro rcc-related ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-related"
      ")" )))

   `(service-request ,req-string))))

(defmacro rcc-synonym ( role rcc-relation)
 (declare (ignorable  role rcc-relation))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "rcc-synonym"
      (myformat nil " ~S" (transform-s-expr role))
      (myformat nil " ~S" (transform-s-expr rcc-relation))
      ")" )))

   `(service-request ,req-string))))

(defmacro reflexive ( rolename &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox rolename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "reflexive"
      (myformat nil " ~S" (transform-s-expr rolename))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro reflexive? ( role-term &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "reflexive?"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro related ( left-name right-name role-name)
 (declare (ignorable  left-name right-name role-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "related"
      (myformat nil " ~S" (transform-s-expr left-name))
      (myformat nil " ~S" (transform-s-expr right-name))
      (myformat nil " ~S" (transform-s-expr role-name))
      ")" )))

   `(service-request ,req-string))))

(defmacro related-individuals ( role-term &optional  (abox-name nil abox-name-supplied-p))
 (declare (ignorable  abox-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "related-individuals"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when abox-name-supplied-p (myformat nil " ~S" (transform-s-expr abox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro retrieve ( res-args query &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro retrieve-under-premise ( res-args query &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-under-premise"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro retrieve-under-premise1 ( query res-args &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-under-premise1"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro retrieve-with-explanation ( res-args query &rest  args &key  (cutoff-fn nil cutoff-fn-supplied-p) (hypo-mode-stack nil hypo-mode-stack-supplied-p) (c-mode nil c-mode-supplied-p) (r-mode nil r-mode-supplied-p) (only-best-p nil only-best-p-supplied-p) (order-by nil order-by-supplied-p) (reverse-order-p nil reverse-order-p-supplied-p) (ensure-permutations-p nil ensure-permutations-p-supplied-p) (how-many nil how-many-supplied-p) (strategy nil strategy-supplied-p) (simple-result-p nil simple-result-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (same-as-only-p nil same-as-only-p-supplied-p) (candidate-individuals nil candidate-individuals-supplied-p) (binding-validator nil binding-validator-supplied-p))
 (declare (ignorable  cutoff-fn hypo-mode-stack c-mode r-mode only-best-p order-by reverse-order-p ensure-permutations-p how-many strategy simple-result-p runtime-consistency-checking-p final-consistency-checking-p same-as-only-p candidate-individuals binding-validator args res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve-with-explanation"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when cutoff-fn-supplied-p (myformat nil " :cutoff-fn ~S" (transform-s-expr cutoff-fn)))
      (when hypo-mode-stack-supplied-p (myformat nil " :hypo-mode-stack ~S" (transform-s-expr hypo-mode-stack)))
      (when c-mode-supplied-p (myformat nil " :c-mode ~S" (transform-s-expr c-mode)))
      (when r-mode-supplied-p (myformat nil " :r-mode ~S" (transform-s-expr r-mode)))
      (when only-best-p-supplied-p (myformat nil " :only-best-p ~S" (transform-s-expr only-best-p)))
      (when order-by-supplied-p (myformat nil " :order-by ~S" (transform-s-expr order-by)))
      (when reverse-order-p-supplied-p (myformat nil " :reverse-order-p ~S" (transform-s-expr reverse-order-p)))
      (when ensure-permutations-p-supplied-p (myformat nil " :ensure-permutations-p ~S" (transform-s-expr ensure-permutations-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when strategy-supplied-p (myformat nil " :strategy ~S" (transform-s-expr strategy)))
      (when simple-result-p-supplied-p (myformat nil " :simple-result-p ~S" (transform-s-expr simple-result-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when same-as-only-p-supplied-p (myformat nil " :same-as-only-p ~S" (transform-s-expr same-as-only-p)))
      (when candidate-individuals-supplied-p (myformat nil " :candidate-individuals ~S" (transform-s-expr candidate-individuals)))
      (when binding-validator-supplied-p (myformat nil " :binding-validator ~S" (transform-s-expr binding-validator)))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   `(service-request ,req-string))))

(defmacro retrieve1 ( query res-args &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (substrate nil substrate-supplied-p) (abox nil abox-supplied-p) (create-abox-if-not-found-p nil create-abox-if-not-found-p-supplied-p) (package nil package-supplied-p) (type-of-substrate nil type-of-substrate-supplied-p) (prepare-now-p nil prepare-now-p-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois substrate abox create-abox-if-not-found-p package type-of-substrate prepare-now-p query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "retrieve1"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      (when create-abox-if-not-found-p-supplied-p (myformat nil " :create-abox-if-not-found-p ~S" (transform-s-expr create-abox-if-not-found-p)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when type-of-substrate-supplied-p (myformat nil " :type-of-substrate ~S" (transform-s-expr type-of-substrate)))
      (when prepare-now-p-supplied-p (myformat nil " :prepare-now-p ~S" (transform-s-expr prepare-now-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-ancestors ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-ancestors"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-children ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-children"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-descendants ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-descendants"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-disjoint? ( role-term-1 role-term-2 &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term-1 role-term-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-disjoint?"
      (myformat nil " ~S" (transform-s-expr role-term-1))
      (myformat nil " ~S" (transform-s-expr role-term-2))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-domain ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-domain"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-equivalent? ( role-term-1 role-term-2 &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term-1 role-term-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-equivalent?"
      (myformat nil " ~S" (transform-s-expr role-term-1))
      (myformat nil " ~S" (transform-s-expr role-term-2))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-inverse ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-inverse"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-parents ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-parents"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-range ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-range"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-satisfiable? ( role &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-satisfiable?"
      (myformat nil " ~S" (transform-s-expr role))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-subsumes? ( role-term-1 role-term-2 &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term-1 role-term-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-subsumes?"
      (myformat nil " ~S" (transform-s-expr role-term-1))
      (myformat nil " ~S" (transform-s-expr role-term-2))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role-synonyms ( role-term &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role-synonyms"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro role? ( role-term &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "role?"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro roles-disjoint ( role1 role2 &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role1 role2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "roles-disjoint"
      (myformat nil " ~S" (transform-s-expr role1))
      (myformat nil " ~S" (transform-s-expr role2))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro roles-equivalent ( role1 role2 &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox role1 role2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "roles-equivalent"
      (myformat nil " ~S" (transform-s-expr role1))
      (myformat nil " ~S" (transform-s-expr role2))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro same-as ( individual-name-1 individual-name-2)
 (declare (ignorable  individual-name-1 individual-name-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "same-as"
      (myformat nil " ~S" (transform-s-expr individual-name-1))
      (myformat nil " ~S" (transform-s-expr individual-name-2))
      ")" )))

   `(service-request ,req-string))))

(defmacro same-individual-as ( individual-name-1 individual-name-2)
 (declare (ignorable  individual-name-1 individual-name-2))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "same-individual-as"
      (myformat nil " ~S" (transform-s-expr individual-name-1))
      (myformat nil " ~S" (transform-s-expr individual-name-2))
      ")" )))

   `(service-request ,req-string))))

(defmacro signature ( &key  (atomic-concepts nil atomic-concepts-supplied-p) (roles nil roles-supplied-p) (transitive-roles nil transitive-roles-supplied-p) (features nil features-supplied-p) (attributes nil attributes-supplied-p) (individuals nil individuals-supplied-p) (objects nil objects-supplied-p))
 (declare (ignorable  atomic-concepts roles transitive-roles features attributes individuals objects))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "signature"
      (when atomic-concepts-supplied-p (myformat nil " :atomic-concepts ~S" (transform-s-expr atomic-concepts)))
      (when roles-supplied-p (myformat nil " :roles ~S" (transform-s-expr roles)))
      (when transitive-roles-supplied-p (myformat nil " :transitive-roles ~S" (transform-s-expr transitive-roles)))
      (when features-supplied-p (myformat nil " :features ~S" (transform-s-expr features)))
      (when attributes-supplied-p (myformat nil " :attributes ~S" (transform-s-expr attributes)))
      (when individuals-supplied-p (myformat nil " :individuals ~S" (transform-s-expr individuals)))
      (when objects-supplied-p (myformat nil " :objects ~S" (transform-s-expr objects)))
      ")" )))

   `(service-request ,req-string))))

(defmacro sparql-answer-query ( sparql-query &rest  args &key  (racer nil racer-supplied-p) (stream nil stream-supplied-p) (native nil native-supplied-p) (add-standard-prefixes nil add-standard-prefixes-supplied-p) (use-optimizer nil use-optimizer-supplied-p))
 (declare (ignorable  racer stream native add-standard-prefixes use-optimizer args sparql-query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "sparql-answer-query"
      (myformat nil " ~S" (transform-s-expr sparql-query))
      (when racer-supplied-p (myformat nil " :racer ~S" (transform-s-expr racer)))
      (when stream-supplied-p (myformat nil " :stream ~S" (transform-s-expr stream)))
      (when native-supplied-p (myformat nil " :native ~S" (transform-s-expr native)))
      (when add-standard-prefixes-supplied-p (myformat nil " :add-standard-prefixes ~S" (transform-s-expr add-standard-prefixes)))
      (when use-optimizer-supplied-p (myformat nil " :use-optimizer ~S" (transform-s-expr use-optimizer)))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   `(service-request ,req-string))))

(defmacro sparql-retrieve ( sparql-query &rest  args &key  (racer nil racer-supplied-p) (stream nil stream-supplied-p) (native nil native-supplied-p) (add-standard-prefixes nil add-standard-prefixes-supplied-p) (use-optimizer nil use-optimizer-supplied-p))
 (declare (ignorable  racer stream native add-standard-prefixes use-optimizer args sparql-query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "sparql-retrieve"
      (myformat nil " ~S" (transform-s-expr sparql-query))
      (when racer-supplied-p (myformat nil " :racer ~S" (transform-s-expr racer)))
      (when stream-supplied-p (myformat nil " :stream ~S" (transform-s-expr stream)))
      (when native-supplied-p (myformat nil " :native ~S" (transform-s-expr native)))
      (when add-standard-prefixes-supplied-p (myformat nil " :add-standard-prefixes ~S" (transform-s-expr add-standard-prefixes)))
      (when use-optimizer-supplied-p (myformat nil " :use-optimizer ~S" (transform-s-expr use-optimizer)))
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr args))
      ")" )))

   `(service-request ,req-string))))

(defmacro state ( &rest  forms)
 (declare (ignorable  forms))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "state"
      (myformat nil " ~{ ~S~}" (mapcar #'transform-s-expr forms))
      ")" )))

   `(service-request ,req-string))))

(defmacro subscribe ( subscriber query-concept &optional  (abox nil abox-supplied-p) (ip nil ip-supplied-p) (port nil port-supplied-p) (use-simplified-protocol-p nil use-simplified-protocol-p-supplied-p))
 (declare (ignorable  abox ip port use-simplified-protocol-p subscriber query-concept))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "subscribe"
      (myformat nil " ~S" (transform-s-expr subscriber))
      (myformat nil " ~S" (transform-s-expr query-concept))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      (when ip-supplied-p (myformat nil " ~S" (transform-s-expr ip)))
      (when port-supplied-p (myformat nil " ~S" (transform-s-expr port)))
      (when use-simplified-protocol-p-supplied-p (myformat nil " ~S" (transform-s-expr use-simplified-protocol-p)))
      ")" )))

   `(service-request ,req-string))))

(defmacro symmetric ( rolename &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox rolename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "symmetric"
      (myformat nil " ~S" (transform-s-expr rolename))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro symmetric? ( role-term &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "symmetric?"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro tbox-classified? ( &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "tbox-classified?"
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro tbox-coherent? ( &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "tbox-coherent?"
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro tbox-cyclic? ( &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "tbox-cyclic?"
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro tbox-prepared? ( &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "tbox-prepared?"
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro tbox-retrieve ( res-args query &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (tbox nil tbox-supplied-p) (package nil package-supplied-p) (create-tbox-if-not-found-p nil create-tbox-if-not-found-p-supplied-p) (substrate nil substrate-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois tbox package create-tbox-if-not-found-p substrate res-args query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "tbox-retrieve"
      (myformat nil " ~S" (transform-s-expr res-args))
      (myformat nil " ~S" (transform-s-expr query))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when create-tbox-if-not-found-p-supplied-p (myformat nil " :create-tbox-if-not-found-p ~S" (transform-s-expr create-tbox-if-not-found-p)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro tbox-retrieve1 ( query res-args &key  (execute-p nil execute-p-supplied-p) (dont-add-abox-duplicates-p nil dont-add-abox-duplicates-p-supplied-p) (remove-duplicates-p nil remove-duplicates-p-supplied-p) (two-phase-processing-p nil two-phase-processing-p-supplied-p) (deliver-phase-two-warning-tokens-p nil deliver-phase-two-warning-tokens-p-supplied-p) (deliver-kb-has-changed-warning-tokens-p nil deliver-kb-has-changed-warning-tokens-p-supplied-p) (add-rule-consequences-p nil add-rule-consequences-p-supplied-p) (continuation-based-instance-retrieval-p nil continuation-based-instance-retrieval-p-supplied-p) (told-information-reasoning-p nil told-information-reasoning-p-supplied-p) (final-consistency-checking-p nil final-consistency-checking-p-supplied-p) (runtime-consistency-checking-p nil runtime-consistency-checking-p-supplied-p) (verbose-p nil verbose-p-supplied-p) (dont-show-variables nil dont-show-variables-supplied-p) (dont-show-head-projection-operators-p nil dont-show-head-projection-operators-p-supplied-p) (dont-show-lambdas-p nil dont-show-lambdas-p-supplied-p) (how-many nil how-many-supplied-p) (only-new-tuples-p nil only-new-tuples-p-supplied-p) (timeout nil timeout-supplied-p) (proactive-tuple-computation-p nil proactive-tuple-computation-p-supplied-p) (tuple-at-a-time-p nil tuple-at-a-time-p-supplied-p) (use-individual-synonyms-p nil use-individual-synonyms-p-supplied-p) (check-abox-consistency-p nil check-abox-consistency-p-supplied-p) (ensure-tbox-classification-p nil ensure-tbox-classification-p-supplied-p) (initial-abox-mirroring-p nil initial-abox-mirroring-p-supplied-p) (initial-role-assertion-mirroring-p nil initial-role-assertion-mirroring-p-supplied-p) (classify-concepts-in-instance-assertions-p nil classify-concepts-in-instance-assertions-p-supplied-p) (exclude-permutations-p nil exclude-permutations-p-supplied-p) (record-explanations-p nil record-explanations-p-supplied-p) (parser-class nil parser-class-supplied-p) (rewrite-defined-concepts-p nil rewrite-defined-concepts-p-supplied-p) (group-by-ops nil group-by-ops-supplied-p) (bind-specials-p nil bind-specials-p-supplied-p) (original-query nil original-query-supplied-p) (rule-con-pattern nil rule-con-pattern-supplied-p) (new-ind-ops nil new-ind-ops-supplied-p) (premise nil premise-supplied-p) (generate-code-p nil generate-code-p-supplied-p) (optimize-p nil optimize-p-supplied-p) (rewrite-semantically-p nil rewrite-semantically-p-supplied-p) (rewrite-to-dnf-p nil rewrite-to-dnf-p-supplied-p) (report-inconsistent-queries-p nil report-inconsistent-queries-p-supplied-p) (report-tautological-queries-p nil report-tautological-queries-p-supplied-p) (use-repository-p nil use-repository-p-supplied-p) (put-into-repository-p nil put-into-repository-p-supplied-p) (id nil id-supplied-p) (dont-check-id-p nil dont-check-id-p-supplied-p) (parser nil parser-supplied-p) (result-vois nil result-vois-supplied-p) (tbox nil tbox-supplied-p) (package nil package-supplied-p) (create-tbox-if-not-found-p nil create-tbox-if-not-found-p-supplied-p) (substrate nil substrate-supplied-p))
 (declare (ignorable  execute-p dont-add-abox-duplicates-p remove-duplicates-p two-phase-processing-p deliver-phase-two-warning-tokens-p deliver-kb-has-changed-warning-tokens-p add-rule-consequences-p continuation-based-instance-retrieval-p told-information-reasoning-p final-consistency-checking-p runtime-consistency-checking-p verbose-p dont-show-variables dont-show-head-projection-operators-p dont-show-lambdas-p how-many only-new-tuples-p timeout proactive-tuple-computation-p tuple-at-a-time-p use-individual-synonyms-p check-abox-consistency-p ensure-tbox-classification-p initial-abox-mirroring-p initial-role-assertion-mirroring-p classify-concepts-in-instance-assertions-p exclude-permutations-p record-explanations-p parser-class rewrite-defined-concepts-p group-by-ops bind-specials-p original-query rule-con-pattern new-ind-ops premise generate-code-p optimize-p rewrite-semantically-p rewrite-to-dnf-p report-inconsistent-queries-p report-tautological-queries-p use-repository-p put-into-repository-p id dont-check-id-p parser result-vois tbox package create-tbox-if-not-found-p substrate query res-args))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "tbox-retrieve1"
      (myformat nil " ~S" (transform-s-expr query))
      (myformat nil " ~S" (transform-s-expr res-args))
      (when execute-p-supplied-p (myformat nil " :execute-p ~S" (transform-s-expr execute-p)))
      (when dont-add-abox-duplicates-p-supplied-p (myformat nil " :dont-add-abox-duplicates-p ~S" (transform-s-expr dont-add-abox-duplicates-p)))
      (when remove-duplicates-p-supplied-p (myformat nil " :remove-duplicates-p ~S" (transform-s-expr remove-duplicates-p)))
      (when two-phase-processing-p-supplied-p (myformat nil " :two-phase-processing-p ~S" (transform-s-expr two-phase-processing-p)))
      (when deliver-phase-two-warning-tokens-p-supplied-p (myformat nil " :deliver-phase-two-warning-tokens-p ~S" (transform-s-expr deliver-phase-two-warning-tokens-p)))
      (when deliver-kb-has-changed-warning-tokens-p-supplied-p (myformat nil " :deliver-kb-has-changed-warning-tokens-p ~S" (transform-s-expr deliver-kb-has-changed-warning-tokens-p)))
      (when add-rule-consequences-p-supplied-p (myformat nil " :add-rule-consequences-p ~S" (transform-s-expr add-rule-consequences-p)))
      (when continuation-based-instance-retrieval-p-supplied-p (myformat nil " :continuation-based-instance-retrieval-p ~S" (transform-s-expr continuation-based-instance-retrieval-p)))
      (when told-information-reasoning-p-supplied-p (myformat nil " :told-information-reasoning-p ~S" (transform-s-expr told-information-reasoning-p)))
      (when final-consistency-checking-p-supplied-p (myformat nil " :final-consistency-checking-p ~S" (transform-s-expr final-consistency-checking-p)))
      (when runtime-consistency-checking-p-supplied-p (myformat nil " :runtime-consistency-checking-p ~S" (transform-s-expr runtime-consistency-checking-p)))
      (when verbose-p-supplied-p (myformat nil " :verbose-p ~S" (transform-s-expr verbose-p)))
      (when dont-show-variables-supplied-p (myformat nil " :dont-show-variables ~S" (transform-s-expr dont-show-variables)))
      (when dont-show-head-projection-operators-p-supplied-p (myformat nil " :dont-show-head-projection-operators-p ~S" (transform-s-expr dont-show-head-projection-operators-p)))
      (when dont-show-lambdas-p-supplied-p (myformat nil " :dont-show-lambdas-p ~S" (transform-s-expr dont-show-lambdas-p)))
      (when how-many-supplied-p (myformat nil " :how-many ~S" (transform-s-expr how-many)))
      (when only-new-tuples-p-supplied-p (myformat nil " :only-new-tuples-p ~S" (transform-s-expr only-new-tuples-p)))
      (when timeout-supplied-p (myformat nil " :timeout ~S" (transform-s-expr timeout)))
      (when proactive-tuple-computation-p-supplied-p (myformat nil " :proactive-tuple-computation-p ~S" (transform-s-expr proactive-tuple-computation-p)))
      (when tuple-at-a-time-p-supplied-p (myformat nil " :tuple-at-a-time-p ~S" (transform-s-expr tuple-at-a-time-p)))
      (when use-individual-synonyms-p-supplied-p (myformat nil " :use-individual-synonyms-p ~S" (transform-s-expr use-individual-synonyms-p)))
      (when check-abox-consistency-p-supplied-p (myformat nil " :check-abox-consistency-p ~S" (transform-s-expr check-abox-consistency-p)))
      (when ensure-tbox-classification-p-supplied-p (myformat nil " :ensure-tbox-classification-p ~S" (transform-s-expr ensure-tbox-classification-p)))
      (when initial-abox-mirroring-p-supplied-p (myformat nil " :initial-abox-mirroring-p ~S" (transform-s-expr initial-abox-mirroring-p)))
      (when initial-role-assertion-mirroring-p-supplied-p (myformat nil " :initial-role-assertion-mirroring-p ~S" (transform-s-expr initial-role-assertion-mirroring-p)))
      (when classify-concepts-in-instance-assertions-p-supplied-p (myformat nil " :classify-concepts-in-instance-assertions-p ~S" (transform-s-expr classify-concepts-in-instance-assertions-p)))
      (when exclude-permutations-p-supplied-p (myformat nil " :exclude-permutations-p ~S" (transform-s-expr exclude-permutations-p)))
      (when record-explanations-p-supplied-p (myformat nil " :record-explanations-p ~S" (transform-s-expr record-explanations-p)))
      (when parser-class-supplied-p (myformat nil " :parser-class ~S" (transform-s-expr parser-class)))
      (when rewrite-defined-concepts-p-supplied-p (myformat nil " :rewrite-defined-concepts-p ~S" (transform-s-expr rewrite-defined-concepts-p)))
      (when group-by-ops-supplied-p (myformat nil " :group-by-ops ~S" (transform-s-expr group-by-ops)))
      (when bind-specials-p-supplied-p (myformat nil " :bind-specials-p ~S" (transform-s-expr bind-specials-p)))
      (when original-query-supplied-p (myformat nil " :original-query ~S" (transform-s-expr original-query)))
      (when rule-con-pattern-supplied-p (myformat nil " :rule-con-pattern ~S" (transform-s-expr rule-con-pattern)))
      (when new-ind-ops-supplied-p (myformat nil " :new-ind-ops ~S" (transform-s-expr new-ind-ops)))
      (when premise-supplied-p (myformat nil " :premise ~S" (transform-s-expr premise)))
      (when generate-code-p-supplied-p (myformat nil " :generate-code-p ~S" (transform-s-expr generate-code-p)))
      (when optimize-p-supplied-p (myformat nil " :optimize-p ~S" (transform-s-expr optimize-p)))
      (when rewrite-semantically-p-supplied-p (myformat nil " :rewrite-semantically-p ~S" (transform-s-expr rewrite-semantically-p)))
      (when rewrite-to-dnf-p-supplied-p (myformat nil " :rewrite-to-dnf-p ~S" (transform-s-expr rewrite-to-dnf-p)))
      (when report-inconsistent-queries-p-supplied-p (myformat nil " :report-inconsistent-queries-p ~S" (transform-s-expr report-inconsistent-queries-p)))
      (when report-tautological-queries-p-supplied-p (myformat nil " :report-tautological-queries-p ~S" (transform-s-expr report-tautological-queries-p)))
      (when use-repository-p-supplied-p (myformat nil " :use-repository-p ~S" (transform-s-expr use-repository-p)))
      (when put-into-repository-p-supplied-p (myformat nil " :put-into-repository-p ~S" (transform-s-expr put-into-repository-p)))
      (when id-supplied-p (myformat nil " :id ~S" (transform-s-expr id)))
      (when dont-check-id-p-supplied-p (myformat nil " :dont-check-id-p ~S" (transform-s-expr dont-check-id-p)))
      (when parser-supplied-p (myformat nil " :parser ~S" (transform-s-expr parser)))
      (when result-vois-supplied-p (myformat nil " :result-vois ~S" (transform-s-expr result-vois)))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when package-supplied-p (myformat nil " :package ~S" (transform-s-expr package)))
      (when create-tbox-if-not-found-p-supplied-p (myformat nil " :create-tbox-if-not-found-p ~S" (transform-s-expr create-tbox-if-not-found-p)))
      (when substrate-supplied-p (myformat nil " :substrate ~S" (transform-s-expr substrate)))
      ")" )))

   `(service-request ,req-string))))

(defmacro timenet-retrieve ( query &key  (abox nil abox-supplied-p))
 (declare (ignorable  abox query))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "timenet-retrieve"
      (myformat nil " ~S" (transform-s-expr query))
      (when abox-supplied-p (myformat nil " :abox ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro transitive ( rolename &optional  (tbox nil tbox-supplied-p))
 (declare (ignorable  tbox rolename))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "transitive"
      (myformat nil " ~S" (transform-s-expr rolename))
      (when tbox-supplied-p (myformat nil " ~S" (transform-s-expr tbox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro transitive? ( role-term &optional  (tbox-name nil tbox-name-supplied-p))
 (declare (ignorable  tbox-name role-term))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "transitive?"
      (myformat nil " ~S" (transform-s-expr role-term))
      (when tbox-name-supplied-p (myformat nil " ~S" (transform-s-expr tbox-name)))
      ")" )))

   `(service-request ,req-string))))

(defmacro unbind ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "unbind"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   `(service-request ,req-string))))

(defmacro undefine ( name)
 (declare (ignorable  name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "undefine"
      (myformat nil " ~S" (transform-s-expr name))
      ")" )))

   `(service-request ,req-string))))

(defmacro undefquery ( name &key  (tbox nil tbox-supplied-p) (arity nil arity-supplied-p))
 (declare (ignorable  tbox arity name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "undefquery"
      (myformat nil " ~S" (transform-s-expr name))
      (when tbox-supplied-p (myformat nil " :tbox ~S" (transform-s-expr tbox)))
      (when arity-supplied-p (myformat nil " :arity ~S" (transform-s-expr arity)))
      ")" )))

   `(service-request ,req-string))))

(defmacro unpublish ( individual &optional  (abox nil abox-supplied-p))
 (declare (ignorable  abox individual))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "unpublish"
      (myformat nil " ~S" (transform-s-expr individual))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(defmacro unrelated ( left-name right-name role-name)
 (declare (ignorable  left-name right-name role-name))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "unrelated"
      (myformat nil " ~S" (transform-s-expr left-name))
      (myformat nil " ~S" (transform-s-expr right-name))
      (myformat nil " ~S" (transform-s-expr role-name))
      ")" )))

   `(service-request ,req-string))))

(defmacro unsubscribe ( subscriber &optional  (query-concept nil query-concept-supplied-p) (abox nil abox-supplied-p))
 (declare (ignorable  query-concept abox subscriber))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "unsubscribe"
      (myformat nil " ~S" (transform-s-expr subscriber))
      (when query-concept-supplied-p (myformat nil " ~S" (transform-s-expr query-concept)))
      (when abox-supplied-p (myformat nil " ~S" (transform-s-expr abox)))
      ")" )))

   `(service-request ,req-string))))

(declare-with-macro with-bindings  (&key))

(declare-with-macro with-bindings-evaluated  (&key))

(declare-with-macro with-critical-section)

(declare-with-macro with-future-bindings  (&key))

(declare-with-macro with-future-bindings-evaluated  (&key))

(declare-with-macro with-nrql-settings  (&key mode dont-show-variables dont-show-lambdas dont-show-head-projection-operators abox-mirroring query-optimization optimizer-use-cardinality-heuristics how-many-tuples timeout warnings add-rule-consequences-automatically dont-add-abox-duplicates two-phase-query-processing-mode phase-two-starts-warning-tokens kb-has-changed-warning-tokens told-information-querying tuple-computation-mode exclude-permutations query-repository report-inconsistent-queries report-tautological-queries query-realization bindings check-abox-consistency use-individual-equivalence-classes rewrite-to-dnf type-of-substrate abox tbox))

(declare-with-macro with-nrql-settings-evaluated  (&key mode dont-show-variables dont-show-lambdas dont-show-head-projection-operators abox-mirroring query-optimization optimizer-use-cardinality-heuristics how-many-tuples timeout warnings add-rule-consequences-automatically dont-add-abox-duplicates two-phase-query-processing-mode phase-two-starts-warning-tokens kb-has-changed-warning-tokens told-information-querying tuple-computation-mode exclude-permutations query-repository report-inconsistent-queries report-tautological-queries query-realization bindings check-abox-consistency use-individual-equivalence-classes rewrite-to-dnf type-of-substrate abox tbox))

(declare-with-macro with-unique-name-assumption)

(declare-with-macro without-unique-name-assumption)

(defmacro xml-output ( expr)
 (declare (ignorable  expr))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "xml-output"
      (myformat nil " ~S" (transform-s-expr expr))
      ")" )))

   `(service-request ,req-string))))

(defmacro xml-native-output ( expr)
 (declare (ignorable  expr))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "xml-native-output"
      (myformat nil " ~S" (transform-s-expr expr))
      ")" )))

   `(service-request ,req-string))))

(defmacro xml-input ( expr)
 (declare (ignorable  expr))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "xml-input"
      (myformat nil " ~S" (transform-s-expr expr))
      ")" )))

   `(service-request ,req-string))))

(defmacro |OWLAPI-sequence| (&body body)
  (with-standard-io-syntax-1
    `(service-request
      ,(myformat nil "(~A ~{ ~S~})"
      "owlapi-sequence"
      (mapcar #'transform-s-expr body)))))

(defmacro |OWLAPI-quietSequence| (&body body)
  (with-standard-io-syntax-1
    `(service-request
      ,(myformat nil "(~A ~{ ~S~})"
      "owlapi-quietsequence"
      (mapcar #'transform-s-expr body)))))

(defmacro |OWLAPI-getLastOutputStreamString| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getLastOutputStreamString|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   `(service-request ,req-string))))

(defmacro |OWLAPI-getLastAnswer| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getLastAnswer|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   `(service-request ,req-string))))

(defmacro |OWLAPI-getIDsOfLastAnswer| ( &optional  (reasoner nil reasoner-supplied-p))
 (declare (ignorable  reasoner))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "|OWLAPI-getIDsOfLastAnswer|"
      (when reasoner-supplied-p (myformat nil " ~S" (transform-s-expr reasoner)))
      ")" )))

   `(service-request ,req-string))))

(defmacro |OWLAPI-answerSequence| (&body body)
  (with-standard-io-syntax-1
    `(service-request
      ,(myformat nil "(~A ~{ ~S~})"
      "owlapi-answersequence"
      (mapcar #'transform-s-expr body)))))

(defmacro get-racer-version ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-racer-version"
      ")" )))

   `(service-request ,req-string))))

(defmacro get-namespace-prefixes ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "get-namespace-prefixes"
      ")" )))

   `(service-request ,req-string))))

(defmacro ensure-small-tboxes ()
 (declare (ignorable ))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "ensure-small-tboxes"
      ")" )))

   `(service-request ,req-string))))

(defmacro answer-sequence (&body body)
  (with-standard-io-syntax-1
    `(service-request
      ,(myformat nil "(~A ~{ ~S~})"
      "answer-sequence"
      (mapcar #'transform-s-expr body)))))

(defmacro evaluate ( expr)
 (declare (ignorable  expr))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "evaluate"
      (myformat nil " ~S" (transform-s-expr expr))
      ")" )))

   `(service-request ,req-string))))

(defmacro evaluate1 ( expr)
 (declare (ignorable  expr))
  (with-standard-io-syntax-1
    (let ((req-string
           (concatenate 'string 
      "("
      "evaluate1"
      (myformat nil " ~S" (transform-s-expr expr))
      ")" )))

   `(service-request ,req-string))))

(defun exit-server ()
  (declare (ignorable))
  (handler-case (with-standard-io-syntax-1
                 (let ((req-string
                        (concatenate 'string "(" "exit-server" ")")))
                   (service-request req-string)))
                (racer-error (error) (error error))
                (lracer-connection-error (error) t)))

